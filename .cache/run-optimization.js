import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.endsWith("...")) {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _collectValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      previous.push(value);
      return previous;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._collectValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  function humanReadableArgName(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.minWidthToWrap = 40;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    prepareContext(contextOptions) {
      this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      const helpCommand = cmd._getHelpCommand();
      if (helpCommand && !helpCommand._hidden) {
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a, b) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a).localeCompare(getSortKey(b));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const helpOption = cmd._getHelpOption();
      if (helpOption && !helpOption.hidden) {
        const removeShort = helpOption.short && cmd._findOption(helpOption.short);
        const removeLong = helpOption.long && cmd._findOption(helpOption.long);
        if (!removeShort && !removeLong) {
          visibleOptions.push(helpOption);
        } else if (helpOption.long && !removeLong) {
          visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
        } else if (helpOption.short && !removeShort) {
          visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
        }
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper) {
      return helper.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
      }, 0);
    }
    longestOptionTermLength(cmd, helper) {
      return helper.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper) {
      return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
      }, 0);
    }
    longestArgumentTermLength(cmd, helper) {
      return helper.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        const extraDescription = `(${extraInfo.join(", ")})`;
        if (option.description) {
          return `${option.description} ${extraDescription}`;
        }
        return extraDescription;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescription = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescription}`;
        }
        return extraDescription;
      }
      return argument.description;
    }
    formatItemList(heading, items, helper) {
      if (items.length === 0)
        return [];
      return [helper.styleTitle(heading), ...items, ""];
    }
    groupItems(unsortedItems, visibleItems, getGroup) {
      const result = new Map;
      unsortedItems.forEach((item) => {
        const group = getGroup(item);
        if (!result.has(group))
          result.set(group, []);
      });
      visibleItems.forEach((item) => {
        const group = getGroup(item);
        if (!result.has(group)) {
          result.set(group, []);
        }
        result.get(group).push(item);
      });
      return result;
    }
    formatHelp(cmd, helper) {
      const termWidth = helper.padWidth(cmd, helper);
      const helpWidth = helper.helpWidth ?? 80;
      function callFormatItem(term, description) {
        return helper.formatItem(term, termWidth, description, helper);
      }
      let output = [
        `${helper.styleTitle("Usage:")} ${helper.styleUsage(helper.commandUsage(cmd))}`,
        ""
      ];
      const commandDescription = helper.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([
          helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth),
          ""
        ]);
      }
      const argumentList = helper.visibleArguments(cmd).map((argument) => {
        return callFormatItem(helper.styleArgumentTerm(helper.argumentTerm(argument)), helper.styleArgumentDescription(helper.argumentDescription(argument)));
      });
      output = output.concat(this.formatItemList("Arguments:", argumentList, helper));
      const optionGroups = this.groupItems(cmd.options, helper.visibleOptions(cmd), (option) => option.helpGroupHeading ?? "Options:");
      optionGroups.forEach((options, group) => {
        const optionList = options.map((option) => {
          return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
        });
        output = output.concat(this.formatItemList(group, optionList, helper));
      });
      if (helper.showGlobalOptions) {
        const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
          return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
        });
        output = output.concat(this.formatItemList("Global Options:", globalOptionList, helper));
      }
      const commandGroups = this.groupItems(cmd.commands, helper.visibleCommands(cmd), (sub) => sub.helpGroup() || "Commands:");
      commandGroups.forEach((commands, group) => {
        const commandList = commands.map((sub) => {
          return callFormatItem(helper.styleSubcommandTerm(helper.subcommandTerm(sub)), helper.styleSubcommandDescription(helper.subcommandDescription(sub)));
        });
        output = output.concat(this.formatItemList(group, commandList, helper));
      });
      return output.join(`
`);
    }
    displayWidth(str) {
      return stripColor(str).length;
    }
    styleTitle(str) {
      return str;
    }
    styleUsage(str) {
      return str.split(" ").map((word) => {
        if (word === "[options]")
          return this.styleOptionText(word);
        if (word === "[command]")
          return this.styleSubcommandText(word);
        if (word[0] === "[" || word[0] === "<")
          return this.styleArgumentText(word);
        return this.styleCommandText(word);
      }).join(" ");
    }
    styleCommandDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleOptionDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleSubcommandDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleArgumentDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleDescriptionText(str) {
      return str;
    }
    styleOptionTerm(str) {
      return this.styleOptionText(str);
    }
    styleSubcommandTerm(str) {
      return str.split(" ").map((word) => {
        if (word === "[options]")
          return this.styleOptionText(word);
        if (word[0] === "[" || word[0] === "<")
          return this.styleArgumentText(word);
        return this.styleSubcommandText(word);
      }).join(" ");
    }
    styleArgumentTerm(str) {
      return this.styleArgumentText(str);
    }
    styleOptionText(str) {
      return str;
    }
    styleArgumentText(str) {
      return str;
    }
    styleSubcommandText(str) {
      return str;
    }
    styleCommandText(str) {
      return str;
    }
    padWidth(cmd, helper) {
      return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
    }
    preformatted(str) {
      return /\n[^\S\r\n]/.test(str);
    }
    formatItem(term, termWidth, description, helper) {
      const itemIndent = 2;
      const itemIndentStr = " ".repeat(itemIndent);
      if (!description)
        return itemIndentStr + term;
      const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));
      const spacerWidth = 2;
      const helpWidth = this.helpWidth ?? 80;
      const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
      let formattedDescription;
      if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) {
        formattedDescription = description;
      } else {
        const wrappedDescription = helper.boxWrap(description, remainingWidth);
        formattedDescription = wrappedDescription.replace(/\n/g, `
` + " ".repeat(termWidth + spacerWidth));
      }
      return itemIndentStr + paddedTerm + " ".repeat(spacerWidth) + formattedDescription.replace(/\n/g, `
${itemIndentStr}`);
    }
    boxWrap(str, width) {
      if (width < this.minWidthToWrap)
        return str;
      const rawLines = str.split(/\r\n|\n/);
      const chunkPattern = /[\s]*[^\s]+/g;
      const wrappedLines = [];
      rawLines.forEach((line) => {
        const chunks = line.match(chunkPattern);
        if (chunks === null) {
          wrappedLines.push("");
          return;
        }
        let sumChunks = [chunks.shift()];
        let sumWidth = this.displayWidth(sumChunks[0]);
        chunks.forEach((chunk) => {
          const visibleWidth = this.displayWidth(chunk);
          if (sumWidth + visibleWidth <= width) {
            sumChunks.push(chunk);
            sumWidth += visibleWidth;
            return;
          }
          wrappedLines.push(sumChunks.join(""));
          const nextChunk = chunk.trimStart();
          sumChunks = [nextChunk];
          sumWidth = this.displayWidth(nextChunk);
        });
        wrappedLines.push(sumChunks.join(""));
      });
      return wrappedLines.join(`
`);
    }
  }
  function stripColor(str) {
    const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
    return str.replace(sgrPattern, "");
  }
  exports.Help = Help;
  exports.stripColor = stripColor;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
      this.helpGroupHeading = undefined;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg) {
      this.presetArg = arg;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name) {
      this.envVar = name;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _collectValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      previous.push(value);
      return previous;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._collectValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      if (this.negate) {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      return camelcase(this.name());
    }
    helpGroup(heading) {
      this.helpGroupHeading = heading;
      return this;
    }
    is(arg) {
      return this.short === arg || this.long === arg;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value);
    }
  }
  function camelcase(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  }
  function splitOptionFlags(flags) {
    let shortFlag;
    let longFlag;
    const shortFlagExp = /^-[^-]$/;
    const longFlagExp = /^--[^-]/;
    const flagParts = flags.split(/[ |,]+/).concat("guard");
    if (shortFlagExp.test(flagParts[0]))
      shortFlag = flagParts.shift();
    if (longFlagExp.test(flagParts[0]))
      longFlag = flagParts.shift();
    if (!shortFlag && shortFlagExp.test(flagParts[0]))
      shortFlag = flagParts.shift();
    if (!shortFlag && longFlagExp.test(flagParts[0])) {
      shortFlag = longFlag;
      longFlag = flagParts.shift();
    }
    if (flagParts[0].startsWith("-")) {
      const unsupportedFlag = flagParts[0];
      const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
      if (/^-[^-][^-]/.test(unsupportedFlag))
        throw new Error(`${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);
      if (shortFlagExp.test(unsupportedFlag))
        throw new Error(`${baseError}
- too many short flags`);
      if (longFlagExp.test(unsupportedFlag))
        throw new Error(`${baseError}
- too many long flags`);
      throw new Error(`${baseError}
- unrecognised flag format`);
    }
    if (shortFlag === undefined && longFlag === undefined)
      throw new Error(`option creation failed due to no flags found in '${flags}'.`);
    return { shortFlag, longFlag };
  }
  exports.Option = Option;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var maxDistance = 3;
  function editDistance(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance)
      return Math.max(a.length, b.length);
    const d = [];
    for (let i = 0;i <= a.length; i++) {
      d[i] = [i];
    }
    for (let j = 0;j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1;j <= b.length; j++) {
      for (let i = 1;i <= a.length; i++) {
        let cost = 1;
        if (a[i - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  }
  function suggestSimilar(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `
(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `
(Did you mean ${similar[0]}?)`;
    }
    return "";
  }
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var EventEmitter = __require("node:events").EventEmitter;
  var childProcess = __require("node:child_process");
  var path = __require("node:path");
  var fs = __require("node:fs");
  var process2 = __require("node:process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help, stripColor } = require_help();
  var { Option, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter {
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = false;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._savedState = null;
      this._outputConfiguration = {
        writeOut: (str) => process2.stdout.write(str),
        writeErr: (str) => process2.stderr.write(str),
        outputError: (str, write) => write(str),
        getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : undefined,
        getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : undefined,
        getOutHasColors: () => useColor() ?? (process2.stdout.isTTY && process2.stdout.hasColors?.()),
        getErrHasColors: () => useColor() ?? (process2.stderr.isTTY && process2.stderr.hasColors?.()),
        stripColor: (str) => stripColor(str)
      };
      this._hidden = false;
      this._helpOption = undefined;
      this._addImplicitHelpCommand = undefined;
      this._helpCommand = undefined;
      this._helpConfiguration = {};
      this._helpGroupHeading = undefined;
      this._defaultCommandGroup = undefined;
      this._defaultOptionGroup = undefined;
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._helpOption = sourceCommand._helpOption;
      this._helpCommand = sourceCommand._helpCommand;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name) {
      return new Command(name);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      this._outputConfiguration = {
        ...this._outputConfiguration,
        ...configuration
      };
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd._checkForBrokenPassThrough();
      return this;
    }
    createArgument(name, description) {
      return new Argument(name, description);
    }
    argument(name, description, parseArg, defaultValue) {
      const argument = this.createArgument(name, description);
      if (typeof parseArg === "function") {
        argument.default(defaultValue).argParser(parseArg);
      } else {
        argument.default(parseArg);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument?.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    helpCommand(enableOrNameAndArgs, description) {
      if (typeof enableOrNameAndArgs === "boolean") {
        this._addImplicitHelpCommand = enableOrNameAndArgs;
        if (enableOrNameAndArgs && this._defaultCommandGroup) {
          this._initCommandGroup(this._getHelpCommand());
        }
        return this;
      }
      const nameAndArgs = enableOrNameAndArgs ?? "help [command]";
      const [, helpName, helpArgs] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const helpDescription = description ?? "display help for command";
      const helpCommand = this.createCommand(helpName);
      helpCommand.helpOption(false);
      if (helpArgs)
        helpCommand.arguments(helpArgs);
      if (helpDescription)
        helpCommand.description(helpDescription);
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      if (enableOrNameAndArgs || description)
        this._initCommandGroup(helpCommand);
      return this;
    }
    addHelpCommand(helpCommand, deprecatedDescription) {
      if (typeof helpCommand !== "object") {
        this.helpCommand(helpCommand, deprecatedDescription);
        return this;
      }
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      this._initCommandGroup(helpCommand);
      return this;
    }
    _getHelpCommand() {
      const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
      if (hasImplicitHelpCommand) {
        if (this._helpCommand === undefined) {
          this.helpCommand(undefined, undefined);
        }
        return this._helpCommand;
      }
      return null;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {}
        };
      }
      return this;
    }
    _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message));
      }
      process2.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value, previous, invalidArgumentMessage) {
      try {
        return target.parseArg(value, previous);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    _registerOption(option) {
      const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
      if (matchingOption) {
        const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
        throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
      }
      this._initOptionGroup(option);
      this.options.push(option);
    }
    _registerCommand(command) {
      const knownBy = (cmd) => {
        return [cmd.name()].concat(cmd.aliases());
      };
      const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
      if (alreadyUsed) {
        const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
        const newCmd = knownBy(command).join("|");
        throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
      }
      this._initCommandGroup(command);
      this.commands.push(command);
    }
    addOption(option) {
      this._registerOption(option);
      const oname = option.name();
      const name = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name, option.defaultValue, "default");
      }
      const handleOptionValue = (val, invalidValueMessage, valueSource) => {
        if (val == null && option.presetArg !== undefined) {
          val = option.presetArg;
        }
        const oldValue = this.getOptionValue(name);
        if (val !== null && option.parseArg) {
          val = this._callParseArg(option, val, oldValue, invalidValueMessage);
        } else if (val !== null && option.variadic) {
          val = option._collectValue(val, oldValue);
        }
        if (val == null) {
          if (option.negate) {
            val = false;
          } else if (option.isBoolean() || option.optional) {
            val = true;
          } else {
            val = "";
          }
        }
        this.setOptionValueWithSource(name, val, valueSource);
      };
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      this._checkForBrokenPassThrough();
      return this;
    }
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
        throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
      }
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      if (Object.keys(this._optionValues).length) {
        throw new Error("call .storeOptionsAsProperties() before setting option values");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value) {
      return this.setOptionValueWithSource(key, value, undefined);
    }
    setOptionValueWithSource(key, value, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined && parseOptions.from === undefined) {
        if (process2.versions?.electron) {
          parseOptions.from = "electron";
        }
        const execArgv = process2.execArgv ?? [];
        if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
          parseOptions.from = "eval";
        }
      }
      if (argv === undefined) {
        argv = process2.argv;
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process2.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        case "eval":
          userArgs = argv.slice(1);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      this._prepareForParse();
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      this._prepareForParse();
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _prepareForParse() {
      if (this._savedState === null) {
        this.saveStateBeforeParse();
      } else {
        this.restoreStateBeforeParse();
      }
    }
    saveStateBeforeParse() {
      this._savedState = {
        _name: this._name,
        _optionValues: { ...this._optionValues },
        _optionValueSources: { ...this._optionValueSources }
      };
    }
    restoreStateBeforeParse() {
      if (this._storeOptionsAsProperties)
        throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
      this._name = this._savedState._name;
      this._scriptPath = null;
      this.rawArgs = [];
      this._optionValues = { ...this._savedState._optionValues };
      this._optionValueSources = { ...this._savedState._optionValueSources };
      this.args = [];
      this.processedArgs = [];
    }
    _checkForMissingExecutable(executableFile, executableDir, subcommandName) {
      if (fs.existsSync(executableFile))
        return;
      const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
      const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
      throw new Error(executableMissing);
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path.resolve(baseDir, baseName);
        if (fs.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs.realpathSync(this._scriptPath);
        } catch {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path.extname(executableFile));
      let proc;
      if (process2.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process2.execArgv).concat(args);
        proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process2.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      proc.on("close", (code) => {
        code = code ?? 1;
        if (!exitCallback) {
          process2.exit(code);
        } else {
          exitCallback(new CommanderError(code, "commander.executeSubCommandAsync", "(close)"));
        }
      });
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process2.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      subCommand._prepareForParse();
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg, i) => {
        if (arg.required && this.args[i] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value, previous) => {
        let parsedValue = value;
        if (value !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index < this.args.length) {
            value = this.args.slice(index);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === undefined) {
            value = [];
          }
        } else if (index < this.args.length) {
          value = this.args[index];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index] = value;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise?.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        this._outputHelpIfRequested(unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      this._outputHelpIfRequested(parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent?.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name) {
      if (!name)
        return;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    _findOption(arg) {
      return this.options.find((option) => option.is(arg));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(args) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      const negativeNumberArg = (arg) => {
        if (!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(arg))
          return false;
        return !this._getCommandAndAncestors().some((cmd) => cmd.options.map((opt) => opt.short).some((short) => /^-\d$/.test(short)));
      };
      let activeVariadicOption = null;
      let activeGroup = null;
      let i = 0;
      while (i < args.length || activeGroup) {
        const arg = activeGroup ?? args[i++];
        activeGroup = null;
        if (arg === "--") {
          if (dest === unknown)
            dest.push(arg);
          dest.push(...args.slice(i));
          break;
        }
        if (activeVariadicOption && (!maybeOption(arg) || negativeNumberArg(arg))) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option = this._findOption(arg);
          if (option) {
            if (option.required) {
              const value = args[i++];
              if (value === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value);
            } else if (option.optional) {
              let value = null;
              if (i < args.length && (!maybeOption(args[i]) || negativeNumberArg(args[i]))) {
                value = args[i++];
              }
              this.emit(`option:${option.name()}`, value);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option = this._findOption(`-${arg[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              activeGroup = `-${arg.slice(2)}`;
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index = arg.indexOf("=");
          const option = this._findOption(arg.slice(0, index));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg.slice(index + 1));
            continue;
          }
        }
        if (dest === operands && maybeOption(arg) && !(this.commands.length === 0 && negativeNumberArg(arg))) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            unknown.push(...args.slice(i));
            break;
          } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
            operands.push(arg, ...args.slice(i));
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg, ...args.slice(i));
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg, ...args.slice(i));
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i = 0;i < len; i++) {
          const key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr(`
`);
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code = config.code || "commander.error";
      this._exit(exitCode, code, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && option.envVar in process2.env) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this._registerOption(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}
`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can't be the same as its name");
      const matchingCommand = this.parent?._findCommand(alias);
      if (matchingCommand) {
        const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
        throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
      }
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases) {
      if (aliases === undefined)
        return this._aliases;
      aliases.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    helpGroup(heading) {
      if (heading === undefined)
        return this._helpGroupHeading ?? "";
      this._helpGroupHeading = heading;
      return this;
    }
    commandsGroup(heading) {
      if (heading === undefined)
        return this._defaultCommandGroup ?? "";
      this._defaultCommandGroup = heading;
      return this;
    }
    optionsGroup(heading) {
      if (heading === undefined)
        return this._defaultOptionGroup ?? "";
      this._defaultOptionGroup = heading;
      return this;
    }
    _initOptionGroup(option) {
      if (this._defaultOptionGroup && !option.helpGroupHeading)
        option.helpGroup(this._defaultOptionGroup);
    }
    _initCommandGroup(cmd) {
      if (this._defaultCommandGroup && !cmd.helpGroup())
        cmd.helpGroup(this._defaultCommandGroup);
    }
    nameFromFilename(filename) {
      this._name = path.basename(filename, path.extname(filename));
      return this;
    }
    executableDir(path2) {
      if (path2 === undefined)
        return this._executableDir;
      this._executableDir = path2;
      return this;
    }
    helpInformation(contextOptions) {
      const helper = this.createHelp();
      const context = this._getOutputContext(contextOptions);
      helper.prepareContext({
        error: context.error,
        helpWidth: context.helpWidth,
        outputHasColors: context.hasColors
      });
      const text = helper.formatHelp(this, helper);
      if (context.hasColors)
        return text;
      return this._outputConfiguration.stripColor(text);
    }
    _getOutputContext(contextOptions) {
      contextOptions = contextOptions || {};
      const error = !!contextOptions.error;
      let baseWrite;
      let hasColors;
      let helpWidth;
      if (error) {
        baseWrite = (str) => this._outputConfiguration.writeErr(str);
        hasColors = this._outputConfiguration.getErrHasColors();
        helpWidth = this._outputConfiguration.getErrHelpWidth();
      } else {
        baseWrite = (str) => this._outputConfiguration.writeOut(str);
        hasColors = this._outputConfiguration.getOutHasColors();
        helpWidth = this._outputConfiguration.getOutHelpWidth();
      }
      const write = (str) => {
        if (!hasColors)
          str = this._outputConfiguration.stripColor(str);
        return baseWrite(str);
      };
      return { error, write, hasColors, helpWidth };
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const outputContext = this._getOutputContext(contextOptions);
      const eventContext = {
        error: outputContext.error,
        write: outputContext.write,
        command: this
      };
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", eventContext));
      this.emit("beforeHelp", eventContext);
      let helpInformation = this.helpInformation({ error: outputContext.error });
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      outputContext.write(helpInformation);
      if (this._getHelpOption()?.long) {
        this.emit(this._getHelpOption().long);
      }
      this.emit("afterHelp", eventContext);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", eventContext));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        if (flags) {
          if (this._helpOption === null)
            this._helpOption = undefined;
          if (this._defaultOptionGroup) {
            this._initOptionGroup(this._getHelpOption());
          }
        } else {
          this._helpOption = null;
        }
        return this;
      }
      this._helpOption = this.createOption(flags ?? "-h, --help", description ?? "display help for command");
      if (flags || description)
        this._initOptionGroup(this._helpOption);
      return this;
    }
    _getHelpOption() {
      if (this._helpOption === undefined) {
        this.helpOption(undefined, undefined);
      }
      return this._helpOption;
    }
    addHelpOption(option) {
      this._helpOption = option;
      this._initOptionGroup(option);
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = Number(process2.exitCode ?? 0);
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context.error, command: context.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context.write(`${helpStr}
`);
        }
      });
      return this;
    }
    _outputHelpIfRequested(args) {
      const helpOption = this._getHelpOption();
      const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
      if (helpRequested) {
        this.outputHelp();
        this._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
  }
  function incrementNodeInspectorPort(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg;
    });
  }
  function useColor() {
    if (process2.env.NO_COLOR || process2.env.FORCE_COLOR === "0" || process2.env.FORCE_COLOR === "false")
      return false;
    if (process2.env.FORCE_COLOR || process2.env.CLICOLOR_FORCE !== undefined)
      return true;
    return;
  }
  exports.Command = Command;
  exports.useColor = useColor;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports.program = new Command;
  exports.createCommand = (name) => new Command(name);
  exports.createOption = (flags, description) => new Option(flags, description);
  exports.createArgument = (name, description) => new Argument(name, description);
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// src/backtest/portfolio.ts
class Portfolio {
  capital;
  initialCapital;
  positions = new Map;
  tradeHistory = [];
  feeRate;
  constructor(initialCapital, feeRate = 0) {
    this.capital = initialCapital;
    this.initialCapital = initialCapital;
    this.feeRate = feeRate;
  }
  buy(tokenId, size, price, timestamp) {
    const totalCost = size * price;
    const fee = totalCost * this.feeRate;
    const totalWithFee = totalCost + fee;
    if (totalWithFee > this.capital + 0.001) {
      return {
        success: false,
        tokenId,
        side: "BUY",
        size: 0,
        price,
        totalCost: 0,
        error: `Insufficient capital: need ${totalWithFee.toFixed(2)}, have ${this.capital.toFixed(2)}`
      };
    }
    this.capital -= totalWithFee;
    const existing = this.positions.get(tokenId);
    if (existing) {
      const newSize = existing.size + size;
      const newAvgPrice = (existing.avgPrice * existing.size + price * size) / newSize;
      existing.size = newSize;
      existing.avgPrice = newAvgPrice;
      if (!existing.buyPrice) {
        existing.buyPrice = price;
      }
    } else {
      this.positions.set(tokenId, {
        tokenId,
        size,
        avgPrice: price,
        currentValue: size * price,
        pnl: 0,
        buyPrice: price
      });
    }
    const record = {
      timestamp,
      tokenId,
      side: "BUY",
      size,
      price,
      totalCost: totalWithFee,
      positionSizeAfter: this.positions.get(tokenId)?.size ?? 0,
      capitalAfter: this.capital
    };
    this.tradeHistory.push(record);
    return {
      success: true,
      tokenId,
      side: "BUY",
      size,
      price,
      totalCost: totalWithFee
    };
  }
  sell(tokenId, size, price, timestamp) {
    const position = this.positions.get(tokenId);
    if (!position || position.size < size) {
      return {
        success: false,
        tokenId,
        side: "SELL",
        size: 0,
        price,
        totalCost: 0,
        error: `Insufficient position: trying to sell ${size}, have ${position?.size ?? 0}`
      };
    }
    const totalValue = size * price;
    const fee = totalValue * this.feeRate;
    const totalAfterFee = totalValue - fee;
    this.capital += totalAfterFee;
    position.size -= size;
    if (position.size === 0) {
      this.positions.delete(tokenId);
    } else {
      position.currentValue = position.size * price;
    }
    const record = {
      timestamp,
      tokenId,
      side: "SELL",
      size,
      price,
      totalCost: totalAfterFee,
      positionSizeAfter: position.size,
      capitalAfter: this.capital
    };
    this.tradeHistory.push(record);
    return {
      success: true,
      tokenId,
      side: "SELL",
      size,
      price,
      totalCost: totalAfterFee
    };
  }
  close(tokenId, price, timestamp) {
    const position = this.positions.get(tokenId);
    if (!position) {
      return {
        success: false,
        tokenId,
        side: "SELL",
        size: 0,
        price,
        totalCost: 0,
        error: "No position to close"
      };
    }
    return this.sell(tokenId, position.size, price, timestamp);
  }
  updatePositionValues(prices) {
    for (const [tokenId, position] of this.positions) {
      const price = prices.get(tokenId);
      if (price !== undefined) {
        position.currentValue = position.size * price;
        position.pnl = position.currentValue - position.size * position.avgPrice;
      }
    }
  }
  getPosition(tokenId) {
    return this.positions.get(tokenId);
  }
  getAllPositions() {
    return Array.from(this.positions.values());
  }
  getCapital() {
    return this.capital;
  }
  getTotalValue(prices) {
    let total = this.capital;
    for (const [tokenId, position] of this.positions) {
      const price = prices.get(tokenId);
      if (price !== undefined) {
        total += position.size * price;
      }
    }
    return total;
  }
  getPnL(prices) {
    return this.getTotalValue(prices) - this.initialCapital;
  }
  getTradeHistory() {
    return [...this.tradeHistory];
  }
  getInitialCapital() {
    return this.initialCapital;
  }
}

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS((exports) => {
  var TypedArrayPrototypeGetSymbolToStringTag = (() => {
    const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
    return (value) => g.call(value);
  })();
  function isUint8Array(value) {
    return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
  }
  function isAnyArrayBuffer(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
  }
  function isRegExp(regexp2) {
    return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
  }
  function isMap(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
  }
  function isDate(date) {
    return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
  }
  function defaultInspect(x, _options) {
    return JSON.stringify(x, (k, v) => {
      if (typeof v === "bigint") {
        return { $numberLong: `${v}` };
      } else if (isMap(v)) {
        return Object.fromEntries(v);
      }
      return v;
    });
  }
  function getStylizeFunction(options) {
    const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
    if (stylizeExists) {
      return options.stylize;
    }
  }
  var BSON_MAJOR_VERSION = 6;
  var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = Math.pow(2, 63) - 1;
  var BSON_INT64_MIN = -Math.pow(2, 63);
  var JS_INT_MAX = Math.pow(2, 53);
  var JS_INT_MIN = -Math.pow(2, 53);
  var BSON_DATA_NUMBER = 1;
  var BSON_DATA_STRING = 2;
  var BSON_DATA_OBJECT = 3;
  var BSON_DATA_ARRAY = 4;
  var BSON_DATA_BINARY = 5;
  var BSON_DATA_UNDEFINED = 6;
  var BSON_DATA_OID = 7;
  var BSON_DATA_BOOLEAN = 8;
  var BSON_DATA_DATE = 9;
  var BSON_DATA_NULL = 10;
  var BSON_DATA_REGEXP = 11;
  var BSON_DATA_DBPOINTER = 12;
  var BSON_DATA_CODE = 13;
  var BSON_DATA_SYMBOL = 14;
  var BSON_DATA_CODE_W_SCOPE = 15;
  var BSON_DATA_INT = 16;
  var BSON_DATA_TIMESTAMP = 17;
  var BSON_DATA_LONG = 18;
  var BSON_DATA_DECIMAL128 = 19;
  var BSON_DATA_MIN_KEY = 255;
  var BSON_DATA_MAX_KEY = 127;
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  var BSONType = Object.freeze({
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: -1,
    maxKey: 127
  });

  class BSONError extends Error {
    get bsonError() {
      return true;
    }
    get name() {
      return "BSONError";
    }
    constructor(message, options) {
      super(message, options);
    }
    static isBSONError(value) {
      return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
    }
  }

  class BSONVersionError extends BSONError {
    get name() {
      return "BSONVersionError";
    }
    constructor() {
      super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
    }
  }

  class BSONRuntimeError extends BSONError {
    get name() {
      return "BSONRuntimeError";
    }
    constructor(message) {
      super(message);
    }
  }

  class BSONOffsetError extends BSONError {
    get name() {
      return "BSONOffsetError";
    }
    constructor(message, offset, options) {
      super(`${message}. offset: ${offset}`, options);
      this.offset = offset;
    }
  }
  var TextDecoderFatal;
  var TextDecoderNonFatal;
  function parseUtf8(buffer2, start, end, fatal) {
    if (fatal) {
      TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
      try {
        return TextDecoderFatal.decode(buffer2.subarray(start, end));
      } catch (cause) {
        throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
      }
    }
    TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
    return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
  }
  function tryReadBasicLatin(uint8array, start, end) {
    if (uint8array.length === 0) {
      return "";
    }
    const stringByteLength = end - start;
    if (stringByteLength === 0) {
      return "";
    }
    if (stringByteLength > 20) {
      return null;
    }
    if (stringByteLength === 1 && uint8array[start] < 128) {
      return String.fromCharCode(uint8array[start]);
    }
    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
    }
    if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
    }
    const latinBytes = [];
    for (let i = start;i < end; i++) {
      const byte = uint8array[i];
      if (byte > 127) {
        return null;
      }
      latinBytes.push(byte);
    }
    return String.fromCharCode(...latinBytes);
  }
  function tryWriteBasicLatin(destination, source, offset) {
    if (source.length === 0)
      return 0;
    if (source.length > 25)
      return null;
    if (destination.length - offset < source.length)
      return null;
    for (let charOffset = 0, destinationOffset = offset;charOffset < source.length; charOffset++, destinationOffset++) {
      const char = source.charCodeAt(charOffset);
      if (char > 127)
        return null;
      destination[destinationOffset] = char;
    }
    return source.length;
  }
  function nodejsMathRandomBytes(byteLength) {
    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  var nodejsRandomBytes = (() => {
    try {
      return __require("crypto").randomBytes;
    } catch {
      return nodejsMathRandomBytes;
    }
  })();
  var nodeJsByteUtils = {
    toLocalBufferType(potentialBuffer) {
      if (Buffer.isBuffer(potentialBuffer)) {
        return potentialBuffer;
      }
      if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return Buffer.from(potentialBuffer);
      }
      throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
    },
    allocate(size) {
      return Buffer.alloc(size);
    },
    allocateUnsafe(size) {
      return Buffer.allocUnsafe(size);
    },
    equals(a, b) {
      return nodeJsByteUtils.toLocalBufferType(a).equals(b);
    },
    fromNumberArray(array) {
      return Buffer.from(array);
    },
    fromBase64(base64) {
      return Buffer.from(base64, "base64");
    },
    toBase64(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
    },
    fromISO88591(codePoints) {
      return Buffer.from(codePoints, "binary");
    },
    toISO88591(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
    },
    fromHex(hex) {
      return Buffer.from(hex, "hex");
    },
    toHex(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
    },
    toUTF8(buffer2, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
      if (fatal) {
        for (let i = 0;i < string.length; i++) {
          if (string.charCodeAt(i) === 65533) {
            parseUtf8(buffer2, start, end, true);
            break;
          }
        }
      }
      return string;
    },
    utf8ByteLength(input) {
      return Buffer.byteLength(input, "utf8");
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
      if (latinBytesWritten != null) {
        return latinBytesWritten;
      }
      return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, undefined, "utf8");
    },
    randomBytes: nodejsRandomBytes,
    swap32(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
    }
  };
  function isReactNative() {
    const { navigator } = globalThis;
    return typeof navigator === "object" && navigator.product === "ReactNative";
  }
  function webMathRandomBytes(byteLength) {
    if (byteLength < 0) {
      throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
    }
    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  var webRandomBytes = (() => {
    const { crypto } = globalThis;
    if (crypto != null && typeof crypto.getRandomValues === "function") {
      return (byteLength) => {
        return crypto.getRandomValues(webByteUtils.allocate(byteLength));
      };
    } else {
      if (isReactNative()) {
        const { console: console2 } = globalThis;
        console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
      }
      return webMathRandomBytes;
    }
  })();
  var HEX_DIGIT = /(\d|[a-f])/i;
  var webByteUtils = {
    toLocalBufferType(potentialUint8array) {
      const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
      if (stringTag === "Uint8Array") {
        return potentialUint8array;
      }
      if (ArrayBuffer.isView(potentialUint8array)) {
        return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
      }
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return new Uint8Array(potentialUint8array);
      }
      throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
    },
    allocate(size) {
      if (typeof size !== "number") {
        throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
      }
      return new Uint8Array(size);
    },
    allocateUnsafe(size) {
      return webByteUtils.allocate(size);
    },
    equals(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0;i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    },
    fromNumberArray(array) {
      return Uint8Array.from(array);
    },
    fromBase64(base64) {
      return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
    },
    toBase64(uint8array) {
      return btoa(webByteUtils.toISO88591(uint8array));
    },
    fromISO88591(codePoints) {
      return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
    },
    toISO88591(uint8array) {
      return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
    },
    fromHex(hex) {
      const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
      const buffer2 = [];
      for (let i = 0;i < evenLengthHex.length; i += 2) {
        const firstDigit = evenLengthHex[i];
        const secondDigit = evenLengthHex[i + 1];
        if (!HEX_DIGIT.test(firstDigit)) {
          break;
        }
        if (!HEX_DIGIT.test(secondDigit)) {
          break;
        }
        const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
        buffer2.push(hexDigit);
      }
      return Uint8Array.from(buffer2);
    },
    toHex(uint8array) {
      return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
    },
    toUTF8(uint8array, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      return parseUtf8(uint8array, start, end, fatal);
    },
    utf8ByteLength(input) {
      return new TextEncoder().encode(input).byteLength;
    },
    encodeUTF8Into(uint8array, source, byteOffset) {
      const bytes = new TextEncoder().encode(source);
      uint8array.set(bytes, byteOffset);
      return bytes.byteLength;
    },
    randomBytes: webRandomBytes,
    swap32(buffer2) {
      if (buffer2.length % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0;i < buffer2.length; i += 4) {
        const byte0 = buffer2[i];
        const byte1 = buffer2[i + 1];
        const byte2 = buffer2[i + 2];
        const byte3 = buffer2[i + 3];
        buffer2[i] = byte3;
        buffer2[i + 1] = byte2;
        buffer2[i + 2] = byte1;
        buffer2[i + 3] = byte0;
      }
      return buffer2;
    }
  };
  var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
  var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

  class BSONValue {
    get [BSON_VERSION_SYMBOL]() {
      return BSON_MAJOR_VERSION;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
      return this.inspect(depth, options, inspect);
    }
  }
  var FLOAT = new Float64Array(1);
  var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
  FLOAT[0] = -1;
  var isBigEndian = FLOAT_BYTES[7] === 0;
  var NumberUtils = {
    isBigEndian,
    getNonnegativeInt32LE(source, offset) {
      if (source[offset + 3] > 127) {
        throw new RangeError(`Size cannot be negative at offset: ${offset}`);
      }
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getInt32LE(source, offset) {
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getUint32LE(source, offset) {
      return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
    },
    getUint32BE(source, offset) {
      return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
    },
    getBigInt64LE(source, offset) {
      const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
      const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
      return (hi << BigInt(32)) + lo;
    },
    getFloat64LE: isBigEndian ? (source, offset) => {
      FLOAT_BYTES[7] = source[offset];
      FLOAT_BYTES[6] = source[offset + 1];
      FLOAT_BYTES[5] = source[offset + 2];
      FLOAT_BYTES[4] = source[offset + 3];
      FLOAT_BYTES[3] = source[offset + 4];
      FLOAT_BYTES[2] = source[offset + 5];
      FLOAT_BYTES[1] = source[offset + 6];
      FLOAT_BYTES[0] = source[offset + 7];
      return FLOAT[0];
    } : (source, offset) => {
      FLOAT_BYTES[0] = source[offset];
      FLOAT_BYTES[1] = source[offset + 1];
      FLOAT_BYTES[2] = source[offset + 2];
      FLOAT_BYTES[3] = source[offset + 3];
      FLOAT_BYTES[4] = source[offset + 4];
      FLOAT_BYTES[5] = source[offset + 5];
      FLOAT_BYTES[6] = source[offset + 6];
      FLOAT_BYTES[7] = source[offset + 7];
      return FLOAT[0];
    },
    setInt32BE(destination, offset, value) {
      destination[offset + 3] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset] = value;
      return 4;
    },
    setInt32LE(destination, offset, value) {
      destination[offset] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 3] = value;
      return 4;
    },
    setBigInt64LE(destination, offset, value) {
      const mask32bits = BigInt(4294967295);
      let lo = Number(value & mask32bits);
      destination[offset] = lo;
      lo >>= 8;
      destination[offset + 1] = lo;
      lo >>= 8;
      destination[offset + 2] = lo;
      lo >>= 8;
      destination[offset + 3] = lo;
      let hi = Number(value >> BigInt(32) & mask32bits);
      destination[offset + 4] = hi;
      hi >>= 8;
      destination[offset + 5] = hi;
      hi >>= 8;
      destination[offset + 6] = hi;
      hi >>= 8;
      destination[offset + 7] = hi;
      return 8;
    },
    setFloat64LE: isBigEndian ? (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[7];
      destination[offset + 1] = FLOAT_BYTES[6];
      destination[offset + 2] = FLOAT_BYTES[5];
      destination[offset + 3] = FLOAT_BYTES[4];
      destination[offset + 4] = FLOAT_BYTES[3];
      destination[offset + 5] = FLOAT_BYTES[2];
      destination[offset + 6] = FLOAT_BYTES[1];
      destination[offset + 7] = FLOAT_BYTES[0];
      return 8;
    } : (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[0];
      destination[offset + 1] = FLOAT_BYTES[1];
      destination[offset + 2] = FLOAT_BYTES[2];
      destination[offset + 3] = FLOAT_BYTES[3];
      destination[offset + 4] = FLOAT_BYTES[4];
      destination[offset + 5] = FLOAT_BYTES[5];
      destination[offset + 6] = FLOAT_BYTES[6];
      destination[offset + 7] = FLOAT_BYTES[7];
      return 8;
    }
  };

  class Binary extends BSONValue {
    get _bsontype() {
      return "Binary";
    }
    constructor(buffer2, subType) {
      super();
      if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
        throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
      }
      this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
        this.position = 0;
      } else {
        this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
        this.position = this.buffer.byteLength;
      }
    }
    put(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONError("only accepts single character Uint8Array or Array");
      let decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
    write(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        throw new BSONError("input cannot be string");
      }
    }
    read(position, length) {
      length = length && length > 0 ? length : this.position;
      const end = position + length;
      return this.buffer.subarray(position, end > this.position ? this.position : end);
    }
    value() {
      return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
    }
    length() {
      return this.position;
    }
    toJSON() {
      return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.buffer.subarray(0, this.position));
      if (encoding === "base64")
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      if (encoding === "utf8" || encoding === "utf-8")
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    }
    toExtendedJSON(options) {
      options = options || {};
      if (this.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(this);
      }
      const base64String = ByteUtils.toBase64(this.buffer);
      const subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    }
    toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.subarray(0, this.position));
      }
      throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
    }
    static createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
    static createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
    static fromExtendedJSON(doc, options) {
      options = options || {};
      let data;
      let type;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== "string") {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ("$uuid" in doc) {
        type = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      const base64Arg = inspect(base64, options);
      const subTypeArg = inspect(this.sub_type, options);
      return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
    }
    toInt8Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {
        throw new BSONError("Binary datatype field is not Int8");
      }
      validateBinaryVector(this);
      return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toFloat32Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {
        throw new BSONError("Binary datatype field is not Float32");
      }
      validateBinaryVector(this);
      const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(floatBytes);
      return new Float32Array(floatBytes.buffer);
    }
    toPackedBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      validateBinaryVector(this);
      return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      validateBinaryVector(this);
      const byteCount = this.length() - 2;
      const bitCount = byteCount * 8 - this.buffer[1];
      const bits = new Int8Array(bitCount);
      for (let bitOffset = 0;bitOffset < bits.length; bitOffset++) {
        const byteOffset = bitOffset / 8 | 0;
        const byte = this.buffer[byteOffset + 2];
        const shift = 7 - bitOffset % 8;
        const bit = byte >> shift & 1;
        bits[bitOffset] = bit;
      }
      return bits;
    }
    static fromInt8Array(array) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.Int8;
      buffer2[1] = 0;
      const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      buffer2.set(intBytes, 2);
      const bin = new this(buffer2, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromFloat32Array(array) {
      const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
      binaryBytes[0] = Binary.VECTOR_TYPE.Float32;
      binaryBytes[1] = 0;
      const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      binaryBytes.set(floatBytes, 2);
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
      const bin = new this(binaryBytes, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromPackedBits(array, padding = 0) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.PackedBit;
      buffer2[1] = padding;
      buffer2.set(array, 2);
      const bin = new this(buffer2, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromBits(bits) {
      const byteLength = bits.length + 7 >>> 3;
      const bytes = new Uint8Array(byteLength + 2);
      bytes[0] = Binary.VECTOR_TYPE.PackedBit;
      const remainder = bits.length % 8;
      bytes[1] = remainder === 0 ? 0 : 8 - remainder;
      for (let bitOffset = 0;bitOffset < bits.length; bitOffset++) {
        const byteOffset = bitOffset >>> 3;
        const bit = bits[bitOffset];
        if (bit !== 0 && bit !== 1) {
          throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
        }
        if (bit === 0)
          continue;
        const shift = 7 - bitOffset % 8;
        bytes[byteOffset + 2] |= bit << shift;
      }
      return new this(bytes, Binary.SUBTYPE_VECTOR);
    }
  }
  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  Binary.BUFFER_SIZE = 256;
  Binary.SUBTYPE_DEFAULT = 0;
  Binary.SUBTYPE_FUNCTION = 1;
  Binary.SUBTYPE_BYTE_ARRAY = 2;
  Binary.SUBTYPE_UUID_OLD = 3;
  Binary.SUBTYPE_UUID = 4;
  Binary.SUBTYPE_MD5 = 5;
  Binary.SUBTYPE_ENCRYPTED = 6;
  Binary.SUBTYPE_COLUMN = 7;
  Binary.SUBTYPE_SENSITIVE = 8;
  Binary.SUBTYPE_VECTOR = 9;
  Binary.SUBTYPE_USER_DEFINED = 128;
  Binary.VECTOR_TYPE = Object.freeze({
    Int8: 3,
    Float32: 39,
    PackedBit: 16
  });
  function validateBinaryVector(vector) {
    if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
      return;
    const size = vector.position;
    const datatype = vector.buffer[0];
    const padding = vector.buffer[1];
    if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
      throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
    }
    if (datatype === Binary.VECTOR_TYPE.Float32) {
      if (size !== 0 && size - 2 !== 0 && (size - 2) % 4 !== 0) {
        throw new BSONError("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
      }
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
      throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
      throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
    }
  }
  var UUID_BYTE_LENGTH = 16;
  var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
  var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

  class UUID extends Binary {
    constructor(input) {
      let bytes;
      if (input == null) {
        bytes = UUID.generate();
      } else if (input instanceof UUID) {
        bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ByteUtils.toLocalBufferType(input);
      } else if (typeof input === "string") {
        bytes = UUID.bytesFromString(input);
      } else {
        throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
    }
    toHexString(includeDashes = true) {
      if (includeDashes) {
        return [
          ByteUtils.toHex(this.buffer.subarray(0, 4)),
          ByteUtils.toHex(this.buffer.subarray(4, 6)),
          ByteUtils.toHex(this.buffer.subarray(6, 8)),
          ByteUtils.toHex(this.buffer.subarray(8, 10)),
          ByteUtils.toHex(this.buffer.subarray(10, 16))
        ].join("-");
      }
      return ByteUtils.toHex(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.id);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch {
        return false;
      }
    }
    toBinary() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    }
    static generate() {
      const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return bytes;
    }
    static isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === "string") {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
    static createFromHexString(hexString) {
      const buffer2 = UUID.bytesFromString(hexString);
      return new UUID(buffer2);
    }
    static createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
    static bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ""));
    }
    static isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new UUID(${inspect(this.toHexString(), options)})`;
    }
  }

  class Code extends BSONValue {
    get _bsontype() {
      return "Code";
    }
    constructor(code, scope) {
      super();
      this.code = code.toString();
      this.scope = scope ?? null;
    }
    toJSON() {
      if (this.scope != null) {
        return { code: this.code, scope: this.scope };
      }
      return { code: this.code };
    }
    toExtendedJSON() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    }
    static fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      let parametersString = inspect(this.code, options);
      const multiLineFn = parametersString.includes(`
`);
      if (this.scope != null) {
        parametersString += `,${multiLineFn ? `
` : " "}${inspect(this.scope, options)}`;
      }
      const endingNewline = multiLineFn && this.scope === null;
      return `new Code(${multiLineFn ? `
` : ""}${parametersString}${endingNewline ? `
` : ""})`;
    }
  }
  function isDBRefLike(value) {
    return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || ("$db" in value) && typeof value.$db === "string");
  }

  class DBRef extends BSONValue {
    get _bsontype() {
      return "DBRef";
    }
    constructor(collection, oid, db, fields) {
      super();
      const parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    get namespace() {
      return this.collection;
    }
    set namespace(value) {
      this.collection = value;
    }
    toJSON() {
      const o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o.$db = this.db;
      return o;
    }
    toExtendedJSON(options) {
      options = options || {};
      let o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db)
        o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
    static fromExtendedJSON(doc) {
      const copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const args = [
        inspect(this.namespace, options),
        inspect(this.oid, options),
        ...this.db ? [inspect(this.db, options)] : [],
        ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
      ];
      args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
      return `new DBRef(${args.join(", ")})`;
    }
  }
  function removeLeadingZerosAndExplicitPlus(str) {
    if (str === "") {
      return str;
    }
    let startIndex = 0;
    const isNegative = str[startIndex] === "-";
    const isExplicitlyPositive = str[startIndex] === "+";
    if (isExplicitlyPositive || isNegative) {
      startIndex += 1;
    }
    let foundInsignificantZero = false;
    for (;startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
      foundInsignificantZero = true;
    }
    if (!foundInsignificantZero) {
      return isExplicitlyPositive ? str.slice(1) : str;
    }
    return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
  }
  function validateStringCharacters(str, radix) {
    radix = radix ?? 10;
    const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
    const regex = new RegExp(`[^-+${validCharacters}]`, "i");
    return regex.test(str) ? false : str;
  }
  var wasm = undefined;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {}
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var MAX_INT64_STRING_LENGTH = 20;
  var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

  class Long extends BSONValue {
    get _bsontype() {
      return "Long";
    }
    get __isLong__() {
      return true;
    }
    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
      super();
      const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
      const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
      const res = typeof lowOrValue === "string" ? Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
      this.low = res.low;
      this.high = res.high;
      this.unsigned = res.unsigned;
    }
    static fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    static fromInt(value, unsigned) {
      let obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    static fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0)
          return Long.UZERO;
        if (value >= TWO_PWR_64_DBL)
          return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -9223372036854776000)
          return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return Long.MAX_VALUE;
      }
      if (value < 0)
        return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    static fromBigInt(value, unsigned) {
      const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
      const FROM_BIGINT_BIT_SHIFT = BigInt(32);
      return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
    }
    static _fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw new BSONError("empty string");
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      let p;
      if ((p = str.indexOf("-")) > 0)
        throw new BSONError("interior hyphen");
      else if (p === 0) {
        return Long._fromString(str.substring(1), unsigned, radix).neg();
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 8));
      let result = Long.ZERO;
      for (let i = 0;i < str.length; i += 8) {
        const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          const power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    static fromStringStrict(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str.trim() !== str) {
        throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
      }
      if (!validateStringCharacters(str, radix)) {
        throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
      }
      const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
      const result = Long._fromString(cleanedStr, unsigned, radix);
      if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
        throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
      }
      return result;
    }
    static fromString(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str === "NaN" && radix < 24) {
        return Long.ZERO;
      } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
        return Long.ZERO;
      }
      return Long._fromString(str, unsigned, radix);
    }
    static fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
    static fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
    static fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
    static isLong(value) {
      return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
    }
    static fromValue(val, unsigned) {
      if (typeof val === "number")
        return Long.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = addend.high >>> 16;
      const b32 = addend.high & 65535;
      const b16 = addend.low >>> 16;
      const b00 = addend.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.eq(other))
        return 0;
      const thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    comp(other) {
      return this.compare(other);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw new BSONError("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long.UZERO : Long.ZERO;
      let approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
            return Long.MIN_VALUE;
          else if (divisor.eq(Long.MIN_VALUE))
            return Long.ONE;
          else {
            const halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE))
          return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        const log2 = Math.ceil(Math.log(approx) / Math.LN2);
        const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        let approxRes = Long.fromNumber(approx);
        let approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
    div(divisor) {
      return this.divide(divisor);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    eq(other) {
      return this.equals(other);
    }
    getHighBits() {
      return this.high;
    }
    getHighBitsUnsigned() {
      return this.high >>> 0;
    }
    getLowBits() {
      return this.low;
    }
    getLowBitsUnsigned() {
      return this.low >>> 0;
    }
    getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      const val = this.high !== 0 ? this.high : this.low;
      let bit;
      for (bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    greaterThan(other) {
      return this.comp(other) > 0;
    }
    gt(other) {
      return this.greaterThan(other);
    }
    greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    ge(other) {
      return this.greaterThanOrEqual(other);
    }
    isEven() {
      return (this.low & 1) === 0;
    }
    isNegative() {
      return !this.unsigned && this.high < 0;
    }
    isOdd() {
      return (this.low & 1) === 1;
    }
    isPositive() {
      return this.unsigned || this.high >= 0;
    }
    isZero() {
      return this.high === 0 && this.low === 0;
    }
    lessThan(other) {
      return this.comp(other) < 0;
    }
    lt(other) {
      return this.lessThan(other);
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    lte(other) {
      return this.lessThanOrEqual(other);
    }
    modulo(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (wasm) {
        const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
    mod(divisor) {
      return this.modulo(divisor);
    }
    rem(divisor) {
      return this.modulo(divisor);
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      if (wasm) {
        const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long.ZERO;
      if (this.eq(Long.MIN_VALUE))
        return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE))
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
        return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = multiplier.high >>> 16;
      const b32 = multiplier.high & 65535;
      const b16 = multiplier.low >>> 16;
      const b00 = multiplier.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    mul(multiplier) {
      return this.multiply(multiplier);
    }
    negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE))
        return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
    neg() {
      return this.negate();
    }
    not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
    notEquals(other) {
      return !this.equals(other);
    }
    neq(other) {
      return this.notEquals(other);
    }
    ne(other) {
      return this.notEquals(other);
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
    shiftLeft(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
    shl(numBits) {
      return this.shiftLeft(numBits);
    }
    shiftRight(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
    shr(numBits) {
      return this.shiftRight(numBits);
    }
    shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        const high = this.high;
        if (numBits < 32) {
          const low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long.fromBits(high, 0, this.unsigned);
        else
          return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
    shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
    sub(subtrahend) {
      return this.subtract(subtrahend);
    }
    toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
    toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
    toBytesLE() {
      const hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    toBytesBE() {
      const hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    }
    toSigned() {
      if (!this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, false);
    }
    toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      let rem = this;
      let result = "";
      while (true) {
        const remDiv = rem.div(radixToPower);
        const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        let digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    }
    toUnsigned() {
      if (this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, true);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
    eqz() {
      return this.isZero();
    }
    le(other) {
      return this.lessThanOrEqual(other);
    }
    toExtendedJSON(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    }
    static fromExtendedJSON(doc, options) {
      const { useBigInt64 = false, relaxed = true } = { ...options };
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError("$numberLong string is too long");
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
      }
      if (useBigInt64) {
        const bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      const longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const longVal = inspect(this.toString(), options);
      const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
      return `new Long(${longVal}${unsignedVal})`;
    }
  }
  Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
  Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.ZERO = Long.fromInt(0);
  Long.UZERO = Long.fromInt(0, true);
  Long.ONE = Long.fromInt(1);
  Long.UONE = Long.fromInt(1, true);
  Long.NEG_ONE = Long.fromInt(-1);
  Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = ByteUtils.fromNumberArray([
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;
  function isDigit(value) {
    return !isNaN(parseInt(value, 10));
  }
  function divideu128(value) {
    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
    let _rem = Long.fromNumber(0);
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return { quotient: value, rem: _rem };
    }
    for (let i = 0;i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value, rem: _rem };
  }
  function multiply64x2(left, right) {
    if (!left && !right) {
      return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
    }
    const leftHigh = left.shiftRightUnsigned(32);
    const leftLow = new Long(left.getLowBits(), 0);
    const rightHigh = right.shiftRightUnsigned(32);
    const rightLow = new Long(right.getLowBits(), 0);
    let productHigh = leftHigh.multiply(rightHigh);
    let productMid = leftHigh.multiply(rightLow);
    const productMid2 = leftLow.multiply(rightHigh);
    let productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  }
  function lessThan(left, right) {
    const uhleft = left.high >>> 0;
    const uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      const ulleft = left.low >>> 0;
      const ulright = right.low >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  }
  function invalidErr(string, message) {
    throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
  }

  class Decimal128 extends BSONValue {
    get _bsontype() {
      return "Decimal128";
    }
    constructor(bytes) {
      super();
      if (typeof bytes === "string") {
        this.bytes = Decimal128.fromString(bytes).bytes;
      } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONError("Decimal128 must take a Buffer or string");
      }
    }
    static fromString(representation) {
      return Decimal128._fromString(representation, { allowRounding: false });
    }
    static fromStringWithRounding(representation) {
      return Decimal128._fromString(representation, { allowRounding: true });
    }
    static _fromString(representation, options) {
      let isNegative = false;
      let sawSign = false;
      let sawRadix = false;
      let foundNonZero = false;
      let significantDigits = 0;
      let nDigitsRead = 0;
      let nDigits = 0;
      let radixPosition = 0;
      let firstNonZero = 0;
      const digits = [0];
      let nDigitsStored = 0;
      let digitsInsert = 0;
      let lastDigit = 0;
      let exponent = 0;
      let significandHigh = new Long(0, 0);
      let significandLow = new Long(0, 0);
      let biasedExponent = 0;
      let index = 0;
      if (representation.length >= 7000) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      const stringMatch = representation.match(PARSE_STRING_REGEXP);
      const infMatch = representation.match(PARSE_INF_REGEXP);
      const nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        const unsignedNumber = stringMatch[2];
        const e = stringMatch[4];
        const expSign = stringMatch[5];
        const expNumber = stringMatch[6];
        if (e && expNumber === undefined)
          invalidErr(representation, "missing exponent power");
        if (e && unsignedNumber === undefined)
          invalidErr(representation, "missing exponent base");
        if (e === undefined && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index] === "+" || representation[index] === "-") {
        sawSign = true;
        isNegative = representation[index++] === "-";
      }
      if (!isDigit(representation[index]) && representation[index] !== ".") {
        if (representation[index] === "i" || representation[index] === "I") {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === "N") {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === ".") {
        if (representation[index] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < MAX_DIGITS) {
          if (representation[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      if (representation[index] === "e" || representation[index] === "E") {
        const match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal128(NAN_BUFFER);
      if (!nDigitsStored) {
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit >= MAX_DIGITS) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      if (options.allowRounding) {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            const digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          let endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          let roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (let i = firstNonZero + lastDigit + 2;i < endOfString; i++) {
                if (parseInt(representation[i], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            let dIdx = lastDigit;
            for (;dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                  }
                }
              } else {
                break;
              }
            }
          }
        }
      } else {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MIN;
              break;
            }
            invalidErr(representation, "exponent underflow");
          }
          if (nDigitsStored < nDigits) {
            if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            nDigits = nDigits - 1;
          } else {
            if (digits[lastDigit] !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          if (roundDigit !== 0) {
            invalidErr(representation, "inexact rounding");
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit < 17) {
        let dIdx = 0;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        let dIdx = 0;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      const buffer2 = ByteUtils.allocateUnsafe(16);
      index = 0;
      buffer2[index++] = dec.low.low & 255;
      buffer2[index++] = dec.low.low >> 8 & 255;
      buffer2[index++] = dec.low.low >> 16 & 255;
      buffer2[index++] = dec.low.low >> 24 & 255;
      buffer2[index++] = dec.low.high & 255;
      buffer2[index++] = dec.low.high >> 8 & 255;
      buffer2[index++] = dec.low.high >> 16 & 255;
      buffer2[index++] = dec.low.high >> 24 & 255;
      buffer2[index++] = dec.high.low & 255;
      buffer2[index++] = dec.high.low >> 8 & 255;
      buffer2[index++] = dec.high.low >> 16 & 255;
      buffer2[index++] = dec.high.low >> 24 & 255;
      buffer2[index++] = dec.high.high & 255;
      buffer2[index++] = dec.high.high >> 8 & 255;
      buffer2[index++] = dec.high.high >> 16 & 255;
      buffer2[index++] = dec.high.high >> 24 & 255;
      return new Decimal128(buffer2);
    }
    toString() {
      let biased_exponent;
      let significand_digits = 0;
      const significand = new Array(36);
      for (let i = 0;i < significand.length; i++)
        significand[i] = 0;
      let index = 0;
      let is_zero = false;
      let significand_msb;
      let significand128 = { parts: [0, 0, 0, 0] };
      let j, k;
      const string = [];
      index = 0;
      const buffer2 = this.bytes;
      const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      index = 0;
      const dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push("-");
      }
      const combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      const exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3;k >= 0; k--) {
          let least_digits = 0;
          const result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j = 8;j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      const scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push(`${0}`);
          if (exponent > 0)
            string.push(`E+${exponent}`);
          else if (exponent < 0)
            string.push(`E${exponent}`);
          return string.join("");
        }
        string.push(`${significand[index++]}`);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (let i = 0;i < significand_digits; i++) {
          string.push(`${significand[index++]}`);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push(`+${scientific_exponent}`);
        } else {
          string.push(`${scientific_exponent}`);
        }
      } else {
        if (exponent >= 0) {
          for (let i = 0;i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
        } else {
          let radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (let i = 0;i < radix_position; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (let i = 0;i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(`${significand[index++]}`);
          }
        }
      }
      return string.join("");
    }
    toJSON() {
      return { $numberDecimal: this.toString() };
    }
    toExtendedJSON() {
      return { $numberDecimal: this.toString() };
    }
    static fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const d128string = inspect(this.toString(), options);
      return `new Decimal128(${d128string})`;
    }
  }

  class Double extends BSONValue {
    get _bsontype() {
      return "Double";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    static fromString(value) {
      const coercedValue = Number(value);
      if (value === "NaN")
        return new Double(NaN);
      if (value === "Infinity")
        return new Double(Infinity);
      if (value === "-Infinity")
        return new Double(-Infinity);
      if (!Number.isFinite(coercedValue)) {
        throw new BSONError(`Input: ${value} is not representable as a Double`);
      }
      if (value.trim() !== value) {
        throw new BSONError(`Input: '${value}' contains whitespace`);
      }
      if (value === "") {
        throw new BSONError(`Input is an empty string`);
      }
      if (/[^-0-9.+eE]/.test(value)) {
        throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
      }
      return new Double(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-0.0" };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
    static fromExtendedJSON(doc, options) {
      const doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Double(${inspect(this.value, options)})`;
    }
  }

  class Int32 extends BSONValue {
    get _bsontype() {
      return "Int32";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value | 0;
    }
    static fromString(value) {
      const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
      const coercedValue = Number(value);
      if (BSON_INT32_MAX < coercedValue) {
        throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
      } else if (BSON_INT32_MIN > coercedValue) {
        throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
      } else if (!Number.isSafeInteger(coercedValue)) {
        throw new BSONError(`Input: '${value}' is not a safe integer`);
      } else if (coercedValue.toString() !== cleanedValue) {
        throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
      }
      return new Int32(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    }
    static fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Int32(${inspect(this.value, options)})`;
    }
  }

  class MaxKey extends BSONValue {
    get _bsontype() {
      return "MaxKey";
    }
    toExtendedJSON() {
      return { $maxKey: 1 };
    }
    static fromExtendedJSON() {
      return new MaxKey;
    }
    inspect() {
      return "new MaxKey()";
    }
  }

  class MinKey extends BSONValue {
    get _bsontype() {
      return "MinKey";
    }
    toExtendedJSON() {
      return { $minKey: 1 };
    }
    static fromExtendedJSON() {
      return new MinKey;
    }
    inspect() {
      return "new MinKey()";
    }
  }
  var PROCESS_UNIQUE = null;
  var __idCache = new WeakMap;

  class ObjectId extends BSONValue {
    get _bsontype() {
      return "ObjectId";
    }
    constructor(inputId) {
      super();
      let workingId;
      if (typeof inputId === "object" && inputId && "id" in inputId) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
        }
        if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
          workingId = ByteUtils.fromHex(inputId.toHexString());
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this.buffer = ObjectId.generate(typeof workingId === "number" ? workingId : undefined);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this.buffer = ByteUtils.toLocalBufferType(workingId);
      } else if (typeof workingId === "string") {
        if (ObjectId.validateHexString(workingId)) {
          this.buffer = ByteUtils.fromHex(workingId);
          if (ObjectId.cacheHexString) {
            __idCache.set(this, workingId);
          }
        } else {
          throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
        }
      } else {
        throw new BSONError("Argument passed in does not match the accepted types");
      }
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
      if (ObjectId.cacheHexString) {
        __idCache.set(this, ByteUtils.toHex(value));
      }
    }
    static validateHexString(string) {
      if (string?.length !== 24)
        return false;
      for (let i = 0;i < 24; i++) {
        const char = string.charCodeAt(i);
        if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
          continue;
        }
        return false;
      }
      return true;
    }
    toHexString() {
      if (ObjectId.cacheHexString) {
        const __id = __idCache.get(this);
        if (__id)
          return __id;
      }
      const hexString = ByteUtils.toHex(this.id);
      if (ObjectId.cacheHexString) {
        __idCache.set(this, hexString);
      }
      return hexString;
    }
    static getInc() {
      return ObjectId.index = (ObjectId.index + 1) % 16777215;
    }
    static generate(time) {
      if (typeof time !== "number") {
        time = Math.floor(Date.now() / 1000);
      }
      const inc = ObjectId.getInc();
      const buffer2 = ByteUtils.allocateUnsafe(12);
      NumberUtils.setInt32BE(buffer2, 0, time);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    }
    toString(encoding) {
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      if (encoding === "hex")
        return this.toHexString();
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    static is(variable) {
      return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
    }
    equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (ObjectId.is(otherId)) {
        return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
      }
      if (typeof otherId === "string") {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
        const otherIdString = otherId.toHexString();
        const thisIdString = this.toHexString();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
    getTimestamp() {
      const timestamp = new Date;
      const time = NumberUtils.getUint32BE(this.buffer, 0);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
    static createPk() {
      return new ObjectId;
    }
    serializeInto(uint8array, index) {
      uint8array[index] = this.buffer[0];
      uint8array[index + 1] = this.buffer[1];
      uint8array[index + 2] = this.buffer[2];
      uint8array[index + 3] = this.buffer[3];
      uint8array[index + 4] = this.buffer[4];
      uint8array[index + 5] = this.buffer[5];
      uint8array[index + 6] = this.buffer[6];
      uint8array[index + 7] = this.buffer[7];
      uint8array[index + 8] = this.buffer[8];
      uint8array[index + 9] = this.buffer[9];
      uint8array[index + 10] = this.buffer[10];
      uint8array[index + 11] = this.buffer[11];
      return 12;
    }
    static createFromTime(time) {
      const buffer2 = ByteUtils.allocate(12);
      for (let i = 11;i >= 4; i--)
        buffer2[i] = 0;
      NumberUtils.setInt32BE(buffer2, 0, time);
      return new ObjectId(buffer2);
    }
    static createFromHexString(hexString) {
      if (hexString?.length !== 24) {
        throw new BSONError("hex string must be 24 characters");
      }
      return new ObjectId(ByteUtils.fromHex(hexString));
    }
    static createFromBase64(base64) {
      if (base64?.length !== 16) {
        throw new BSONError("base64 string must be 16 characters");
      }
      return new ObjectId(ByteUtils.fromBase64(base64));
    }
    static isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "string")
        return ObjectId.validateHexString(id);
      try {
        new ObjectId(id);
        return true;
      } catch {
        return false;
      }
    }
    toExtendedJSON() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    }
    static fromExtendedJSON(doc) {
      return new ObjectId(doc.$oid);
    }
    isCached() {
      return ObjectId.cacheHexString && __idCache.has(this);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new ObjectId(${inspect(this.toHexString(), options)})`;
    }
  }
  ObjectId.index = Math.floor(Math.random() * 16777215);
  function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
    let totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
      }
      for (const key of Object.keys(object)) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  }
  function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
    if (typeof value?.toBSON === "function") {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
      case "number":
        if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
      case "object":
        if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        } else if (value._bsontype === "ObjectId") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
        } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (value._bsontype === "Decimal128") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
        } else if (value._bsontype === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
          }
        } else if (value._bsontype === "Binary") {
          const binary = value;
          if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
          }
        } else if (value._bsontype === "Symbol") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
        } else if (value._bsontype === "DBRef") {
          const ordered_values = Object.assign({
            $ref: value.collection,
            $id: value.oid
          }, value.fields);
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || isRegExp(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value._bsontype === "BSONRegExp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (serializeFunctions) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
        }
        return 0;
      case "bigint":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      case "symbol":
        return 0;
      default:
        throw new BSONError(`Unrecognized JS type: ${typeof value}`);
    }
  }
  function alphabetize(str) {
    return str.split("").sort().join("");
  }

  class BSONRegExp extends BSONValue {
    get _bsontype() {
      return "BSONRegExp";
    }
    constructor(pattern, options) {
      super();
      this.pattern = pattern;
      this.options = alphabetize(options ?? "");
      if (this.pattern.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
      }
      if (this.options.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
      }
      for (let i = 0;i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
        }
      }
    }
    static parseOptions(options) {
      return options ? options.split("").sort().join("") : "";
    }
    toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    }
    static fromExtendedJSON(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
    }
    inspect(depth, options, inspect) {
      const stylize = getStylizeFunction(options) ?? ((v) => v);
      inspect ??= defaultInspect;
      const pattern = stylize(inspect(this.pattern), "regexp");
      const flags = stylize(inspect(this.options), "regexp");
      return `new BSONRegExp(${pattern}, ${flags})`;
    }
  }

  class BSONSymbol extends BSONValue {
    get _bsontype() {
      return "BSONSymbol";
    }
    constructor(value) {
      super();
      this.value = value;
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON() {
      return { $symbol: this.value };
    }
    static fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new BSONSymbol(${inspect(this.value, options)})`;
    }
  }
  var LongWithoutOverridesClass = Long;

  class Timestamp extends LongWithoutOverridesClass {
    get _bsontype() {
      return "Timestamp";
    }
    get i() {
      return this.low >>> 0;
    }
    get t() {
      return this.high >>> 0;
    }
    constructor(low) {
      if (low == null) {
        super(0, 0, true);
      } else if (typeof low === "bigint") {
        super(low, true);
      } else if (Long.isLong(low)) {
        super(low.low, low.high, true);
      } else if (typeof low === "object" && "t" in low && "i" in low) {
        if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
        }
        if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
        }
        const t = Number(low.t);
        const i = Number(low.i);
        if (t < 0 || Number.isNaN(t)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
        }
        if (i < 0 || Number.isNaN(i)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
        }
        if (t > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
        }
        if (i > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
        }
        super(i, t, true);
      } else {
        throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      }
    }
    toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
    static fromInt(value) {
      return new Timestamp(Long.fromInt(value, true));
    }
    static fromNumber(value) {
      return new Timestamp(Long.fromNumber(value, true));
    }
    static fromBits(lowBits, highBits) {
      return new Timestamp({ i: lowBits, t: highBits });
    }
    static fromString(str, optRadix) {
      return new Timestamp(Long.fromString(str, true, optRadix));
    }
    toExtendedJSON() {
      return { $timestamp: { t: this.t, i: this.i } };
    }
    static fromExtendedJSON(doc) {
      const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({ t, i });
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const t = inspect(this.t, options);
      const i = inspect(this.i, options);
      return `new Timestamp({ t: ${t}, i: ${i} })`;
    }
  }
  Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
  var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
  var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
  function internalDeserialize(buffer2, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    const size = NumberUtils.getInt32LE(buffer2, index);
    if (size < 5) {
      throw new BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
      throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
      throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
    }
    if (size + index > buffer2.byteLength) {
      throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
    }
    if (buffer2[index + size - 1] !== 0) {
      throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer2, index, options, isArray);
  }
  var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
  function deserializeObject(buffer2, index, options, isArray = false) {
    const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    const raw = options["raw"] == null ? false : options["raw"];
    const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    const promoteBuffers = options.promoteBuffers ?? false;
    const promoteLongs = options.promoteLongs ?? true;
    const promoteValues = options.promoteValues ?? true;
    const useBigInt64 = options.useBigInt64 ?? false;
    if (useBigInt64 && !promoteValues) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    if (useBigInt64 && !promoteLongs) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    const validation = options.validation == null ? { utf8: true } : options.validation;
    let globalUTFValidation = true;
    let validationSetting;
    let utf8KeysSet;
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === "boolean") {
      validationSetting = utf8ValidatedKeys;
    } else {
      globalUTFValidation = false;
      const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
        return utf8ValidatedKeys[key];
      });
      if (utf8ValidationValues.length === 0) {
        throw new BSONError("UTF-8 validation setting cannot be empty");
      }
      if (typeof utf8ValidationValues[0] !== "boolean") {
        throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
      }
      validationSetting = utf8ValidationValues[0];
      if (!utf8ValidationValues.every((item) => item === validationSetting)) {
        throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
      }
    }
    if (!globalUTFValidation) {
      utf8KeysSet = new Set;
      for (const key of Object.keys(utf8ValidatedKeys)) {
        utf8KeysSet.add(key);
      }
    }
    const startIndex = index;
    if (buffer2.length < 5)
      throw new BSONError("corrupt bson message < 5 bytes long");
    const size = NumberUtils.getInt32LE(buffer2, index);
    index += 4;
    if (size < 5 || size > buffer2.length)
      throw new BSONError("corrupt bson message");
    const object = isArray ? [] : {};
    let arrayIndex = 0;
    let isPossibleDBRef = isArray ? false : null;
    while (true) {
      const elementType = buffer2[index++];
      if (elementType === 0)
        break;
      let i = index;
      while (buffer2[i] !== 0 && i < buffer2.length) {
        i++;
      }
      if (i >= buffer2.byteLength)
        throw new BSONError("Bad BSON Document: illegal CString");
      const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
      let shouldValidateKey = true;
      if (globalUTFValidation || utf8KeysSet?.has(name)) {
        shouldValidateKey = validationSetting;
      } else {
        shouldValidateKey = !validationSetting;
      }
      if (isPossibleDBRef !== false && name[0] === "$") {
        isPossibleDBRef = allowedDBRefKeys.test(name);
      }
      let value;
      index = i + 1;
      if (elementType === BSON_DATA_STRING) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_OID) {
        const oid = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oid[i2] = buffer2[index + i2];
        value = new ObjectId(oid);
        index = index + 12;
      } else if (elementType === BSON_DATA_INT && promoteValues === false) {
        value = new Int32(NumberUtils.getInt32LE(buffer2, index));
        index += 4;
      } else if (elementType === BSON_DATA_INT) {
        value = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
      } else if (elementType === BSON_DATA_NUMBER) {
        value = NumberUtils.getFloat64LE(buffer2, index);
        index += 8;
        if (promoteValues === false)
          value = new Double(value);
      } else if (elementType === BSON_DATA_DATE) {
        const lowBits = NumberUtils.getInt32LE(buffer2, index);
        const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
        index += 8;
        value = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON_DATA_BOOLEAN) {
        if (buffer2[index] !== 0 && buffer2[index] !== 1)
          throw new BSONError("illegal boolean type value");
        value = buffer2[index++] === 1;
      } else if (elementType === BSON_DATA_OBJECT) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        if (objectSize <= 0 || objectSize > buffer2.length - index)
          throw new BSONError("bad embedded document length in bson");
        if (raw) {
          value = buffer2.subarray(index, index + objectSize);
        } else {
          let objectOptions = options;
          if (!globalUTFValidation) {
            objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, objectOptions, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON_DATA_ARRAY) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        let arrayOptions = options;
        const stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = { ...options, raw: true };
        }
        if (!globalUTFValidation) {
          arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
        }
        value = deserializeObject(buffer2, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer2[index - 1] !== 0)
          throw new BSONError("invalid array terminator byte");
        if (index !== stopIndex)
          throw new BSONError("corrupted array bson");
      } else if (elementType === BSON_DATA_UNDEFINED) {
        value = undefined;
      } else if (elementType === BSON_DATA_NULL) {
        value = null;
      } else if (elementType === BSON_DATA_LONG) {
        if (useBigInt64) {
          value = NumberUtils.getBigInt64LE(buffer2, index);
          index += 8;
        } else {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          const long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            value = long;
          }
        }
      } else if (elementType === BSON_DATA_DECIMAL128) {
        const bytes = ByteUtils.allocateUnsafe(16);
        for (let i2 = 0;i2 < 16; i2++)
          bytes[i2] = buffer2[index + i2];
        index = index + 16;
        value = new Decimal128(bytes);
      } else if (elementType === BSON_DATA_BINARY) {
        let binarySize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        const totalBinarySize = binarySize;
        const subType = buffer2[index++];
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found");
        if (binarySize > buffer2.byteLength)
          throw new BSONError("Binary type size larger than document size");
        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found for subtype 0x02");
          if (binarySize > totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
          if (binarySize < totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
        } else {
          value = new Binary(buffer2.subarray(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
            value = value.toUUID();
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        const optionsArray = new Array(regExpOptions.length);
        for (i = 0;i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        value = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        value = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON_DATA_SYMBOL) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = promoteValues ? symbol : new BSONSymbol(symbol);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_TIMESTAMP) {
        value = new Timestamp({
          i: NumberUtils.getUint32LE(buffer2, index),
          t: NumberUtils.getUint32LE(buffer2, index + 4)
        });
        index += 8;
      } else if (elementType === BSON_DATA_MIN_KEY) {
        value = new MinKey;
      } else if (elementType === BSON_DATA_MAX_KEY) {
        value = new MaxKey;
      } else if (elementType === BSON_DATA_CODE) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = new Code(functionString);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
        const totalSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new BSONError("code_w_scope total size shorter minimum expected length");
        }
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        const scopeObject = deserializeObject(buffer2, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too long, clips outer document");
        }
        value = new Code(functionString, scopeObject);
      } else if (elementType === BSON_DATA_DBPOINTER) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
          throw new BSONError("bad string length in bson");
        const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const oidBuffer = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oidBuffer[i2] = buffer2[index + i2];
        const oid = new ObjectId(oidBuffer);
        index = index + 12;
        value = new DBRef(namespace, oid);
      } else {
        throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
      }
      if (name === "__proto__") {
        Object.defineProperty(object, name, {
          value,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        object[name] = value;
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new BSONError("corrupt array bson");
      throw new BSONError("corrupt object bson");
    }
    if (!isPossibleDBRef)
      return object;
    if (isDBRefLike(object)) {
      const copy = Object.assign({}, object);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
  }
  var regexp = /\x00/;
  var ignoreKeys = new Set(["$db", "$ref", "$id", "$clusterTime"]);
  function serializeString(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_STRING;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes + 1;
    buffer2[index - 1] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
    NumberUtils.setInt32LE(buffer2, index, size + 1);
    index = index + 4 + size;
    buffer2[index++] = 0;
    return index;
  }
  function serializeNumber(buffer2, key, value, index) {
    const isNegativeZero = Object.is(value, -0);
    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
    buffer2[index++] = type;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (type === BSON_DATA_INT) {
      index += NumberUtils.setInt32LE(buffer2, index, value);
    } else {
      index += NumberUtils.setFloat64LE(buffer2, index, value);
    }
    return index;
  }
  function serializeBigInt(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_LONG;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index += numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setBigInt64LE(buffer2, index, value);
    return index;
  }
  function serializeNull(buffer2, key, _, index) {
    buffer2[index++] = BSON_DATA_NULL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBoolean(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BOOLEAN;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value ? 1 : 0;
    return index;
  }
  function serializeDate(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DATE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const dateInMilis = Long.fromNumber(value.getTime());
    const lowBits = dateInMilis.getLowBits();
    const highBits = dateInMilis.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw new BSONError("value " + value.source + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
    buffer2[index++] = 0;
    if (value.ignoreCase)
      buffer2[index++] = 105;
    if (value.global)
      buffer2[index++] = 115;
    if (value.multiline)
      buffer2[index++] = 109;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBSONRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
    buffer2[index++] = 0;
    const sortedOptions = value.options.split("").sort().join("");
    index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
    buffer2[index++] = 0;
    return index;
  }
  function serializeMinMax(buffer2, key, value, index) {
    if (value === null) {
      buffer2[index++] = BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer2[index++] = BSON_DATA_MIN_KEY;
    } else {
      buffer2[index++] = BSON_DATA_MAX_KEY;
    }
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeObjectId(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_OID;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += value.serializeInto(buffer2, index);
    return index;
  }
  function serializeBuffer(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = value.length;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = value[i];
    } else {
      buffer2.set(value, index);
    }
    index = index + size;
    return index;
  }
  function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
    if (path.has(value)) {
      throw new BSONError("Cannot convert circular structure to BSON");
    }
    path.add(value);
    buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.delete(value);
    return endIndex;
  }
  function serializeDecimal128(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DECIMAL128;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    for (let i = 0;i < 16; i++)
      buffer2[index + i] = value.bytes[i];
    return index + 16;
  }
  function serializeLong(buffer2, key, value, index) {
    buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const lowBits = value.getLowBits();
    const highBits = value.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeInt32(buffer2, key, value, index) {
    value = value.valueOf();
    buffer2[index++] = BSON_DATA_INT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setInt32LE(buffer2, index, value);
    return index;
  }
  function serializeDouble(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_NUMBER;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setFloat64LE(buffer2, index, value.value);
    return index;
  }
  function serializeFunction(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
    if (value.scope && typeof value.scope === "object") {
      buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      const functionString = value.code;
      index = index + 4;
      const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, codeSize);
      buffer2[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      index = endIndex - 1;
      const totalSize = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
      buffer2[index++] = 0;
    } else {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.code.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
    }
    return index;
  }
  function serializeBinary(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const data = value.buffer;
    let size = value.position;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = value.sub_type;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
    }
    if (value.sub_type === Binary.SUBTYPE_VECTOR) {
      validateBinaryVector(value);
    }
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = data[i];
    } else {
      buffer2.set(data, index);
    }
    index = index + value.position;
    return index;
  }
  function serializeSymbol(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_SYMBOL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path) {
    buffer2[index++] = BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    let output = {
      $ref: value.collection || value.namespace,
      $id: value.oid
    };
    if (value.db != null) {
      output.$db = value.db;
    }
    output = Object.assign(output, value.fields);
    const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
    const size = endIndex - startIndex;
    startIndex += NumberUtils.setInt32LE(buffer2, index, size);
    return endIndex;
  }
  function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    if (path == null) {
      if (object == null) {
        buffer2[0] = 5;
        buffer2[1] = 0;
        buffer2[2] = 0;
        buffer2[3] = 0;
        buffer2[4] = 0;
        return 5;
      }
      if (Array.isArray(object)) {
        throw new BSONError("serialize does not support an array as the root input");
      }
      if (typeof object !== "object") {
        throw new BSONError("serialize does not support non-object as the root input");
      } else if ("_bsontype" in object && typeof object._bsontype === "string") {
        throw new BSONError(`BSON types cannot be serialized as a document`);
      } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
        throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
      }
      path = new Set;
    }
    path.add(object);
    let index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        const key = `${i}`;
        let value = object[i];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (value === undefined) {
          index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else if (object instanceof Map || isMap(object)) {
      const iterator = object.entries();
      let done = false;
      while (!done) {
        const entry = iterator.next();
        done = !!entry.done;
        if (done)
          continue;
        const key = entry.value ? entry.value[0] : undefined;
        let value = entry.value ? entry.value[1] : undefined;
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
        if (object != null && typeof object !== "object") {
          throw new BSONError("toBSON function did not return an object");
        }
      }
      for (const key of Object.keys(object)) {
        let value = object[key];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    }
    path.delete(object);
    buffer2[index++] = 0;
    const size = index - startingIndex;
    startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
    return index;
  }
  function isBSONType(value) {
    return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
  }
  var keysToCodecs = {
    $oid: ObjectId,
    $binary: Binary,
    $uuid: Binary,
    $symbol: BSONSymbol,
    $numberInt: Int32,
    $numberDecimal: Decimal128,
    $numberDouble: Double,
    $numberLong: Long,
    $minKey: MinKey,
    $maxKey: MaxKey,
    $regex: BSONRegExp,
    $regularExpression: BSONRegExp,
    $timestamp: Timestamp
  };
  function deserializeValue(value, options = {}) {
    if (typeof value === "number") {
      const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
      const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
      if (options.relaxed || options.legacy) {
        return value;
      }
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (in32BitRange) {
          return new Int32(value);
        }
        if (in64BitRange) {
          if (options.useBigInt64) {
            return BigInt(value);
          }
          return Long.fromNumber(value);
        }
      }
      return new Double(value);
    }
    if (value == null || typeof value !== "object")
      return value;
    if (value.$undefined)
      return null;
    const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
    for (let i = 0;i < keys.length; i++) {
      const c = keysToCodecs[keys[i]];
      if (c)
        return c.fromExtendedJSON(value, options);
    }
    if (value.$date != null) {
      const d = value.$date;
      const date = new Date;
      if (options.legacy) {
        if (typeof d === "number")
          date.setTime(d);
        else if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      } else {
        if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (Long.isLong(d))
          date.setTime(d.toNumber());
        else if (typeof d === "number" && options.relaxed)
          date.setTime(d);
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      }
      return date;
    }
    if (value.$code != null) {
      const copy = Object.assign({}, value);
      if (value.$scope) {
        copy.$scope = deserializeValue(value.$scope);
      }
      return Code.fromExtendedJSON(value);
    }
    if (isDBRefLike(value) || value.$dbPointer) {
      const v = value.$ref ? value : value.$dbPointer;
      if (v instanceof DBRef)
        return v;
      const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
      let valid = true;
      dollarKeys.forEach((k) => {
        if (["$ref", "$id", "$db"].indexOf(k) === -1)
          valid = false;
      });
      if (valid)
        return DBRef.fromExtendedJSON(v);
    }
    return value;
  }
  function serializeArray(array, options) {
    return array.map((v, index) => {
      options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
      try {
        return serializeValue(v, options);
      } finally {
        options.seenObjects.pop();
      }
    });
  }
  function getISOString(date) {
    const isoStr = date.toISOString();
    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
  }
  function serializeValue(value, options) {
    if (value instanceof Map || isMap(value)) {
      const obj = Object.create(null);
      for (const [k, v] of value) {
        if (typeof k !== "string") {
          throw new BSONError("Can only serialize maps with string keys");
        }
        obj[k] = v;
      }
      return serializeValue(obj, options);
    }
    if ((typeof value === "object" || typeof value === "function") && value !== null) {
      const index = options.seenObjects.findIndex((entry) => entry.obj === value);
      if (index !== -1) {
        const props = options.seenObjects.map((entry) => entry.propertyName);
        const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
        const alreadySeen = props[index];
        const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
        const current = props[props.length - 1];
        const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
        const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
        throw new BSONError(`Converting circular structure to EJSON:
` + `    ${leadingPart}${alreadySeen}${circularPart}${current}
` + `    ${leadingSpace}\\${dashes}/`);
      }
      options.seenObjects[options.seenObjects.length - 1].obj = value;
    }
    if (Array.isArray(value))
      return serializeArray(value, options);
    if (value === undefined)
      return null;
    if (value instanceof Date || isDate(value)) {
      const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
      if (options.legacy) {
        return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
      }
      return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
    }
    if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return { $numberInt: value.toString() };
        }
        if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
          return { $numberLong: value.toString() };
        }
      }
      return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
    }
    if (typeof value === "bigint") {
      if (!options.relaxed) {
        return { $numberLong: BigInt.asIntN(64, value).toString() };
      }
      return Number(BigInt.asIntN(64, value));
    }
    if (value instanceof RegExp || isRegExp(value)) {
      let flags = value.flags;
      if (flags === undefined) {
        const match = value.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      const rx = new BSONRegExp(value.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value != null && typeof value === "object")
      return serializeDocument(value, options);
    return value;
  }
  var BSON_TYPE_MAPPINGS = {
    Binary: (o) => new Binary(o.value(), o.sub_type),
    Code: (o) => new Code(o.code, o.scope),
    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
    Decimal128: (o) => new Decimal128(o.bytes),
    Double: (o) => new Double(o.value),
    Int32: (o) => new Int32(o.value),
    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
    MaxKey: () => new MaxKey,
    MinKey: () => new MinKey,
    ObjectId: (o) => new ObjectId(o),
    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
    BSONSymbol: (o) => new BSONSymbol(o.value),
    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
  };
  function serializeDocument(doc, options) {
    if (doc == null || typeof doc !== "object")
      throw new BSONError("not an object instance");
    const bsontype = doc._bsontype;
    if (typeof bsontype === "undefined") {
      const _doc = {};
      for (const name of Object.keys(doc)) {
        options.seenObjects.push({ propertyName: name, obj: null });
        try {
          const value = serializeValue(doc[name], options);
          if (name === "__proto__") {
            Object.defineProperty(_doc, name, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            _doc[name] = value;
          }
        } finally {
          options.seenObjects.pop();
        }
      }
      return _doc;
    } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
      throw new BSONVersionError;
    } else if (isBSONType(doc)) {
      let outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== "function") {
        const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === "Code" && outDoc.scope) {
        outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
      } else if (bsontype === "DBRef" && outDoc.oid) {
        outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
    }
  }
  function parse(text, options) {
    const ejsonOptions = {
      useBigInt64: options?.useBigInt64 ?? false,
      relaxed: options?.relaxed ?? true,
      legacy: options?.legacy ?? false
    };
    return JSON.parse(text, (key, value) => {
      if (key.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
      }
      return deserializeValue(value, ejsonOptions);
    });
  }
  function stringify(value, replacer, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      options = replacer;
      replacer = undefined;
      space = 0;
    }
    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    const doc = serializeValue(value, serializeOptions);
    return JSON.stringify(doc, replacer, space);
  }
  function EJSONserialize(value, options) {
    options = options || {};
    return JSON.parse(stringify(value, options));
  }
  function EJSONdeserialize(ejson, options) {
    options = options || {};
    return parse(JSON.stringify(ejson), options);
  }
  var EJSON = Object.create(null);
  EJSON.parse = parse;
  EJSON.stringify = stringify;
  EJSON.serialize = EJSONserialize;
  EJSON.deserialize = EJSONdeserialize;
  Object.freeze(EJSON);
  var BSONElementType = {
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: 255,
    maxKey: 127
  };
  function getSize(source, offset) {
    try {
      return NumberUtils.getNonnegativeInt32LE(source, offset);
    } catch (cause) {
      throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
    }
  }
  function findNull(bytes, offset) {
    let nullTerminatorOffset = offset;
    for (;bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
      ;
    if (nullTerminatorOffset === bytes.length - 1) {
      throw new BSONOffsetError("Null terminator not found", offset);
    }
    return nullTerminatorOffset;
  }
  function parseToElements(bytes, startOffset = 0) {
    startOffset ??= 0;
    if (bytes.length < 5) {
      throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
    }
    const documentSize = getSize(bytes, startOffset);
    if (documentSize > bytes.length - startOffset) {
      throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
    }
    if (bytes[startOffset + documentSize - 1] !== 0) {
      throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
    }
    const elements = [];
    let offset = startOffset + 4;
    while (offset <= documentSize + startOffset) {
      const type = bytes[offset];
      offset += 1;
      if (type === 0) {
        if (offset - startOffset !== documentSize) {
          throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
        }
        break;
      }
      const nameOffset = offset;
      const nameLength = findNull(bytes, offset) - nameOffset;
      offset += nameLength + 1;
      let length;
      if (type === BSONElementType.double || type === BSONElementType.long || type === BSONElementType.date || type === BSONElementType.timestamp) {
        length = 8;
      } else if (type === BSONElementType.int) {
        length = 4;
      } else if (type === BSONElementType.objectId) {
        length = 12;
      } else if (type === BSONElementType.decimal) {
        length = 16;
      } else if (type === BSONElementType.bool) {
        length = 1;
      } else if (type === BSONElementType.null || type === BSONElementType.undefined || type === BSONElementType.maxKey || type === BSONElementType.minKey) {
        length = 0;
      } else if (type === BSONElementType.regex) {
        length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
      } else if (type === BSONElementType.object || type === BSONElementType.array || type === BSONElementType.javascriptWithScope) {
        length = getSize(bytes, offset);
      } else if (type === BSONElementType.string || type === BSONElementType.binData || type === BSONElementType.dbPointer || type === BSONElementType.javascript || type === BSONElementType.symbol) {
        length = getSize(bytes, offset) + 4;
        if (type === BSONElementType.binData) {
          length += 1;
        }
        if (type === BSONElementType.dbPointer) {
          length += 12;
        }
      } else {
        throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
      }
      if (length > documentSize) {
        throw new BSONOffsetError("value reports length larger than document", offset);
      }
      elements.push([type, nameOffset, nameLength, offset, length]);
      offset += length;
    }
    return elements;
  }
  var onDemand = Object.create(null);
  onDemand.parseToElements = parseToElements;
  onDemand.ByteUtils = ByteUtils;
  onDemand.NumberUtils = NumberUtils;
  Object.freeze(onDemand);
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = ByteUtils.allocate(MAXSIZE);
  function setInternalBufferSize(size) {
    if (buffer.length < size) {
      buffer = ByteUtils.allocate(size);
    }
  }
  function serialize(object, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = ByteUtils.allocate(minInternalBufferSize);
    }
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    return finishedBuffer;
  }
  function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === "number" ? options.index : 0;
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    return startIndex + serializationIndex - 1;
  }
  function deserialize(buffer2, options = {}) {
    return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
  }
  function calculateObjectSize(object, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
  }
  function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    for (let i = 0;i < numberOfDocuments; i++) {
      const size = NumberUtils.getInt32LE(bufferData, index);
      internalOptions.index = index;
      documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
      index = index + size;
    }
    return index;
  }
  var bson = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BSONError,
    BSONOffsetError,
    BSONRegExp,
    BSONRuntimeError,
    BSONSymbol,
    BSONType,
    BSONValue,
    BSONVersionError,
    Binary,
    Code,
    DBRef,
    Decimal128,
    Double,
    EJSON,
    Int32,
    Long,
    MaxKey,
    MinKey,
    ObjectId,
    Timestamp,
    UUID,
    calculateObjectSize,
    deserialize,
    deserializeStream,
    onDemand,
    serialize,
    serializeWithBufferAndIndex,
    setInternalBufferSize
  });
  exports.BSON = bson;
  exports.BSONError = BSONError;
  exports.BSONOffsetError = BSONOffsetError;
  exports.BSONRegExp = BSONRegExp;
  exports.BSONRuntimeError = BSONRuntimeError;
  exports.BSONSymbol = BSONSymbol;
  exports.BSONType = BSONType;
  exports.BSONValue = BSONValue;
  exports.BSONVersionError = BSONVersionError;
  exports.Binary = Binary;
  exports.Code = Code;
  exports.DBRef = DBRef;
  exports.Decimal128 = Decimal128;
  exports.Double = Double;
  exports.EJSON = EJSON;
  exports.Int32 = Int32;
  exports.Long = Long;
  exports.MaxKey = MaxKey;
  exports.MinKey = MinKey;
  exports.ObjectId = ObjectId;
  exports.Timestamp = Timestamp;
  exports.UUID = UUID;
  exports.calculateObjectSize = calculateObjectSize;
  exports.deserialize = deserialize;
  exports.deserializeStream = deserializeStream;
  exports.onDemand = onDemand;
  exports.serialize = serialize;
  exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  exports.setInternalBufferSize = setInternalBufferSize;
});

// src/backtest/engine.ts
class BacktestEngine {
  config;
  data;
  portfolio;
  strategy;
  bars = new Map;
  currentBarIndex = 0;
  maxBars = 0;
  currentBar = null;
  barHistory = new Map;
  constructor(data, strategy, config) {
    this.data = data;
    this.strategy = strategy;
    this.config = {
      initialCapital: config?.initialCapital ?? 1000,
      feeRate: config?.feeRate ?? 0,
      slippage: config?.slippage ?? 0
    };
    this.portfolio = new Portfolio(this.config.initialCapital, this.config.feeRate);
    this.prepareBars();
  }
  prepareBars() {
    const allTimestamps = new Set;
    for (const [tokenId, history] of this.data.priceHistory) {
      for (const point of history) {
        allTimestamps.add(point.t);
      }
    }
    const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
    for (const [tokenId, history] of this.data.priceHistory) {
      const priceMap = new Map;
      for (const point of history) {
        priceMap.set(point.t, point.p);
      }
      const market = this.findMarketForToken(tokenId);
      if (!market)
        continue;
      const tokenBars = [];
      for (const ts of sortedTimestamps) {
        const price = priceMap.get(ts);
        if (price !== undefined) {
          tokenBars.push({
            timestamp: ts,
            open: price,
            high: price,
            low: price,
            close: price,
            tokenId,
            market
          });
        }
      }
      this.bars.set(tokenId, tokenBars);
      this.barHistory.set(tokenId, []);
      if (tokenBars.length > this.maxBars) {
        this.maxBars = tokenBars.length;
      }
    }
  }
  findMarketForToken(tokenId) {
    return this.data.markets.find((m) => m.tokens.some((t) => t.token_id === tokenId));
  }
  run() {
    const ctx = this.createContext();
    this.strategy.onInit(ctx);
    const tokenIds = Array.from(this.bars.keys());
    for (let i = 0;i < this.maxBars; i++) {
      this.currentBarIndex = i;
      const currentPrices = new Map;
      for (const tokenId of tokenIds) {
        const tokenBars = this.bars.get(tokenId);
        if (tokenBars && tokenBars[i]) {
          const bar = tokenBars[i];
          this.currentBar = bar;
          currentPrices.set(tokenId, bar.close);
          const history = this.barHistory.get(tokenId) ?? [];
          history.push(bar);
          this.barHistory.set(tokenId, history);
          this.strategy.onNext(ctx, bar);
        }
      }
      this.portfolio.updatePositionValues(currentPrices);
    }
    return this.calculateResult();
  }
  createContext() {
    const self = this;
    const portfolioAPI = {
      getPosition(tokenId) {
        return self.portfolio.getPosition(tokenId);
      },
      getAllPositions() {
        return self.portfolio.getAllPositions();
      },
      getTotalValue() {
        const prices = new Map;
        for (const [tokenId, bars] of self.bars) {
          if (bars[self.currentBarIndex]) {
            prices.set(tokenId, bars[self.currentBarIndex].close);
          }
        }
        return self.portfolio.getTotalValue(prices);
      },
      getPnL() {
        const prices = new Map;
        for (const [tokenId, bars] of self.bars) {
          if (bars[self.currentBarIndex]) {
            prices.set(tokenId, bars[self.currentBarIndex].close);
          }
        }
        return self.portfolio.getPnL(prices);
      }
    };
    const dataAPI = {
      getBar(tokenId, offset = 0) {
        const history = self.barHistory.get(tokenId);
        if (!history)
          return;
        const idx = history.length - 1 - offset;
        return idx >= 0 ? history[idx] : undefined;
      },
      getHistory(tokenId, length) {
        const history = self.barHistory.get(tokenId) ?? [];
        if (length === undefined)
          return [...history];
        return history.slice(-length);
      }
    };
    return {
      portfolio: portfolioAPI,
      data: dataAPI,
      buy(tokenId, size) {
        const bar = self.currentBar;
        if (!bar) {
          return {
            success: false,
            tokenId,
            side: "BUY",
            size: 0,
            price: 0,
            totalCost: 0,
            error: "No current bar"
          };
        }
        const price = bar.close;
        return self.portfolio.buy(tokenId, size, price, bar.timestamp);
      },
      sell(tokenId, size) {
        const bar = self.currentBar;
        if (!bar) {
          return {
            success: false,
            tokenId,
            side: "SELL",
            size: 0,
            price: 0,
            totalCost: 0,
            error: "No current bar"
          };
        }
        const price = bar.close;
        return self.portfolio.sell(tokenId, size, price, bar.timestamp);
      },
      close(tokenId) {
        const bar = self.currentBar;
        if (!bar) {
          return {
            success: false,
            tokenId,
            side: "SELL",
            size: 0,
            price: 0,
            totalCost: 0,
            error: "No current bar"
          };
        }
        const price = bar.close;
        return self.portfolio.close(tokenId, price, bar.timestamp);
      },
      getPosition(tokenId) {
        return self.portfolio.getPosition(tokenId);
      },
      getCapital() {
        return self.portfolio.getCapital();
      },
      getCurrentPrice(tokenId) {
        const bar = self.currentBar;
        if (!bar || bar.tokenId !== tokenId) {
          const bars = self.bars.get(tokenId);
          if (bars && bars[self.currentBarIndex]) {
            return bars[self.currentBarIndex].close;
          }
          return 0;
        }
        return bar.close;
      },
      getCurrentBar() {
        return self.currentBar;
      }
    };
  }
  calculateResult() {
    const tradeHistory = this.portfolio.getTradeHistory();
    const finalPrices = new Map;
    for (const [tokenId, bars] of this.bars) {
      if (bars.length > 0) {
        finalPrices.set(tokenId, bars[bars.length - 1].close);
      }
    }
    const finalCapital = this.portfolio.getTotalValue(finalPrices);
    const totalReturn = finalCapital - this.config.initialCapital;
    const totalReturnPercent = totalReturn / this.config.initialCapital * 100;
    const values = [];
    let runningValue = this.config.initialCapital;
    let maxValue = runningValue;
    let maxDrawdown = 0;
    for (const trade of tradeHistory) {
      const pos = this.portfolio.getPosition(trade.tokenId);
      const price = finalPrices.get(trade.tokenId) ?? trade.price;
      if (trade.side === "SELL") {
        runningValue = trade.capitalAfter;
      } else {
        runningValue = trade.capitalAfter;
      }
      if (pos) {
        runningValue += pos.size * price;
      }
      values.push(runningValue);
      if (runningValue > maxValue) {
        maxValue = runningValue;
      }
      const drawdown = (maxValue - runningValue) / maxValue;
      if (drawdown > maxDrawdown) {
        maxDrawdown = drawdown;
      }
    }
    let sharpeRatio = 0;
    if (values.length > 1) {
      const returns = [];
      for (let i = 1;i < values.length; i++) {
        returns.push((values[i] - values[i - 1]) / values[i - 1]);
      }
      const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
      const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
      sharpeRatio = stdDev > 0 ? avgReturn / stdDev * Math.sqrt(252) : 0;
    }
    let winningTrades = 0;
    let losingTrades = 0;
    let totalBuyCost = new Map;
    let totalBuySize = new Map;
    for (const trade of tradeHistory) {
      if (trade.side === "BUY") {
        const prevCost = totalBuyCost.get(trade.tokenId) ?? 0;
        const prevSize = totalBuySize.get(trade.tokenId) ?? 0;
        totalBuyCost.set(trade.tokenId, prevCost + trade.totalCost);
        totalBuySize.set(trade.tokenId, prevSize + trade.size);
      } else {
        const avgBuyPrice = (totalBuyCost.get(trade.tokenId) ?? 0) / (totalBuySize.get(trade.tokenId) ?? 1);
        const sellPrice = trade.price;
        if (sellPrice >= avgBuyPrice) {
          winningTrades++;
        } else {
          losingTrades++;
        }
        totalBuyCost.delete(trade.tokenId);
        totalBuySize.delete(trade.tokenId);
      }
    }
    return {
      finalCapital,
      totalReturn,
      totalReturnPercent,
      maxDrawdown: maxDrawdown * 100,
      sharpeRatio,
      totalTrades: tradeHistory.length,
      winningTrades,
      losingTrades,
      positions: this.portfolio.getAllPositions(),
      tradeHistory
    };
  }
}
function loadStoredData(filePath) {
  const fs = __require("fs");
  const path = __require("path");
  const BSON = require_bson();
  const content = fs.readFileSync(filePath, "utf8");
  let manifest = null;
  try {
    manifest = JSON.parse(content);
  } catch {}
  if (manifest && manifest.metadata) {
    const dir = path.dirname(filePath);
    const metadataBuffer = fs.readFileSync(path.join(dir, manifest.metadata));
    const metadata = BSON.deserialize(metadataBuffer);
    const markets = [];
    for (const chunkFile of manifest.markets) {
      const chunkBuffer = fs.readFileSync(path.join(dir, chunkFile));
      const chunk = BSON.deserialize(chunkBuffer);
      if (chunk.markets) {
        markets.push(...chunk.markets);
      }
    }
    const priceHistory2 = new Map;
    for (const chunkFile of manifest.priceHistory) {
      const chunkBuffer = fs.readFileSync(path.join(dir, chunkFile));
      const chunk = BSON.deserialize(chunkBuffer);
      if (chunk.priceHistory) {
        for (const [key, value] of Object.entries(chunk.priceHistory)) {
          priceHistory2.set(key, value);
        }
      }
    }
    return {
      markets,
      priceHistory: priceHistory2,
      collectionMetadata: metadata.collectionMetadata ?? {
        collectedAt: "",
        version: "1.0.0",
        totalMarkets: markets.length,
        totalPricePoints: Array.from(priceHistory2.values()).reduce((sum, h) => sum + h.length, 0)
      }
    };
  }
  const buffer = fs.readFileSync(filePath);
  const raw = BSON.deserialize(buffer);
  const priceHistory = new Map;
  if (raw.priceHistory) {
    if (raw.priceHistory instanceof Map) {
      for (const [key, value] of raw.priceHistory) {
        priceHistory.set(key, value);
      }
    } else {
      for (const key of Object.keys(raw.priceHistory)) {
        priceHistory.set(key, raw.priceHistory[key]);
      }
    }
  }
  return {
    markets: raw.markets ?? [],
    priceHistory,
    collectionMetadata: raw.collectionMetadata ?? {
      collectedAt: "",
      version: "1.0.0",
      totalMarkets: 0,
      totalPricePoints: 0
    }
  };
}
var init_engine = () => {};

// node_modules/cli-progress/lib/eta.js
var require_eta = __commonJS((exports, module) => {
  class ETA {
    constructor(length, initTime, initValue) {
      this.etaBufferLength = length || 100;
      this.valueBuffer = [initValue];
      this.timeBuffer = [initTime];
      this.eta = "0";
    }
    update(time, value, total) {
      this.valueBuffer.push(value);
      this.timeBuffer.push(time);
      this.calculate(total - value);
    }
    getTime() {
      return this.eta;
    }
    calculate(remaining) {
      const currentBufferSize = this.valueBuffer.length;
      const buffer = Math.min(this.etaBufferLength, currentBufferSize);
      const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer];
      const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer];
      const vt_rate = v_diff / t_diff;
      this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
      this.timeBuffer = this.timeBuffer.slice(-this.etaBufferLength);
      const eta = Math.ceil(remaining / vt_rate / 1000);
      if (isNaN(eta)) {
        this.eta = "NULL";
      } else if (!isFinite(eta)) {
        this.eta = "INF";
      } else if (eta > 1e7) {
        this.eta = "INF";
      } else if (eta < 0) {
        this.eta = 0;
      } else {
        this.eta = eta;
      }
    }
  }
  module.exports = ETA;
});

// node_modules/cli-progress/lib/terminal.js
var require_terminal = __commonJS((exports, module) => {
  var _readline = __require("readline");

  class Terminal {
    constructor(outputStream) {
      this.stream = outputStream;
      this.linewrap = true;
      this.dy = 0;
    }
    cursorSave() {
      if (!this.stream.isTTY) {
        return;
      }
      this.stream.write("\x1B7");
    }
    cursorRestore() {
      if (!this.stream.isTTY) {
        return;
      }
      this.stream.write("\x1B8");
    }
    cursor(enabled) {
      if (!this.stream.isTTY) {
        return;
      }
      if (enabled) {
        this.stream.write("\x1B[?25h");
      } else {
        this.stream.write("\x1B[?25l");
      }
    }
    cursorTo(x = null, y = null) {
      if (!this.stream.isTTY) {
        return;
      }
      _readline.cursorTo(this.stream, x, y);
    }
    cursorRelative(dx = null, dy = null) {
      if (!this.stream.isTTY) {
        return;
      }
      this.dy = this.dy + dy;
      _readline.moveCursor(this.stream, dx, dy);
    }
    cursorRelativeReset() {
      if (!this.stream.isTTY) {
        return;
      }
      _readline.moveCursor(this.stream, 0, -this.dy);
      _readline.cursorTo(this.stream, 0, null);
      this.dy = 0;
    }
    clearRight() {
      if (!this.stream.isTTY) {
        return;
      }
      _readline.clearLine(this.stream, 1);
    }
    clearLine() {
      if (!this.stream.isTTY) {
        return;
      }
      _readline.clearLine(this.stream, 0);
    }
    clearBottom() {
      if (!this.stream.isTTY) {
        return;
      }
      _readline.clearScreenDown(this.stream);
    }
    newline() {
      this.stream.write(`
`);
      this.dy++;
    }
    write(s, rawWrite = false) {
      if (this.linewrap === true && rawWrite === false) {
        this.stream.write(s.substr(0, this.getWidth()));
      } else {
        this.stream.write(s);
      }
    }
    lineWrapping(enabled) {
      if (!this.stream.isTTY) {
        return;
      }
      this.linewrap = enabled;
      if (enabled) {
        this.stream.write("\x1B[?7h");
      } else {
        this.stream.write("\x1B[?7l");
      }
    }
    isTTY() {
      return this.stream.isTTY === true;
    }
    getWidth() {
      return this.stream.columns || (this.stream.isTTY ? 80 : 200);
    }
  }
  module.exports = Terminal;
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0;i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// node_modules/cli-progress/lib/format-value.js
var require_format_value = __commonJS((exports, module) => {
  module.exports = function formatValue(v, options, type) {
    if (options.autopadding !== true) {
      return v;
    }
    function autopadding(value, length) {
      return (options.autopaddingChar + value).slice(-length);
    }
    switch (type) {
      case "percentage":
        return autopadding(v, 3);
      default:
        return v;
    }
  };
});

// node_modules/cli-progress/lib/format-bar.js
var require_format_bar = __commonJS((exports, module) => {
  module.exports = function formatBar(progress, options) {
    const completeSize = Math.round(progress * options.barsize);
    const incompleteSize = options.barsize - completeSize;
    return options.barCompleteString.substr(0, completeSize) + options.barGlue + options.barIncompleteString.substr(0, incompleteSize);
  };
});

// node_modules/cli-progress/lib/format-time.js
var require_format_time = __commonJS((exports, module) => {
  module.exports = function formatTime(t, options, roundToMultipleOf) {
    function round(input) {
      if (roundToMultipleOf) {
        return roundToMultipleOf * Math.round(input / roundToMultipleOf);
      } else {
        return input;
      }
    }
    function autopadding(v) {
      return (options.autopaddingChar + v).slice(-2);
    }
    if (t > 3600) {
      return autopadding(Math.floor(t / 3600)) + "h" + autopadding(round(t % 3600 / 60)) + "m";
    } else if (t > 60) {
      return autopadding(Math.floor(t / 60)) + "m" + autopadding(round(t % 60)) + "s";
    } else if (t > 10) {
      return autopadding(round(t)) + "s";
    } else {
      return autopadding(t) + "s";
    }
  };
});

// node_modules/cli-progress/lib/formatter.js
var require_formatter = __commonJS((exports, module) => {
  var _stringWidth = require_string_width();
  var _defaultFormatValue = require_format_value();
  var _defaultFormatBar = require_format_bar();
  var _defaultFormatTime = require_format_time();
  module.exports = function defaultFormatter(options, params, payload) {
    let s = options.format;
    const formatTime = options.formatTime || _defaultFormatTime;
    const formatValue = options.formatValue || _defaultFormatValue;
    const formatBar = options.formatBar || _defaultFormatBar;
    const percentage = Math.floor(params.progress * 100) + "";
    const stopTime = params.stopTime || Date.now();
    const elapsedTime = Math.round((stopTime - params.startTime) / 1000);
    const context = Object.assign({}, payload, {
      bar: formatBar(params.progress, options),
      percentage: formatValue(percentage, options, "percentage"),
      total: formatValue(params.total, options, "total"),
      value: formatValue(params.value, options, "value"),
      eta: formatValue(params.eta, options, "eta"),
      eta_formatted: formatTime(params.eta, options, 5),
      duration: formatValue(elapsedTime, options, "duration"),
      duration_formatted: formatTime(elapsedTime, options, 1)
    });
    s = s.replace(/\{(\w+)\}/g, function(match, key) {
      if (typeof context[key] !== "undefined") {
        return context[key];
      }
      return match;
    });
    const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s) - 2);
    const halfMargin = Math.floor(fullMargin / 2);
    switch (options.align) {
      case "right":
        s = fullMargin > 0 ? " ".repeat(fullMargin) + s : s;
        break;
      case "center":
        s = halfMargin > 0 ? " ".repeat(halfMargin) + s : s;
        break;
      case "left":
      default:
        break;
    }
    return s;
  };
});

// node_modules/cli-progress/lib/options.js
var require_options = __commonJS((exports, module) => {
  function mergeOption(v, defaultValue) {
    if (typeof v === "undefined" || v === null) {
      return defaultValue;
    } else {
      return v;
    }
  }
  module.exports = {
    parse: function parse(rawOptions, preset) {
      const options = {};
      const opt = Object.assign({}, preset, rawOptions);
      options.throttleTime = 1000 / mergeOption(opt.fps, 10);
      options.stream = mergeOption(opt.stream, process.stderr);
      options.terminal = mergeOption(opt.terminal, null);
      options.clearOnComplete = mergeOption(opt.clearOnComplete, false);
      options.stopOnComplete = mergeOption(opt.stopOnComplete, false);
      options.barsize = mergeOption(opt.barsize, 40);
      options.align = mergeOption(opt.align, "left");
      options.hideCursor = mergeOption(opt.hideCursor, false);
      options.linewrap = mergeOption(opt.linewrap, false);
      options.barGlue = mergeOption(opt.barGlue, "");
      options.barCompleteChar = mergeOption(opt.barCompleteChar, "=");
      options.barIncompleteChar = mergeOption(opt.barIncompleteChar, "-");
      options.format = mergeOption(opt.format, "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}");
      options.formatTime = mergeOption(opt.formatTime, null);
      options.formatValue = mergeOption(opt.formatValue, null);
      options.formatBar = mergeOption(opt.formatBar, null);
      options.etaBufferLength = mergeOption(opt.etaBuffer, 10);
      options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);
      options.progressCalculationRelative = mergeOption(opt.progressCalculationRelative, false);
      options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);
      options.noTTYOutput = mergeOption(opt.noTTYOutput, false);
      options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2000);
      options.emptyOnZero = mergeOption(opt.emptyOnZero, false);
      options.forceRedraw = mergeOption(opt.forceRedraw, false);
      options.autopadding = mergeOption(opt.autopadding, false);
      options.gracefulExit = mergeOption(opt.gracefulExit, false);
      return options;
    },
    assignDerivedOptions: function assignDerivedOptions(options) {
      options.barCompleteString = options.barCompleteChar.repeat(options.barsize + 1);
      options.barIncompleteString = options.barIncompleteChar.repeat(options.barsize + 1);
      options.autopaddingChar = options.autopadding ? mergeOption(options.autopaddingChar, "   ") : "";
      return options;
    }
  };
});

// node_modules/cli-progress/lib/generic-bar.js
var require_generic_bar = __commonJS((exports, module) => {
  var _ETA = require_eta();
  var _Terminal = require_terminal();
  var _formatter = require_formatter();
  var _options = require_options();
  var _EventEmitter = __require("events");
  module.exports = class GenericBar extends _EventEmitter {
    constructor(options) {
      super();
      this.options = _options.assignDerivedOptions(options);
      this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
      this.value = 0;
      this.startValue = 0;
      this.total = 100;
      this.lastDrawnString = null;
      this.startTime = null;
      this.stopTime = null;
      this.lastRedraw = Date.now();
      this.eta = new _ETA(this.options.etaBufferLength, 0, 0);
      this.payload = {};
      this.isActive = false;
      this.formatter = typeof this.options.format === "function" ? this.options.format : _formatter;
    }
    render(forceRendering = false) {
      const params = {
        progress: this.getProgress(),
        eta: this.eta.getTime(),
        startTime: this.startTime,
        stopTime: this.stopTime,
        total: this.total,
        value: this.value,
        maxWidth: this.terminal.getWidth()
      };
      if (this.options.etaAsynchronousUpdate) {
        this.updateETA();
      }
      const s = this.formatter(this.options, params, this.payload);
      const forceRedraw = forceRendering || this.options.forceRedraw || this.options.noTTYOutput && !this.terminal.isTTY();
      if (forceRedraw || this.lastDrawnString != s) {
        this.emit("redraw-pre");
        this.terminal.cursorTo(0, null);
        this.terminal.write(s);
        this.terminal.clearRight();
        this.lastDrawnString = s;
        this.lastRedraw = Date.now();
        this.emit("redraw-post");
      }
    }
    start(total, startValue, payload) {
      this.value = startValue || 0;
      this.total = typeof total !== "undefined" && total >= 0 ? total : 100;
      this.startValue = startValue || 0;
      this.payload = payload || {};
      this.startTime = Date.now();
      this.stopTime = null;
      this.lastDrawnString = "";
      this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);
      this.isActive = true;
      this.emit("start", total, startValue);
    }
    stop() {
      this.isActive = false;
      this.stopTime = Date.now();
      this.emit("stop", this.total, this.value);
    }
    update(arg0, arg1 = {}) {
      if (typeof arg0 === "number") {
        this.value = arg0;
        this.eta.update(Date.now(), arg0, this.total);
      }
      const payloadData = (typeof arg0 === "object" ? arg0 : arg1) || {};
      this.emit("update", this.total, this.value);
      for (const key in payloadData) {
        this.payload[key] = payloadData[key];
      }
      if (this.value >= this.getTotal() && this.options.stopOnComplete) {
        this.stop();
      }
    }
    getProgress() {
      let progress = this.value / this.total;
      if (this.options.progressCalculationRelative) {
        progress = (this.value - this.startValue) / (this.total - this.startValue);
      }
      if (isNaN(progress)) {
        progress = this.options && this.options.emptyOnZero ? 0 : 1;
      }
      progress = Math.min(Math.max(progress, 0), 1);
      return progress;
    }
    increment(arg0 = 1, arg1 = {}) {
      if (typeof arg0 === "object") {
        this.update(this.value + 1, arg0);
      } else {
        this.update(this.value + arg0, arg1);
      }
    }
    getTotal() {
      return this.total;
    }
    setTotal(total) {
      if (typeof total !== "undefined" && total >= 0) {
        this.total = total;
      }
    }
    updateETA() {
      this.eta.update(Date.now(), this.value, this.total);
    }
  };
});

// node_modules/cli-progress/lib/single-bar.js
var require_single_bar = __commonJS((exports, module) => {
  var _GenericBar = require_generic_bar();
  var _options = require_options();
  module.exports = class SingleBar extends _GenericBar {
    constructor(options, preset) {
      super(_options.parse(options, preset));
      this.timer = null;
      if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
        this.options.synchronousUpdate = false;
      }
      this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
      this.sigintCallback = null;
    }
    render() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      super.render();
      if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
        this.terminal.newline();
      }
      this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
    }
    update(current, payload) {
      if (!this.timer) {
        return;
      }
      super.update(current, payload);
      if (this.options.synchronousUpdate && this.lastRedraw + this.options.throttleTime * 2 < Date.now()) {
        this.render();
      }
    }
    start(total, startValue, payload) {
      if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
        return;
      }
      if (this.sigintCallback === null && this.options.gracefulExit) {
        this.sigintCallback = this.stop.bind(this);
        process.once("SIGINT", this.sigintCallback);
        process.once("SIGTERM", this.sigintCallback);
      }
      this.terminal.cursorSave();
      if (this.options.hideCursor === true) {
        this.terminal.cursor(false);
      }
      if (this.options.linewrap === false) {
        this.terminal.lineWrapping(false);
      }
      super.start(total, startValue, payload);
      this.render();
    }
    stop() {
      if (!this.timer) {
        return;
      }
      if (this.sigintCallback) {
        process.removeListener("SIGINT", this.sigintCallback);
        process.removeListener("SIGTERM", this.sigintCallback);
        this.sigintCallback = null;
      }
      this.render();
      super.stop();
      clearTimeout(this.timer);
      this.timer = null;
      if (this.options.hideCursor === true) {
        this.terminal.cursor(true);
      }
      if (this.options.linewrap === false) {
        this.terminal.lineWrapping(true);
      }
      this.terminal.cursorRestore();
      if (this.options.clearOnComplete) {
        this.terminal.cursorTo(0, null);
        this.terminal.clearLine();
      } else {
        this.terminal.newline();
      }
    }
  };
});

// node_modules/cli-progress/lib/multi-bar.js
var require_multi_bar = __commonJS((exports, module) => {
  var _Terminal = require_terminal();
  var _BarElement = require_generic_bar();
  var _options = require_options();
  var _EventEmitter = __require("events");
  module.exports = class MultiBar extends _EventEmitter {
    constructor(options, preset) {
      super();
      this.bars = [];
      this.options = _options.parse(options, preset);
      this.options.synchronousUpdate = false;
      this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
      this.timer = null;
      this.isActive = false;
      this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
      this.loggingBuffer = [];
      this.sigintCallback = null;
    }
    create(total, startValue, payload, barOptions = {}) {
      const bar = new _BarElement(Object.assign({}, this.options, {
        terminal: this.terminal
      }, barOptions));
      this.bars.push(bar);
      if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
        return bar;
      }
      if (this.sigintCallback === null && this.options.gracefulExit) {
        this.sigintCallback = this.stop.bind(this);
        process.once("SIGINT", this.sigintCallback);
        process.once("SIGTERM", this.sigintCallback);
      }
      if (!this.isActive) {
        if (this.options.hideCursor === true) {
          this.terminal.cursor(false);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(false);
        }
        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
      }
      this.isActive = true;
      bar.start(total, startValue, payload);
      this.emit("start");
      return bar;
    }
    remove(bar) {
      const index = this.bars.indexOf(bar);
      if (index < 0) {
        return false;
      }
      this.bars.splice(index, 1);
      this.update();
      this.terminal.newline();
      this.terminal.clearBottom();
      return true;
    }
    update() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this.emit("update-pre");
      this.terminal.cursorRelativeReset();
      this.emit("redraw-pre");
      if (this.loggingBuffer.length > 0) {
        this.terminal.clearLine();
        while (this.loggingBuffer.length > 0) {
          this.terminal.write(this.loggingBuffer.shift(), true);
        }
      }
      for (let i = 0;i < this.bars.length; i++) {
        if (i > 0) {
          this.terminal.newline();
        }
        this.bars[i].render();
      }
      this.emit("redraw-post");
      if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
        this.terminal.newline();
        this.terminal.newline();
      }
      this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
      this.emit("update-post");
      if (this.options.stopOnComplete && !this.bars.find((bar) => bar.isActive)) {
        this.stop();
      }
    }
    stop() {
      clearTimeout(this.timer);
      this.timer = null;
      if (this.sigintCallback) {
        process.removeListener("SIGINT", this.sigintCallback);
        process.removeListener("SIGTERM", this.sigintCallback);
        this.sigintCallback = null;
      }
      this.isActive = false;
      if (this.options.hideCursor === true) {
        this.terminal.cursor(true);
      }
      if (this.options.linewrap === false) {
        this.terminal.lineWrapping(true);
      }
      this.terminal.cursorRelativeReset();
      this.emit("stop-pre-clear");
      if (this.options.clearOnComplete) {
        this.terminal.clearBottom();
      } else {
        for (let i = 0;i < this.bars.length; i++) {
          if (i > 0) {
            this.terminal.newline();
          }
          this.bars[i].render();
          this.bars[i].stop();
        }
        this.terminal.newline();
      }
      this.emit("stop");
    }
    log(s) {
      this.loggingBuffer.push(s);
    }
  };
});

// node_modules/cli-progress/presets/legacy.js
var require_legacy = __commonJS((exports, module) => {
  module.exports = {
    format: "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}",
    barCompleteChar: "=",
    barIncompleteChar: "-"
  };
});

// node_modules/cli-progress/presets/shades-classic.js
var require_shades_classic = __commonJS((exports, module) => {
  module.exports = {
    format: " {bar} {percentage}% | ETA: {eta}s | {value}/{total}",
    barCompleteChar: "",
    barIncompleteChar: ""
  };
});

// node_modules/cli-progress/presets/shades-grey.js
var require_shades_grey = __commonJS((exports, module) => {
  module.exports = {
    format: " \x1B[90m{bar}\x1B[0m {percentage}% | ETA: {eta}s | {value}/{total}",
    barCompleteChar: "",
    barIncompleteChar: ""
  };
});

// node_modules/cli-progress/presets/rect.js
var require_rect = __commonJS((exports, module) => {
  module.exports = {
    format: " {bar} {percentage}% | ETA: {eta}s | {value}/{total}",
    barCompleteChar: "",
    barIncompleteChar: " "
  };
});

// node_modules/cli-progress/presets/index.js
var require_presets = __commonJS((exports, module) => {
  var _legacy = require_legacy();
  var _shades_classic = require_shades_classic();
  var _shades_grey = require_shades_grey();
  var _rect = require_rect();
  module.exports = {
    legacy: _legacy,
    shades_classic: _shades_classic,
    shades_grey: _shades_grey,
    rect: _rect
  };
});

// node_modules/cli-progress/cli-progress.js
var require_cli_progress = __commonJS((exports, module) => {
  var _SingleBar = require_single_bar();
  var _MultiBar = require_multi_bar();
  var _Presets = require_presets();
  var _Formatter = require_formatter();
  var _defaultFormatValue = require_format_value();
  var _defaultFormatBar = require_format_bar();
  var _defaultFormatTime = require_format_time();
  module.exports = {
    Bar: _SingleBar,
    SingleBar: _SingleBar,
    MultiBar: _MultiBar,
    Presets: _Presets,
    Format: {
      Formatter: _Formatter,
      BarFormat: _defaultFormatBar,
      ValueFormat: _defaultFormatValue,
      TimeFormat: _defaultFormatTime
    }
  };
});

// node_modules/commander/esm.mjs
var import__ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import__.default;

// node_modules/kleur/index.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
  reset: init(0, 0),
  bold: init(1, 22),
  dim: init(2, 22),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  grey: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49)
};
function run(arr, str) {
  let i = 0, tmp, beg = "", end = "";
  for (;i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has, keys) {
  let ctx = { has, keys };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
}
function init(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== undefined && this.has !== undefined) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === undefined ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === undefined ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
  };
}
var kleur_default = $;

// scripts/run-optimization.ts
init_engine();

// src/types.ts
class Indicator {
  values = [];
  get(index = 0) {
    return this.values[this.values.length - 1 - index];
  }
  getValues() {
    return [...this.values];
  }
  push(value) {
    this.values.push(value);
  }
}

class SimpleMovingAverage extends Indicator {
  period;
  prices = [];
  constructor(period) {
    super();
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period) {
      this.prices.shift();
    }
    if (this.prices.length === this.period) {
      const sum = this.prices.reduce((a, b) => a + b, 0);
      this.push(sum / this.period);
    }
  }
}

class CrossOver extends Indicator {
  line1;
  line2;
  prevDiff = null;
  constructor(line1, line2) {
    super();
    this.line1 = line1;
    this.line2 = line2;
  }
  update() {
    const val1 = this.line1.get(0);
    const val2 = this.line2.get(0);
    if (val1 === undefined || val2 === undefined) {
      return;
    }
    const diff = val1 - val2;
    if (this.prevDiff !== null) {
      if (this.prevDiff <= 0 && diff > 0) {
        this.push(1);
      } else if (this.prevDiff >= 0 && diff < 0) {
        this.push(-1);
      } else {
        this.push(0);
      }
    }
    this.prevDiff = diff;
  }
}

class RSI extends Indicator {
  period;
  prices = [];
  gains = [];
  losses = [];
  avgGain = 0;
  avgLoss = 0;
  initialized = false;
  constructor(period) {
    super();
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period) {
      this.prices.shift();
    }
    if (this.prices.length >= 2) {
      const change = this.prices[this.prices.length - 1] - this.prices[this.prices.length - 2];
      const gain = change > 0 ? change : 0;
      const loss = change < 0 ? -change : 0;
      this.gains.push(gain);
      this.losses.push(loss);
      if (this.gains.length > this.period) {
        this.gains.shift();
        this.losses.shift();
      }
      if (!this.initialized && this.gains.length === this.period) {
        this.avgGain = this.gains.reduce((a, b) => a + b, 0) / this.period;
        this.avgLoss = this.losses.reduce((a, b) => a + b, 0) / this.period;
        this.initialized = true;
      } else if (this.initialized) {
        this.avgGain = (this.avgGain * (this.period - 1) + gain) / this.period;
        this.avgLoss = (this.avgLoss * (this.period - 1) + loss) / this.period;
      }
      if (this.initialized && this.avgLoss === 0) {
        this.push(100);
      } else if (this.initialized) {
        const rs = this.avgGain / this.avgLoss;
        const rsi = 100 - 100 / (1 + rs);
        this.push(rsi);
      }
    }
  }
}

class ATR extends Indicator {
  period;
  highs = [];
  lows = [];
  closes = [];
  prevClose = null;
  trValues = [];
  constructor(period) {
    super();
    this.period = period;
  }
  update(high, low, close) {
    this.highs.push(high);
    this.lows.push(low);
    this.closes.push(close);
    if (this.highs.length > this.period) {
      this.highs.shift();
      this.lows.shift();
      this.closes.shift();
    }
    if (this.closes.length >= 2) {
      const tr = Math.max(this.highs[this.highs.length - 1] - this.lows[this.lows.length - 1], Math.abs(this.highs[this.highs.length - 1] - this.closes[this.closes.length - 2]), Math.abs(this.lows[this.lows.length - 1] - this.closes[this.closes.length - 2]));
      this.trValues.push(tr);
      if (this.trValues.length > this.period) {
        this.trValues.shift();
      }
      if (this.trValues.length === this.period) {
        const atr = this.trValues.reduce((a, b) => a + b, 0) / this.period;
        this.push(atr);
      }
    }
  }
}

// src/strategies/strat_simple_ma_01.ts
import * as fs from "fs";
import * as path from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams = {
  fast_period: 50,
  slow_period: 200,
  stop_loss: 0.02,
  trailing_stop: false,
  risk_percent: 0.1,
  rsi_enabled: false,
  rsi_period: 14,
  rsi_oversold: 30,
  rsi_overbought: 70,
  atr_enabled: false,
  atr_multiplier: 2,
  take_profit_enabled: false,
  take_profit: 0.05,
  exit_strategy: 0
};
function loadSavedParams() {
  const paramsPath = path.join(__dirname, "strat_simple_ma_01.params.json");
  if (!fs.existsSync(paramsPath))
    return null;
  try {
    const content = fs.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    const booleanParams = ["trailing_stop", "rsi_enabled", "atr_enabled", "take_profit_enabled"];
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams) {
        if (booleanParams.includes(key)) {
          if (typeof value === "number") {
            params[key] = value === 1;
          } else if (typeof value === "boolean") {
            params[key] = value;
          }
        } else if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SimpleMAStrategy {
  params;
  fastMA;
  slowMA;
  crossover;
  rsi;
  atr;
  buyPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams();
    const mergedParams = { ...defaultParams, ...savedParams, ...params };
    let fast = mergedParams.fast_period;
    let slow = mergedParams.slow_period;
    if (fast >= slow) {
      [fast, slow] = [slow, fast];
    }
    this.params = {
      fast_period: fast,
      slow_period: slow,
      stop_loss: mergedParams.stop_loss,
      trailing_stop: mergedParams.trailing_stop,
      risk_percent: mergedParams.risk_percent,
      rsi_enabled: mergedParams.rsi_enabled,
      rsi_period: mergedParams.rsi_period,
      rsi_oversold: mergedParams.rsi_oversold,
      rsi_overbought: mergedParams.rsi_overbought,
      atr_enabled: mergedParams.atr_enabled,
      atr_multiplier: mergedParams.atr_multiplier,
      take_profit_enabled: mergedParams.take_profit_enabled,
      take_profit: mergedParams.take_profit,
      exit_strategy: mergedParams.exit_strategy
    };
    this.fastMA = new SimpleMovingAverage(this.params.fast_period);
    this.slowMA = new SimpleMovingAverage(this.params.slow_period);
    this.crossover = new CrossOver(this.fastMA, this.slowMA);
    this.rsi = new RSI(this.params.rsi_period);
    this.atr = new ATR(this.params.slow_period);
  }
  onInit(_ctx) {
    console.log(`SimpleMAStrategy initialized with params:`);
    console.log(`  Fast MA period: ${this.params.fast_period}`);
    console.log(`  Slow MA period: ${this.params.slow_period}`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Trailing stop: ${this.params.trailing_stop}`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
    console.log(`  RSI: ${this.params.rsi_enabled ? `period=${this.params.rsi_period}, oversold=${this.params.rsi_oversold}, overbought=${this.params.rsi_overbought}` : "disabled"}`);
    console.log(`  ATR: ${this.params.atr_enabled ? `multiplier=${this.params.atr_multiplier}` : "disabled"}`);
    console.log(`  Take Profit: ${this.params.take_profit_enabled ? `${this.params.take_profit * 100}%` : "disabled"}`);
    console.log(`  Exit Strategy: ${this.params.exit_strategy}`);
  }
  onNext(ctx, bar) {
    this.fastMA.update(bar.close);
    this.slowMA.update(bar.close);
    this.crossover.update();
    this.rsi.update(bar.close);
    this.atr.update(bar.high, bar.low, bar.close);
    const position = ctx.getPosition(bar.tokenId);
    const crossoverValue = this.crossover.get(0);
    const rsiValue = this.rsi.get(0);
    const atrValue = this.atr.get(0);
    if (position && position.size > 0) {
      const buyPrice = this.buyPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId);
      if (buyPrice !== undefined) {
        let stopPrice;
        if (this.params.atr_enabled && atrValue !== undefined && this.params.atr_multiplier > 0) {
          stopPrice = buyPrice - atrValue * this.params.atr_multiplier;
        } else {
          stopPrice = buyPrice * (1 - this.params.stop_loss);
        }
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (this.params.trailing_stop) {
          const currentHighest = highest !== undefined ? Math.max(highest, bar.close) : bar.close;
          this.highestPrice.set(bar.tokenId, currentHighest);
          let trailingStopPrice;
          if (this.params.atr_enabled && atrValue !== undefined) {
            trailingStopPrice = currentHighest - atrValue * this.params.atr_multiplier;
          } else {
            trailingStopPrice = currentHighest * (1 - this.params.stop_loss);
          }
          if (bar.close <= trailingStopPrice && bar.close > buyPrice) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            return;
          }
        }
        if (this.params.take_profit_enabled) {
          const tpPrice = buyPrice * (1 + this.params.take_profit);
          if (bar.close >= tpPrice) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Take profit triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            return;
          }
        }
        let shouldSell = false;
        if (this.params.exit_strategy === 0) {
          if (crossoverValue !== undefined && crossoverValue < 0) {
            shouldSell = true;
          }
        } else if (this.params.exit_strategy === 1) {
          if (this.params.rsi_enabled && rsiValue !== undefined && rsiValue >= this.params.rsi_overbought) {
            shouldSell = true;
          }
        }
        if (shouldSell) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] SELL signal for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}${rsiValue !== undefined ? `, RSI: ${rsiValue.toFixed(2)}` : ""}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else {
      let shouldBuy = false;
      if (crossoverValue !== undefined && crossoverValue > 0) {
        if (this.params.rsi_enabled && rsiValue !== undefined) {
          if (rsiValue <= this.params.rsi_oversold) {
            shouldBuy = true;
          }
        } else {
          shouldBuy = true;
        }
      }
      if (shouldBuy) {
        const feeBuffer = 0.995;
        let cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
        if (this.params.atr_enabled && atrValue !== undefined && this.params.atr_multiplier > 0 && atrValue > 0) {
          const atrRisk = atrValue * this.params.atr_multiplier;
          const maxSizeByATR = ctx.getCapital() * this.params.risk_percent / atrRisk;
          cash = Math.min(cash, maxSizeByATR * bar.close * feeBuffer);
        }
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY signal for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, size: ${size.toFixed(2)}${rsiValue !== undefined ? `, RSI: ${rsiValue.toFixed(2)}` : ""}${atrValue !== undefined ? `, ATR: ${atrValue.toFixed(4)}` : ""}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.buyPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_bollinger_02.ts
import * as fs2 from "fs";
import * as path2 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams2 = {
  period: 10,
  std_dev_multiplier: 2,
  stop_loss: 0.03,
  trailing_stop: true,
  risk_percent: 0.15,
  mean_reversion: true,
  take_profit: 0.05,
  take_profit_enabled: false,
  rsi_period: 14,
  rsi_enabled: false,
  rsi_oversold: 30,
  rsi_overbought: 70,
  breakout_enabled: false,
  breakout_threshold: 0.02
};
function loadSavedParams2() {
  const paramsPath = path2.join(__dirname, "strat_bollinger_02.params.json");
  if (!fs2.existsSync(paramsPath))
    return null;
  try {
    const content = fs2.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    const booleanParams = ["trailing_stop", "mean_reversion", "take_profit_enabled", "rsi_enabled", "breakout_enabled"];
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams2) {
        if (booleanParams.includes(key)) {
          if (typeof value === "number") {
            params[key] = value === 1;
          } else if (typeof value === "boolean") {
            params[key] = value;
          }
        } else if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StandardDeviation {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period) {
      this.prices.shift();
    }
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    const squaredDiffs = this.prices.map((p) => Math.pow(p - mean, 2));
    const variance = squaredDiffs.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(variance);
  }
  getValues() {
    return [...this.prices];
  }
}

class BollingerBandsStrategy {
  params;
  indicators = new Map;
  buyPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams2();
    const mergedParams = { ...defaultParams2, ...savedParams, ...params };
    this.params = {
      period: mergedParams.period,
      std_dev_multiplier: mergedParams.std_dev_multiplier,
      stop_loss: mergedParams.stop_loss,
      trailing_stop: mergedParams.trailing_stop,
      risk_percent: mergedParams.risk_percent,
      mean_reversion: mergedParams.mean_reversion,
      take_profit: mergedParams.take_profit,
      take_profit_enabled: mergedParams.take_profit_enabled,
      rsi_period: mergedParams.rsi_period,
      rsi_enabled: mergedParams.rsi_enabled,
      rsi_oversold: mergedParams.rsi_oversold,
      rsi_overbought: mergedParams.rsi_overbought,
      breakout_enabled: mergedParams.breakout_enabled,
      breakout_threshold: mergedParams.breakout_threshold
    };
  }
  getIndicators(tokenId) {
    let ind = this.indicators.get(tokenId);
    if (!ind) {
      ind = {
        sma: new SimpleMovingAverage(this.params.period),
        stdDev: new StandardDeviation(this.params.period),
        rsi: new RSI(this.params.rsi_period),
        prices: []
      };
      this.indicators.set(tokenId, ind);
    }
    return ind;
  }
  getBollingerBands(tokenId) {
    const ind = this.getIndicators(tokenId);
    const middle = ind.sma.get(0);
    const stdDev = ind.stdDev.get();
    if (middle === undefined || stdDev === undefined) {
      return { middle: undefined, upper: undefined, lower: undefined };
    }
    return {
      middle,
      upper: middle + this.params.std_dev_multiplier * stdDev,
      lower: middle - this.params.std_dev_multiplier * stdDev
    };
  }
  onInit(_ctx) {
    console.log(`BollingerBandsStrategy initialized with params:`);
    console.log(`  Period: ${this.params.period}`);
    console.log(`  Std Dev Multiplier: ${this.params.std_dev_multiplier}`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Trailing stop: ${this.params.trailing_stop}`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
    console.log(`  Mean reversion mode: ${this.params.mean_reversion}`);
    console.log(`  Take profit: ${this.params.take_profit_enabled ? `${this.params.take_profit * 100}%` : "disabled"}`);
    console.log(`  RSI: ${this.params.rsi_enabled ? `period=${this.params.rsi_period}, oversold=${this.params.rsi_oversold}, overbought=${this.params.rsi_overbought}` : "disabled"}`);
    console.log(`  Breakout: ${this.params.breakout_enabled ? `threshold=${this.params.breakout_threshold * 100}%` : "disabled"}`);
  }
  onNext(ctx, bar) {
    const ind = this.getIndicators(bar.tokenId);
    ind.sma.update(bar.close);
    ind.stdDev.update(bar.close);
    ind.rsi.update(bar.close);
    ind.prices.push(bar.close);
    if (ind.prices.length > this.params.period) {
      ind.prices.shift();
    }
    const position = ctx.getPosition(bar.tokenId);
    const bands = this.getBollingerBands(bar.tokenId);
    const rsiValue = ind.rsi.get(0);
    if (position && position.size > 0) {
      const buyPrice = this.buyPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId);
      if (buyPrice !== undefined) {
        const stopPrice = buyPrice * (1 - this.params.stop_loss);
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (this.params.trailing_stop) {
          const currentHighest = highest !== undefined ? Math.max(highest, bar.close) : bar.close;
          this.highestPrice.set(bar.tokenId, currentHighest);
          const trailingStopPrice = currentHighest * (1 - this.params.stop_loss);
          if (bar.close <= trailingStopPrice && bar.close > buyPrice) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            return;
          }
        }
        if (this.params.take_profit_enabled && bands.upper !== undefined) {
          const tpPrice = buyPrice * (1 + this.params.take_profit);
          if (bar.close >= tpPrice || bar.close >= bands.upper) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Take profit triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            return;
          }
        }
        if (bands.upper !== undefined && this.params.mean_reversion) {
          let shouldSell = bar.close >= bands.upper;
          if (this.params.rsi_enabled && rsiValue !== undefined) {
            shouldSell = shouldSell && rsiValue >= this.params.rsi_overbought;
          }
          if (shouldSell) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Bollinger Bands SELL signal (price at upper band) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}${rsiValue !== undefined ? `, RSI: ${rsiValue.toFixed(2)}` : ""}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
          }
        }
      }
    } else {
      let shouldBuy = false;
      let buyReason = "";
      if (this.params.breakout_enabled && bands.upper !== undefined) {
        const breakoutPrice = bands.upper * (1 + this.params.breakout_threshold);
        if (bar.close >= breakoutPrice) {
          shouldBuy = true;
          buyReason = `breakout above upper band`;
        }
      }
      if (!shouldBuy && this.params.mean_reversion && bands.lower !== undefined && bands.upper !== undefined) {
        if (bar.close <= bands.lower) {
          shouldBuy = true;
          buyReason = `price at lower band`;
        }
      }
      if (shouldBuy && this.params.rsi_enabled && rsiValue !== undefined) {
        shouldBuy = rsiValue <= this.params.rsi_oversold;
        if (shouldBuy) {
          buyReason += `, RSI oversold (${rsiValue.toFixed(2)})`;
        }
      }
      if (shouldBuy) {
        const feeBuffer = 0.995;
        let cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY signal (${buyReason}) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, size: ${size.toFixed(2)}`);
          console.log(`  Bands - Lower: ${bands.lower?.toFixed(4)}, Middle: ${bands.middle?.toFixed(4)}, Upper: ${bands.upper?.toFixed(4)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.buyPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_rsi_03.ts
import * as fs3 from "fs";
import * as path3 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams3 = {
  rsi_period: 5,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams3() {
  const paramsPath = path3.join(__dirname, "strat_rsi_03.params.json");
  if (!fs3.existsSync(paramsPath))
    return null;
  try {
    const content = fs3.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams3) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RSIMeanReversionStrategy {
  params;
  rsiMap = new Map;
  buyPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams3();
    const mergedParams = { ...defaultParams3, ...savedParams, ...params };
    this.params = {
      rsi_period: mergedParams.rsi_period,
      rsi_oversold: mergedParams.rsi_oversold,
      rsi_overbought: mergedParams.rsi_overbought,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent
    };
  }
  getRsi(tokenId) {
    let rsi = this.rsiMap.get(tokenId);
    if (!rsi) {
      rsi = new RSI(this.params.rsi_period);
      this.rsiMap.set(tokenId, rsi);
    }
    return rsi;
  }
  onInit(_ctx) {
    console.log(`RSI Mean Reversion Strategy initialized with params:`);
    console.log(`  RSI period: ${this.params.rsi_period}`);
    console.log(`  Oversold: ${this.params.rsi_oversold}`);
    console.log(`  Overbought: ${this.params.rsi_overbought}`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
  }
  onNext(ctx, bar) {
    const rsi = this.getRsi(bar.tokenId);
    rsi.update(bar.close);
    const position = ctx.getPosition(bar.tokenId);
    const rsiValue = rsi.get(0);
    if (position && position.size > 0) {
      const buyPrice = this.buyPrice.get(bar.tokenId);
      if (buyPrice !== undefined) {
        const stopPrice = buyPrice * (1 - this.params.stop_loss);
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          return;
        }
        if (rsiValue !== undefined && rsiValue >= this.params.rsi_overbought) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] RSI overbought SELL for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, RSI: ${rsiValue.toFixed(2)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
        }
      }
    } else {
      if (rsiValue !== undefined && rsiValue <= this.params.rsi_oversold) {
        const feeBuffer = 0.995;
        const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] RSI oversold BUY for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, RSI: ${rsiValue.toFixed(2)}, size: ${size.toFixed(2)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.buyPrice.set(bar.tokenId, bar.close);
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_atr_breakout_04.ts
import * as fs4 from "fs";
import * as path4 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams4 = {
  breakout_multiplier: 0.5,
  lookback: 10,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams4() {
  const paramsPath = path4.join(__dirname, "strat_atr_breakout_04.params.json");
  if (!fs4.existsSync(paramsPath))
    return null;
  try {
    const content = fs4.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams4) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ATRBreakoutStrategy {
  params;
  priceHistory = new Map;
  buyPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams4();
    const mergedParams = { ...defaultParams4, ...savedParams, ...params };
    this.params = {
      breakout_multiplier: mergedParams.breakout_multiplier,
      lookback: mergedParams.lookback,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent
    };
  }
  onInit(_ctx) {
    console.log(`ATR Breakout Strategy initialized with params:`);
    console.log(`  Breakout multiplier: ${this.params.breakout_multiplier}`);
    console.log(`  Lookback: ${this.params.lookback}`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
  }
  onNext(ctx, bar) {
    let history = this.priceHistory.get(bar.tokenId);
    if (!history) {
      history = [];
      this.priceHistory.set(bar.tokenId, history);
    }
    history.push(bar.close);
    if (history.length > this.params.lookback) {
      history.shift();
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const buyPrice = this.buyPrice.get(bar.tokenId);
      if (buyPrice !== undefined) {
        const stopPrice = buyPrice * (1 - this.params.stop_loss);
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          return;
        }
        if (history.length >= this.params.lookback) {
          const recentHigh = Math.max(...history);
          const recentLow = Math.min(...history);
          const priceRange = recentHigh - recentLow;
          if (priceRange > 0 && bar.close < recentHigh - priceRange * this.params.breakout_multiplier) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop SELL for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
          }
        }
      }
    } else {
      if (history.length >= this.params.lookback) {
        const lookbackPrices = history.slice(0, -1);
        const recentHigh = Math.max(...lookbackPrices);
        const recentLow = Math.min(...lookbackPrices);
        const priceRange = recentHigh - recentLow;
        if (priceRange > 0) {
          const breakoutLevel = recentHigh + priceRange * this.params.breakout_multiplier;
          if (bar.close > breakoutLevel) {
            const feeBuffer = 0.995;
            const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
            const size = cash / bar.close;
            if (size > 0 && cash <= ctx.getCapital()) {
              console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Breakout BUY for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, breakout: ${breakoutLevel.toFixed(4)}, range: ${priceRange.toFixed(4)}, size: ${size.toFixed(2)}`);
              const result = ctx.buy(bar.tokenId, size);
              if (result.success) {
                this.buyPrice.set(bar.tokenId, bar.close);
              } else {
                console.error(`  Order failed: ${result.error}`);
              }
            }
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_ma_atr_05.ts
import * as fs5 from "fs";
import * as path5 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams5 = {
  fast_period: 5,
  slow_period: 15,
  volatility_period: 20,
  vol_multiplier: 2,
  risk_percent: 0.1
};
function loadSavedParams5() {
  const paramsPath = path5.join(__dirname, "strat_ma_atr_05.params.json");
  if (!fs5.existsSync(paramsPath))
    return null;
  try {
    const content = fs5.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams5) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const sqDiffs = values.reduce((sum, v) => sum + (v - mean) * (v - mean), 0);
  return Math.sqrt(sqDiffs / values.length);
}

class MAStrategyWithATRStop {
  params;
  fastMAs = new Map;
  slowMAs = new Map;
  crossovers = new Map;
  priceBuffers = new Map;
  buyPrice = new Map;
  buyVolatility = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams5();
    const mergedParams = { ...defaultParams5, ...savedParams, ...params };
    this.params = {
      fast_period: mergedParams.fast_period,
      slow_period: mergedParams.slow_period,
      volatility_period: mergedParams.volatility_period,
      vol_multiplier: mergedParams.vol_multiplier,
      risk_percent: mergedParams.risk_percent
    };
  }
  getIndicators(tokenId) {
    let fastMA = this.fastMAs.get(tokenId);
    let slowMA = this.slowMAs.get(tokenId);
    let crossover = this.crossovers.get(tokenId);
    if (!fastMA || !slowMA || !crossover) {
      fastMA = new SimpleMovingAverage(this.params.fast_period);
      slowMA = new SimpleMovingAverage(this.params.slow_period);
      crossover = new CrossOver(fastMA, slowMA);
      this.fastMAs.set(tokenId, fastMA);
      this.slowMAs.set(tokenId, slowMA);
      this.crossovers.set(tokenId, crossover);
    }
    return { fastMA, slowMA, crossover };
  }
  updatePriceBuffer(tokenId, price) {
    let buffer = this.priceBuffers.get(tokenId);
    if (!buffer) {
      buffer = [];
      this.priceBuffers.set(tokenId, buffer);
    }
    buffer.push(price);
    if (buffer.length > this.params.volatility_period) {
      buffer.shift();
    }
    return buffer;
  }
  onInit(_ctx) {
    console.log(`MA + Volatility Stop Strategy initialized with params:`);
    console.log(`  Fast MA period: ${this.params.fast_period}`);
    console.log(`  Slow MA period: ${this.params.slow_period}`);
    console.log(`  Volatility period: ${this.params.volatility_period}`);
    console.log(`  Volatility multiplier: ${this.params.vol_multiplier}`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
  }
  onNext(ctx, bar) {
    const { fastMA, slowMA, crossover } = this.getIndicators(bar.tokenId);
    fastMA.update(bar.close);
    slowMA.update(bar.close);
    crossover.update();
    const priceBuffer = this.updatePriceBuffer(bar.tokenId, bar.close);
    const currentVol = stddev(priceBuffer);
    const position = ctx.getPosition(bar.tokenId);
    const crossoverValue = crossover.get(0);
    if (position && position.size > 0) {
      const entryPrice = this.buyPrice.get(bar.tokenId);
      const entryVol = this.buyVolatility.get(bar.tokenId);
      if (entryPrice !== undefined && entryVol !== undefined) {
        const effectiveVol = Math.max(entryVol, currentVol);
        const stopDistance = effectiveVol > 0.000000001 ? effectiveVol * this.params.vol_multiplier : entryPrice * 0.02;
        const stopPrice = entryPrice - stopDistance;
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Volatility stop triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)} (stop: ${stopPrice.toFixed(4)})`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.buyVolatility.delete(bar.tokenId);
          return;
        }
        if (crossoverValue !== undefined && crossoverValue < 0) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] MA crossover SELL signal for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.buyVolatility.delete(bar.tokenId);
        }
      }
    } else {
      if (crossoverValue !== undefined && crossoverValue > 0) {
        const feeBuffer = 0.995;
        const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] MA crossover BUY signal for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, size: ${size.toFixed(2)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.buyPrice.set(bar.tokenId, bar.close);
            this.buyVolatility.set(bar.tokenId, currentVol);
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_support_06.ts
import * as fs6 from "fs";
import * as path6 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams6 = {
  lookback: 10,
  bounce_threshold: 0.05,
  stop_loss: 0.05,
  risk_percent: 0.1,
  take_profit: 0.1
};
function loadSavedParams6() {
  const paramsPath = path6.join(__dirname, "strat_support_06.params.json");
  if (!fs6.existsSync(paramsPath))
    return null;
  try {
    const content = fs6.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams6) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SupportResistanceStrategy {
  params;
  lows = new Map;
  highs = new Map;
  prevClose = new Map;
  buyPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams6();
    const mergedParams = { ...defaultParams6, ...savedParams, ...params };
    this.params = {
      lookback: mergedParams.lookback,
      bounce_threshold: mergedParams.bounce_threshold,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent,
      take_profit: mergedParams.take_profit
    };
  }
  onInit(_ctx) {
    console.log(`Support/Resistance Strategy initialized with params:`);
    console.log(`  Lookback: ${this.params.lookback}`);
    console.log(`  Bounce threshold: ${this.params.bounce_threshold * 100}%`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Take profit: ${this.params.take_profit * 100}%`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
  }
  onNext(ctx, bar) {
    let tokenLows = this.lows.get(bar.tokenId) || [];
    let tokenHighs = this.highs.get(bar.tokenId) || [];
    tokenLows.push(bar.low);
    tokenHighs.push(bar.high);
    if (tokenLows.length > this.params.lookback) {
      tokenLows.shift();
      tokenHighs.shift();
    }
    this.lows.set(bar.tokenId, tokenLows);
    this.highs.set(bar.tokenId, tokenHighs);
    const position = ctx.getPosition(bar.tokenId);
    const prev = this.prevClose.get(bar.tokenId);
    this.prevClose.set(bar.tokenId, bar.close);
    if (position && position.size > 0) {
      const buyPrice = this.buyPrice.get(bar.tokenId);
      if (buyPrice !== undefined) {
        const stopPrice = buyPrice * (1 - this.params.stop_loss);
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          return;
        }
        const targetPrice = buyPrice * (1 + this.params.take_profit);
        if (bar.close >= targetPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Take profit for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          return;
        }
        if (tokenHighs.length >= this.params.lookback) {
          const resistance = Math.max(...tokenHighs);
          if (bar.close >= resistance * (1 - this.params.bounce_threshold)) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Resistance SELL for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.buyPrice.delete(bar.tokenId);
          }
        }
      }
    } else {
      if (bar.close > 0.8 || bar.close < 0.05) {
        return;
      }
      if (tokenLows.length >= this.params.lookback && prev !== undefined) {
        const support = Math.min(...tokenLows);
        const bounceLevel = support * (1 + this.params.bounce_threshold);
        if (bar.close <= bounceLevel && bar.close > prev) {
          const feeBuffer = 0.995;
          const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
          const size = cash / bar.close;
          if (size > 0 && cash <= ctx.getCapital()) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Support bounce BUY for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, support: ${support.toFixed(4)}, size: ${size.toFixed(2)}`);
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.buyPrice.set(bar.tokenId, bar.close);
            } else {
              console.error(`  Order failed: ${result.error}`);
            }
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_momentum_07.ts
import * as fs7 from "fs";
import * as path7 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams7 = {
  lookback: 3,
  entry_threshold: 0.05,
  trailing_stop_pct: 0.05,
  minimum_hold: 3,
  risk_percent: 0.1
};
function loadSavedParams7() {
  const paramsPath = path7.join(__dirname, "strat_momentum_07.params.json");
  if (!fs7.existsSync(paramsPath))
    return null;
  try {
    const content = fs7.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams7) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ShortTermStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestSinceEntry = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams7();
    const mergedParams = { ...defaultParams7, ...savedParams, ...params };
    this.params = {
      lookback: Math.max(2, Math.floor(mergedParams.lookback)),
      entry_threshold: mergedParams.entry_threshold,
      trailing_stop_pct: mergedParams.trailing_stop_pct,
      minimum_hold: Math.max(0, Math.floor(mergedParams.minimum_hold)),
      risk_percent: mergedParams.risk_percent
    };
  }
  onInit(_ctx) {
    console.log(`ShortTermStrategy initialized:`);
    console.log(`  Lookback: ${this.params.lookback} bars`);
    console.log(`  Entry threshold: ${(this.params.entry_threshold * 100).toFixed(1)}%`);
    console.log(`  Trailing stop: ${(this.params.trailing_stop_pct * 100).toFixed(1)}%`);
    console.log(`  Minimum hold: ${this.params.minimum_hold} bars`);
    console.log(`  Risk percent: ${(this.params.risk_percent * 100).toFixed(1)}%`);
  }
  getPriceChange(tokenId) {
    const history = this.priceHistory.get(tokenId);
    if (!history || history.length < this.params.lookback + 1) {
      return;
    }
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.lookback];
    if (past <= 0)
      return;
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxHistory = this.params.lookback + 5;
    if (history.length > maxHistory) {
      history.shift();
    }
    const priceChange = this.getPriceChange(bar.tokenId);
    if (priceChange === undefined) {
      return;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        const prevHighest = this.highestSinceEntry.get(bar.tokenId) ?? entry;
        const highest = Math.max(prevHighest, bar.close);
        this.highestSinceEntry.set(bar.tokenId, highest);
        const held = (this.barsHeld.get(bar.tokenId) ?? 0) + 1;
        this.barsHeld.set(bar.tokenId, held);
        if (held >= this.params.minimum_hold) {
          const drawdownFromHighest = (highest - bar.close) / highest;
          if (drawdownFromHighest >= this.params.trailing_stop_pct) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] TRAILING STOP ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)} highest=${highest.toFixed(4)} drawdown=${(drawdownFromHighest * 100).toFixed(1)}%`);
            ctx.close(bar.tokenId);
            this.entryPrice.delete(bar.tokenId);
            this.highestSinceEntry.delete(bar.tokenId);
            this.barsHeld.delete(bar.tokenId);
            return;
          }
        }
      }
    } else {
      if (priceChange >= this.params.entry_threshold) {
        if (bar.close > 0.1 && bar.close < 0.9) {
          const cash = ctx.getCapital() * this.params.risk_percent;
          const size = cash / bar.close;
          if (size > 0 && cash <= ctx.getCapital()) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY ${bar.tokenId.slice(0, 8)}... change=${(priceChange * 100).toFixed(1)}% price=${bar.close.toFixed(4)}`);
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.entryPrice.set(bar.tokenId, bar.close);
              this.highestSinceEntry.set(bar.tokenId, bar.close);
              this.barsHeld.set(bar.tokenId, 0);
            }
          }
        }
      }
    }
  }
  onComplete(_ctx) {
    console.log(`
Strategy completed.`);
  }
}

// src/strategies/strat_range_08.ts
import * as fs8 from "fs";
import * as path8 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams8 = {
  buy_below: 0.3,
  sell_above: 0.6,
  stop_loss: 0.15,
  risk_percent: 0.1
};
function loadSavedParams8() {
  const paramsPath = path8.join(__dirname, "strat_range_08.params.json");
  if (!fs8.existsSync(paramsPath))
    return null;
  try {
    const content = fs8.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams8) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RangeTradingStrategy {
  params;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams8();
    const mergedParams = { ...defaultParams8, ...savedParams, ...params };
    let buyBelow = mergedParams.buy_below;
    let sellAbove = mergedParams.sell_above;
    if (buyBelow >= sellAbove) {
      [buyBelow, sellAbove] = [sellAbove, buyBelow];
    }
    this.params = {
      buy_below: buyBelow,
      sell_above: sellAbove,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent
    };
  }
  onInit(_ctx) {
    console.log(`RangeTradingStrategy initialized:`);
    console.log(`  Buy below: ${(this.params.buy_below * 100).toFixed(0)}%`);
    console.log(`  Sell above: ${(this.params.sell_above * 100).toFixed(0)}%`);
    console.log(`  Stop loss: ${(this.params.stop_loss * 100).toFixed(1)}%`);
    console.log(`  Risk percent: ${(this.params.risk_percent * 100).toFixed(1)}%`);
  }
  onNext(ctx, bar) {
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] STOP LOSS ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= this.params.sell_above) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] TAKE PROFIT ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
      }
    } else {
      if (bar.close <= this.params.buy_below && bar.close > 0.02) {
        const cash = ctx.getCapital() * this.params.risk_percent;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {
    console.log(`
Strategy completed.`);
  }
}

// src/strategies/strat_mean_revert_09.ts
import * as fs9 from "fs";
import * as path9 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams9 = {
  ma_period: 8,
  deviation_threshold: 0.03,
  stop_loss: 0.08,
  risk_percent: 0.1
};
function loadSavedParams9() {
  const paramsPath = path9.join(__dirname, "strat_mean_revert_09.params.json");
  if (!fs9.existsSync(paramsPath))
    return null;
  try {
    const content = fs9.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams9) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MeanReversionStrategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams9();
    const mergedParams = { ...defaultParams9, ...savedParams, ...params };
    this.params = {
      ma_period: Math.max(2, Math.floor(mergedParams.ma_period)),
      deviation_threshold: mergedParams.deviation_threshold,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent
    };
  }
  onInit(_ctx) {
    console.log(`MeanReversionStrategy initialized:`);
    console.log(`  MA period: ${this.params.ma_period}`);
    console.log(`  Deviation threshold: ${(this.params.deviation_threshold * 100).toFixed(1)}%`);
    console.log(`  Stop loss: ${(this.params.stop_loss * 100).toFixed(1)}%`);
    console.log(`  Risk percent: ${(this.params.risk_percent * 100).toFixed(1)}%`);
  }
  getSMA(tokenId) {
    let sma = this.smaMap.get(tokenId);
    if (!sma) {
      sma = new SimpleMovingAverage(this.params.ma_period);
      this.smaMap.set(tokenId, sma);
    }
    return sma;
  }
  onNext(ctx, bar) {
    const sma = this.getSMA(bar.tokenId);
    sma.update(bar.close);
    const maValue = sma.get(0);
    if (maValue === undefined) {
      return;
    }
    const price = bar.close;
    const deviation = maValue - price;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (price < entry * (1 - this.params.stop_loss)) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] STOP LOSS ${bar.tokenId.slice(0, 8)}... price=${price.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (price >= maValue) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] MEAN REVERT EXIT ${bar.tokenId.slice(0, 8)}... price=${price.toFixed(4)} ma=${maValue.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
      }
    } else {
      if (deviation >= this.params.deviation_threshold) {
        if (price >= 0.05 && price <= 0.9) {
          const cash = ctx.getCapital() * this.params.risk_percent;
          const size = cash / price;
          if (size > 0 && cash <= ctx.getCapital()) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY ${bar.tokenId.slice(0, 8)}... price=${price.toFixed(4)} ma=${maValue.toFixed(4)} dev=${(deviation * 100).toFixed(1)}%`);
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.entryPrice.set(bar.tokenId, price);
            }
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_dual_ma_10.ts
import * as fs10 from "fs";
import * as path10 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams10 = {
  fast_period: 5,
  slow_period: 12,
  trend_period: 25,
  stop_loss: 0.05,
  trailing_stop_pct: 0.03,
  risk_percent: 0.1
};
function loadSavedParams10() {
  const paramsPath = path10.join(__dirname, "strat_dual_ma_10.params.json");
  if (!fs10.existsSync(paramsPath))
    return null;
  try {
    const content = fs10.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams10) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class DualMAStrategy {
  params;
  fastMAs = new Map;
  slowMAs = new Map;
  trendMAs = new Map;
  crossovers = new Map;
  buyPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams10();
    const mergedParams = { ...defaultParams10, ...savedParams, ...params };
    let fast = mergedParams.fast_period;
    let slow = mergedParams.slow_period;
    let trend = mergedParams.trend_period;
    const sorted = [fast, slow, trend].sort((a, b) => a - b);
    fast = sorted[0];
    slow = sorted[1];
    trend = sorted[2];
    this.params = {
      fast_period: fast,
      slow_period: slow,
      trend_period: trend,
      stop_loss: mergedParams.stop_loss,
      trailing_stop_pct: mergedParams.trailing_stop_pct,
      risk_percent: mergedParams.risk_percent
    };
  }
  getIndicators(tokenId) {
    if (!this.fastMAs.has(tokenId)) {
      const fastMA = new SimpleMovingAverage(this.params.fast_period);
      const slowMA = new SimpleMovingAverage(this.params.slow_period);
      const trendMA = new SimpleMovingAverage(this.params.trend_period);
      const crossover = new CrossOver(fastMA, slowMA);
      this.fastMAs.set(tokenId, fastMA);
      this.slowMAs.set(tokenId, slowMA);
      this.trendMAs.set(tokenId, trendMA);
      this.crossovers.set(tokenId, crossover);
    }
    return {
      fastMA: this.fastMAs.get(tokenId),
      slowMA: this.slowMAs.get(tokenId),
      trendMA: this.trendMAs.get(tokenId),
      crossover: this.crossovers.get(tokenId)
    };
  }
  onInit(_ctx) {
    console.log(`DualMAStrategy initialized with params:`);
    console.log(`  Fast MA period: ${this.params.fast_period}`);
    console.log(`  Slow MA period: ${this.params.slow_period}`);
    console.log(`  Trend MA period: ${this.params.trend_period}`);
    console.log(`  Stop loss: ${(this.params.stop_loss * 100).toFixed(1)}%`);
    console.log(`  Trailing stop: ${(this.params.trailing_stop_pct * 100).toFixed(1)}%`);
    console.log(`  Risk percent: ${(this.params.risk_percent * 100).toFixed(1)}%`);
  }
  onNext(ctx, bar) {
    const { fastMA, slowMA, trendMA, crossover } = this.getIndicators(bar.tokenId);
    fastMA.update(bar.close);
    slowMA.update(bar.close);
    trendMA.update(bar.close);
    crossover.update();
    const crossoverValue = crossover.get(0);
    const trendValue = trendMA.get(0);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.buyPrice.get(bar.tokenId);
      if (entry !== undefined) {
        const stopPrice = entry * (1 - this.params.stop_loss);
        if (bar.close <= stopPrice) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] STOP LOSS ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)} entry=${entry.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const prevHighest = this.highestPrice.get(bar.tokenId) ?? entry;
        const highest = Math.max(prevHighest, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        const drawdown = (highest - bar.close) / highest;
        if (drawdown >= this.params.trailing_stop_pct && bar.close > entry) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] TRAILING STOP ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)} highest=${highest.toFixed(4)} drawdown=${(drawdown * 100).toFixed(1)}%`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (crossoverValue !== undefined && crossoverValue < 0) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] SELL crossover ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.buyPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
      }
      return;
    }
    if (bar.close < 0.05 || bar.close > 0.95) {
      return;
    }
    if (crossoverValue !== undefined && crossoverValue > 0) {
      if (trendValue !== undefined && bar.close > trendValue) {
        const feeBuffer = 0.995;
        const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY ${bar.tokenId.slice(0, 8)}... price=${bar.close.toFixed(4)} trendMA=${trendValue.toFixed(4)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.buyPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_ema_fast_11.ts
import * as fs11 from "fs";
import * as path11 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams11 = {
  fast_period: 3,
  slow_period: 8,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams11() {
  const paramsPath = path11.join(__dirname, "strat_ema_fast_11.params.json");
  if (!fs11.existsSync(paramsPath))
    return null;
  try {
    const content = fs11.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams11) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ExponentialMA {
  period;
  multiplier;
  value;
  values = [];
  constructor(period) {
    this.period = period;
    this.multiplier = 2 / (period + 1);
  }
  update(price) {
    if (this.value === undefined) {
      this.values.push(price);
      if (this.values.length >= this.period) {
        this.value = this.values.reduce((a, b) => a + b, 0) / this.period;
      }
    } else {
      this.value = (price - this.value) * this.multiplier + this.value;
    }
  }
  get() {
    return this.value;
  }
}

class EMAFastCrossStrategy {
  params;
  fastEMAs = new Map;
  slowEMAs = new Map;
  prevDiff = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams11();
    const mergedParams = { ...defaultParams11, ...savedParams, ...params };
    let fast = Math.max(2, Math.floor(mergedParams.fast_period));
    let slow = Math.max(3, Math.floor(mergedParams.slow_period));
    if (fast >= slow)
      [fast, slow] = [slow, fast];
    this.params = { ...mergedParams, fast_period: fast, slow_period: slow };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastEMAs.has(bar.tokenId)) {
      this.fastEMAs.set(bar.tokenId, new ExponentialMA(this.params.fast_period));
      this.slowEMAs.set(bar.tokenId, new ExponentialMA(this.params.slow_period));
    }
    const fastEMA = this.fastEMAs.get(bar.tokenId);
    const slowEMA = this.slowEMAs.get(bar.tokenId);
    fastEMA.update(bar.close);
    slowEMA.update(bar.close);
    const fastVal = fastEMA.get();
    const slowVal = slowEMA.get();
    if (fastVal === undefined || slowVal === undefined)
      return;
    const diff = fastVal - slowVal;
    const prev = this.prevDiff.get(bar.tokenId);
    this.prevDiff.set(bar.tokenId, diff);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry !== undefined) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (prev !== undefined && prev >= 0 && diff < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (prev !== undefined && prev <= 0 && diff > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ema_med_12.ts
import * as fs12 from "fs";
import * as path12 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams12 = {
  fast_period: 5,
  slow_period: 15,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.15
};
function loadSavedParams12() {
  const paramsPath = path12.join(__dirname, "strat_ema_med_12.params.json");
  if (!fs12.existsSync(paramsPath))
    return null;
  try {
    const content = fs12.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams12) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ExponentialMA2 {
  period;
  multiplier;
  value;
  values = [];
  constructor(period) {
    this.period = period;
    this.multiplier = 2 / (period + 1);
  }
  update(price) {
    if (this.value === undefined) {
      this.values.push(price);
      if (this.values.length >= this.period) {
        this.value = this.values.reduce((a, b) => a + b, 0) / this.period;
      }
    } else {
      this.value = (price - this.value) * this.multiplier + this.value;
    }
  }
  get() {
    return this.value;
  }
}

class EMAMedCrossStrategy {
  params;
  fastEMAs = new Map;
  slowEMAs = new Map;
  prevDiff = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams12();
    const mergedParams = { ...defaultParams12, ...savedParams, ...params };
    let fast = Math.max(2, Math.floor(mergedParams.fast_period));
    let slow = Math.max(3, Math.floor(mergedParams.slow_period));
    if (fast >= slow)
      [fast, slow] = [slow, fast];
    this.params = { ...mergedParams, fast_period: fast, slow_period: slow };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastEMAs.has(bar.tokenId)) {
      this.fastEMAs.set(bar.tokenId, new ExponentialMA2(this.params.fast_period));
      this.slowEMAs.set(bar.tokenId, new ExponentialMA2(this.params.slow_period));
    }
    const fastEMA = this.fastEMAs.get(bar.tokenId);
    const slowEMA = this.slowEMAs.get(bar.tokenId);
    fastEMA.update(bar.close);
    slowEMA.update(bar.close);
    const fastVal = fastEMA.get();
    const slowVal = slowEMA.get();
    if (fastVal === undefined || slowVal === undefined)
      return;
    const diff = fastVal - slowVal;
    const prev = this.prevDiff.get(bar.tokenId);
    this.prevDiff.set(bar.tokenId, diff);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry !== undefined) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (prev !== undefined && prev >= 0 && diff < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (prev !== undefined && prev <= 0 && diff > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ema_slow_13.ts
import * as fs13 from "fs";
import * as path13 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams13 = {
  fast_period: 8,
  slow_period: 20,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  risk_percent: 0.12
};
function loadSavedParams13() {
  const paramsPath = path13.join(__dirname, "strat_ema_slow_13.params.json");
  if (!fs13.existsSync(paramsPath))
    return null;
  try {
    const content = fs13.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams13) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ExponentialMA3 {
  period;
  multiplier;
  value;
  values = [];
  constructor(period) {
    this.period = period;
    this.multiplier = 2 / (period + 1);
  }
  update(price) {
    if (this.value === undefined) {
      this.values.push(price);
      if (this.values.length >= this.period) {
        this.value = this.values.reduce((a, b) => a + b, 0) / this.period;
      }
    } else {
      this.value = (price - this.value) * this.multiplier + this.value;
    }
  }
  get() {
    return this.value;
  }
}

class EMASlowCrossStrategy {
  params;
  fastEMAs = new Map;
  slowEMAs = new Map;
  prevDiff = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams13();
    const mergedParams = { ...defaultParams13, ...savedParams, ...params };
    let fast = Math.max(2, Math.floor(mergedParams.fast_period));
    let slow = Math.max(3, Math.floor(mergedParams.slow_period));
    if (fast >= slow)
      [fast, slow] = [slow, fast];
    this.params = { ...mergedParams, fast_period: fast, slow_period: slow };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastEMAs.has(bar.tokenId)) {
      this.fastEMAs.set(bar.tokenId, new ExponentialMA3(this.params.fast_period));
      this.slowEMAs.set(bar.tokenId, new ExponentialMA3(this.params.slow_period));
    }
    const fastEMA = this.fastEMAs.get(bar.tokenId);
    const slowEMA = this.slowEMAs.get(bar.tokenId);
    fastEMA.update(bar.close);
    slowEMA.update(bar.close);
    const fastVal = fastEMA.get();
    const slowVal = slowEMA.get();
    if (fastVal === undefined || slowVal === undefined)
      return;
    const diff = fastVal - slowVal;
    const prev = this.prevDiff.get(bar.tokenId);
    this.prevDiff.set(bar.tokenId, diff);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry !== undefined) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (prev !== undefined && prev >= 0 && diff < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (prev !== undefined && prev <= 0 && diff > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ema_tight_14.ts
import * as fs14 from "fs";
import * as path14 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams14 = {
  fast_period: 4,
  slow_period: 10,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.08
};
function loadSavedParams14() {
  const paramsPath = path14.join(__dirname, "strat_ema_tight_14.params.json");
  if (!fs14.existsSync(paramsPath))
    return null;
  try {
    const content = fs14.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams14) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ExponentialMA4 {
  period;
  multiplier;
  value;
  values = [];
  constructor(period) {
    this.period = period;
    this.multiplier = 2 / (period + 1);
  }
  update(price) {
    if (this.value === undefined) {
      this.values.push(price);
      if (this.values.length >= this.period) {
        this.value = this.values.reduce((a, b) => a + b, 0) / this.period;
      }
    } else {
      this.value = (price - this.value) * this.multiplier + this.value;
    }
  }
  get() {
    return this.value;
  }
}

class EMATightStopStrategy {
  params;
  fastEMAs = new Map;
  slowEMAs = new Map;
  prevDiff = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams14();
    const mergedParams = { ...defaultParams14, ...savedParams, ...params };
    let fast = Math.max(2, Math.floor(mergedParams.fast_period));
    let slow = Math.max(3, Math.floor(mergedParams.slow_period));
    if (fast >= slow)
      [fast, slow] = [slow, fast];
    this.params = { ...mergedParams, fast_period: fast, slow_period: slow };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastEMAs.has(bar.tokenId)) {
      this.fastEMAs.set(bar.tokenId, new ExponentialMA4(this.params.fast_period));
      this.slowEMAs.set(bar.tokenId, new ExponentialMA4(this.params.slow_period));
    }
    const fastEMA = this.fastEMAs.get(bar.tokenId);
    const slowEMA = this.slowEMAs.get(bar.tokenId);
    fastEMA.update(bar.close);
    slowEMA.update(bar.close);
    const fastVal = fastEMA.get();
    const slowVal = slowEMA.get();
    if (fastVal === undefined || slowVal === undefined)
      return;
    const diff = fastVal - slowVal;
    const prev = this.prevDiff.get(bar.tokenId);
    this.prevDiff.set(bar.tokenId, diff);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry !== undefined) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (prev !== undefined && prev >= 0 && diff < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (prev !== undefined && prev <= 0 && diff > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ema_wide_15.ts
import * as fs15 from "fs";
import * as path15 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams15 = {
  fast_period: 5,
  slow_period: 12,
  stop_loss: 0.1,
  trailing_stop: 0.08,
  risk_percent: 0.2
};
function loadSavedParams15() {
  const paramsPath = path15.join(__dirname, "strat_ema_wide_15.params.json");
  if (!fs15.existsSync(paramsPath))
    return null;
  try {
    const content = fs15.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams15) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ExponentialMA5 {
  period;
  multiplier;
  value;
  values = [];
  constructor(period) {
    this.period = period;
    this.multiplier = 2 / (period + 1);
  }
  update(price) {
    if (this.value === undefined) {
      this.values.push(price);
      if (this.values.length >= this.period) {
        this.value = this.values.reduce((a, b) => a + b, 0) / this.period;
      }
    } else {
      this.value = (price - this.value) * this.multiplier + this.value;
    }
  }
  get() {
    return this.value;
  }
}

class EMAWideStopStrategy {
  params;
  fastEMAs = new Map;
  slowEMAs = new Map;
  prevDiff = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams15();
    const mergedParams = { ...defaultParams15, ...savedParams, ...params };
    let fast = Math.max(2, Math.floor(mergedParams.fast_period));
    let slow = Math.max(3, Math.floor(mergedParams.slow_period));
    if (fast >= slow)
      [fast, slow] = [slow, fast];
    this.params = { ...mergedParams, fast_period: fast, slow_period: slow };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastEMAs.has(bar.tokenId)) {
      this.fastEMAs.set(bar.tokenId, new ExponentialMA5(this.params.fast_period));
      this.slowEMAs.set(bar.tokenId, new ExponentialMA5(this.params.slow_period));
    }
    const fastEMA = this.fastEMAs.get(bar.tokenId);
    const slowEMA = this.slowEMAs.get(bar.tokenId);
    fastEMA.update(bar.close);
    slowEMA.update(bar.close);
    const fastVal = fastEMA.get();
    const slowVal = slowEMA.get();
    if (fastVal === undefined || slowVal === undefined)
      return;
    const diff = fastVal - slowVal;
    const prev = this.prevDiff.get(bar.tokenId);
    this.prevDiff.set(bar.tokenId, diff);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry !== undefined) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (prev !== undefined && prev >= 0 && diff < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (prev !== undefined && prev <= 0 && diff > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_roc_fast_16.ts
import * as fs16 from "fs";
import * as path16 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams16 = {
  lookback: 3,
  entry_threshold: 0.03,
  exit_threshold: 0.02,
  min_hold: 2,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams16() {
  const paramsPath = path16.join(__dirname, "strat_roc_fast_16.params.json");
  if (!fs16.existsSync(paramsPath))
    return null;
  try {
    const content = fs16.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams16) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ROCFastStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams16();
    this.params = { ...defaultParams16, ...savedParams, ...params };
    this.params.lookback = Math.max(2, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.lookback + 2)
      history.shift();
    if (history.length <= this.params.lookback)
      return;
    const roc = (bar.close - history[history.length - 1 - this.params.lookback]) / history[history.length - 1 - this.params.lookback];
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const held = (this.barsHeld.get(bar.tokenId) ?? 0) + 1;
      this.barsHeld.set(bar.tokenId, held);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.barsHeld.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (held >= this.params.min_hold && roc < -this.params.exit_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.barsHeld.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (roc >= this.params.entry_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_roc_slow_17.ts
import * as fs17 from "fs";
import * as path17 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams17 = {
  lookback: 8,
  entry_threshold: 0.05,
  exit_threshold: 0.03,
  min_hold: 3,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams17() {
  const paramsPath = path17.join(__dirname, "strat_roc_slow_17.params.json");
  if (!fs17.existsSync(paramsPath))
    return null;
  try {
    const content = fs17.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams17) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ROCSlowStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams17();
    this.params = { ...defaultParams17, ...savedParams, ...params };
    this.params.lookback = Math.max(2, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.lookback + 2)
      history.shift();
    if (history.length <= this.params.lookback)
      return;
    const roc = (bar.close - history[history.length - 1 - this.params.lookback]) / history[history.length - 1 - this.params.lookback];
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const held = (this.barsHeld.get(bar.tokenId) ?? 0) + 1;
      this.barsHeld.set(bar.tokenId, held);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.barsHeld.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (held >= this.params.min_hold && roc < -this.params.exit_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.barsHeld.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (roc >= this.params.entry_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_donchian_short_18.ts
import * as fs18 from "fs";
import * as path18 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams18 = {
  channel_period: 8,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  exit_at_mid: 0,
  risk_percent: 0.1
};
function loadSavedParams18() {
  const paramsPath = path18.join(__dirname, "strat_donchian_short_18.params.json");
  if (!fs18.existsSync(paramsPath))
    return null;
  try {
    const content = fs18.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams18) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class DonchianShortStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams18();
    this.params = { ...defaultParams18, ...savedParams, ...params };
    this.params.channel_period = Math.max(3, Math.floor(this.params.channel_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.channel_period + 1)
      history.shift();
    if (history.length < this.params.channel_period)
      return;
    const lookback = history.slice(0, -1);
    const channelHigh = Math.max(...lookback);
    const channelLow = Math.min(...lookback);
    const channelMid = (channelHigh + channelLow) / 2;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close <= channelMid && this.params.exit_at_mid > 0.5) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bar.close > channelHigh) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_donchian_long_19.ts
import * as fs19 from "fs";
import * as path19 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams19 = {
  channel_period: 15,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  exit_at_mid: 1,
  risk_percent: 0.15
};
function loadSavedParams19() {
  const paramsPath = path19.join(__dirname, "strat_donchian_long_19.params.json");
  if (!fs19.existsSync(paramsPath))
    return null;
  try {
    const content = fs19.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams19) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class DonchianLongStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams19();
    this.params = { ...defaultParams19, ...savedParams, ...params };
    this.params.channel_period = Math.max(3, Math.floor(this.params.channel_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.channel_period + 1)
      history.shift();
    if (history.length < this.params.channel_period)
      return;
    const lookback = history.slice(0, -1);
    const channelHigh = Math.max(...lookback);
    const channelLow = Math.min(...lookback);
    const channelMid = (channelHigh + channelLow) / 2;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close <= channelMid && this.params.exit_at_mid > 0.5) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bar.close > channelHigh) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_fast_20.ts
import * as fs20 from "fs";
import * as path20 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams20 = {
  k_period: 5,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams20() {
  const paramsPath = path20.join(__dirname, "strat_stoch_fast_20.params.json");
  if (!fs20.existsSync(paramsPath))
    return null;
  try {
    const content = fs20.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams20) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochFastStrategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams20();
    this.params = { ...defaultParams20, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_slow_21.ts
import * as fs21 from "fs";
import * as path21 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams21 = {
  k_period: 10,
  d_period: 5,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams21() {
  const paramsPath = path21.join(__dirname, "strat_stoch_slow_21.params.json");
  if (!fs21.existsSync(paramsPath))
    return null;
  try {
    const content = fs21.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams21) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochSlowStrategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams21();
    this.params = { ...defaultParams21, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_short_22.ts
import * as fs22 from "fs";
import * as path22 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams22 = {
  period: 7,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams22() {
  const paramsPath = path22.join(__dirname, "strat_willr_short_22.params.json");
  if (!fs22.existsSync(paramsPath))
    return null;
  try {
    const content = fs22.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams22) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRShortStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams22();
    this.params = { ...defaultParams22, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_long_23.ts
import * as fs23 from "fs";
import * as path23 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams23 = {
  period: 14,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams23() {
  const paramsPath = path23.join(__dirname, "strat_willr_long_23.params.json");
  if (!fs23.existsSync(paramsPath))
    return null;
  try {
    const content = fs23.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams23) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRLongStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams23();
    this.params = { ...defaultParams23, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_accel_fast_24.ts
import * as fs24 from "fs";
import * as path24 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams24 = {
  lookback: 4,
  entry_threshold: 0.005,
  exit_threshold: 0.003,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams24() {
  const paramsPath = path24.join(__dirname, "strat_accel_fast_24.params.json");
  if (!fs24.existsSync(paramsPath))
    return null;
  try {
    const content = fs24.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams24) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class AccelFastStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams24();
    this.params = { ...defaultParams24, ...savedParams, ...params };
    this.params.lookback = Math.max(3, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.lookback + 2)
      history.shift();
    if (history.length < this.params.lookback + 1)
      return;
    const n = history.length;
    const vel1 = history[n - 1] - history[n - 2];
    const vel0 = history[n - 2] - history[n - 3];
    const accel = vel1 - vel0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (accel < -this.params.exit_threshold && vel1 < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (accel > this.params.entry_threshold && vel1 > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_accel_slow_25.ts
import * as fs25 from "fs";
import * as path25 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams25 = {
  lookback: 8,
  entry_threshold: 0.003,
  exit_threshold: 0.002,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams25() {
  const paramsPath = path25.join(__dirname, "strat_accel_slow_25.params.json");
  if (!fs25.existsSync(paramsPath))
    return null;
  try {
    const content = fs25.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams25) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class AccelSlowStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams25();
    this.params = { ...defaultParams25, ...savedParams, ...params };
    this.params.lookback = Math.max(3, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.lookback + 2)
      history.shift();
    if (history.length < this.params.lookback + 1)
      return;
    const n = history.length;
    const vel1 = history[n - 1] - history[n - 2];
    const vel0 = history[n - 2] - history[n - 3];
    const accel = vel1 - vel0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (accel < -this.params.exit_threshold && vel1 < 0) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (accel > this.params.entry_threshold && vel1 > 0) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_vbreak_tight_26.ts
import * as fs26 from "fs";
import * as path26 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams26 = {
  vol_period: 8,
  lookback: 12,
  contraction_ratio: 0.5,
  breakout_threshold: 0.02,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams26() {
  const paramsPath = path26.join(__dirname, "strat_vbreak_tight_26.params.json");
  if (!fs26.existsSync(paramsPath))
    return null;
  try {
    const content = fs26.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams26) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev2(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  return Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
}

class VolBreakTightStrategy {
  params;
  priceHistory = new Map;
  volHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams26();
    this.params = { ...defaultParams26, ...savedParams, ...params };
    this.params.vol_period = Math.max(3, Math.floor(this.params.vol_period));
    this.params.lookback = Math.max(3, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.volHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const volHist = this.volHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > Math.max(this.params.vol_period, this.params.lookback) + 2)
      history.shift();
    if (history.length < this.params.vol_period)
      return;
    const currentVol = stddev2(history.slice(-this.params.vol_period));
    volHist.push(currentVol);
    if (volHist.length > this.params.lookback)
      volHist.shift();
    if (volHist.length < this.params.lookback)
      return;
    const avgVol = volHist.reduce((a, b) => a + b, 0) / volHist.length;
    const isContraction = currentVol < avgVol * this.params.contraction_ratio;
    const priceChange = history.length >= 2 ? (bar.close - history[history.length - 2]) / history[history.length - 2] : 0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (isContraction && priceChange > this.params.breakout_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_vbreak_wide_27.ts
import * as fs27 from "fs";
import * as path27 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams27 = {
  vol_period: 12,
  lookback: 18,
  contraction_ratio: 0.6,
  breakout_threshold: 0.03,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams27() {
  const paramsPath = path27.join(__dirname, "strat_vbreak_wide_27.params.json");
  if (!fs27.existsSync(paramsPath))
    return null;
  try {
    const content = fs27.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams27) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev3(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  return Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
}

class VolBreakWideStrategy {
  params;
  priceHistory = new Map;
  volHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams27();
    this.params = { ...defaultParams27, ...savedParams, ...params };
    this.params.vol_period = Math.max(3, Math.floor(this.params.vol_period));
    this.params.lookback = Math.max(3, Math.floor(this.params.lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.volHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const volHist = this.volHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > Math.max(this.params.vol_period, this.params.lookback) + 2)
      history.shift();
    if (history.length < this.params.vol_period)
      return;
    const currentVol = stddev3(history.slice(-this.params.vol_period));
    volHist.push(currentVol);
    if (volHist.length > this.params.lookback)
      volHist.shift();
    if (volHist.length < this.params.lookback)
      return;
    const avgVol = volHist.reduce((a, b) => a + b, 0) / volHist.length;
    const isContraction = currentVol < avgVol * this.params.contraction_ratio;
    const priceChange = history.length >= 2 ? (bar.close - history[history.length - 2]) / history[history.length - 2] : 0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (isContraction && priceChange > this.params.breakout_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ribbon_tight_28.ts
import * as fs28 from "fs";
import * as path28 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams28 = {
  shortest_period: 3,
  period_step: 2,
  num_mas: 4,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams28() {
  const paramsPath = path28.join(__dirname, "strat_ribbon_tight_28.params.json");
  if (!fs28.existsSync(paramsPath))
    return null;
  try {
    const content = fs28.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams28) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RibbonTightStrategy {
  params;
  maArrays = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams28();
    this.params = { ...defaultParams28, ...savedParams, ...params };
  }
  getMAs(tokenId) {
    if (!this.maArrays.has(tokenId)) {
      const periods = [];
      const base = Math.max(3, Math.floor(this.params.shortest_period));
      const step = Math.max(1, Math.floor(this.params.period_step));
      const count = Math.max(3, Math.floor(this.params.num_mas));
      for (let i = 0;i < count; i++) {
        periods.push(base + i * step);
      }
      this.maArrays.set(tokenId, periods.map((p) => new SimpleMovingAverage(p)));
    }
    return this.maArrays.get(tokenId);
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const mas = this.getMAs(bar.tokenId);
    for (const ma of mas)
      ma.update(bar.close);
    const values = mas.map((ma) => ma.get(0)).filter((v) => v !== undefined);
    if (values.length < mas.length)
      return;
    let bullishAligned = true;
    let bearishAligned = true;
    for (let i = 1;i < values.length; i++) {
      if (values[i - 1] <= values[i])
        bullishAligned = false;
      if (values[i - 1] >= values[i])
        bearishAligned = false;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bearishAligned || bar.close < values[values.length - 1]) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishAligned && bar.close > values[0]) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_ribbon_wide_29.ts
import * as fs29 from "fs";
import * as path29 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams29 = {
  shortest_period: 5,
  period_step: 4,
  num_mas: 5,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams29() {
  const paramsPath = path29.join(__dirname, "strat_ribbon_wide_29.params.json");
  if (!fs29.existsSync(paramsPath))
    return null;
  try {
    const content = fs29.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams29) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RibbonWideStrategy {
  params;
  maArrays = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams29();
    this.params = { ...defaultParams29, ...savedParams, ...params };
  }
  getMAs(tokenId) {
    if (!this.maArrays.has(tokenId)) {
      const periods = [];
      const base = Math.max(3, Math.floor(this.params.shortest_period));
      const step = Math.max(1, Math.floor(this.params.period_step));
      const count = Math.max(3, Math.floor(this.params.num_mas));
      for (let i = 0;i < count; i++) {
        periods.push(base + i * step);
      }
      this.maArrays.set(tokenId, periods.map((p) => new SimpleMovingAverage(p)));
    }
    return this.maArrays.get(tokenId);
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const mas = this.getMAs(bar.tokenId);
    for (const ma of mas)
      ma.update(bar.close);
    const values = mas.map((ma) => ma.get(0)).filter((v) => v !== undefined);
    if (values.length < mas.length)
      return;
    let bullishAligned = true;
    let bearishAligned = true;
    for (let i = 1;i < values.length; i++) {
      if (values[i - 1] <= values[i])
        bullishAligned = false;
      if (values[i - 1] >= values[i])
        bearishAligned = false;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bearishAligned || bar.close < values[values.length - 1]) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishAligned && bar.close > values[0]) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_div_fast_30.ts
import * as fs30 from "fs";
import * as path30 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams30 = {
  rsi_period: 5,
  divergence_lookback: 6,
  oversold: 30,
  overbought: 70,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams30() {
  const paramsPath = path30.join(__dirname, "strat_rsi_div_fast_30.params.json");
  if (!fs30.existsSync(paramsPath))
    return null;
  try {
    const content = fs30.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams30) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RSIDivFastStrategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams30();
    this.params = { ...defaultParams30, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_div_slow_31.ts
import * as fs31 from "fs";
import * as path31 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams31 = {
  rsi_period: 8,
  divergence_lookback: 10,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams31() {
  const paramsPath = path31.join(__dirname, "strat_rsi_div_slow_31.params.json");
  if (!fs31.existsSync(paramsPath))
    return null;
  try {
    const content = fs31.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams31) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RSIDivSlowStrategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams31();
    this.params = { ...defaultParams31, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_tight_32.ts
import * as fs32 from "fs";
import * as path32 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams32 = {
  ma_period: 6,
  rsi_period: 5,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams32() {
  const paramsPath = path32.join(__dirname, "strat_mr_rsi_tight_32.params.json");
  if (!fs32.existsSync(paramsPath))
    return null;
  try {
    const content = fs32.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams32) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRSITightStrategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams32();
    this.params = { ...defaultParams32, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_wide_33.ts
import * as fs33 from "fs";
import * as path33 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams33 = {
  ma_period: 10,
  rsi_period: 7,
  deviation_threshold: 0.04,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams33() {
  const paramsPath = path33.join(__dirname, "strat_mr_rsi_wide_33.params.json");
  if (!fs33.existsSync(paramsPath))
    return null;
  try {
    const content = fs33.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams33) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRSIWideStrategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams33();
    this.params = { ...defaultParams33, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_adapt_fast_34.ts
import * as fs34 from "fs";
import * as path34 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams34 = {
  min_period: 3,
  max_period: 12,
  vol_sensitivity: 50,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams34() {
  const paramsPath = path34.join(__dirname, "strat_adapt_fast_34.params.json");
  if (!fs34.existsSync(paramsPath))
    return null;
  try {
    const content = fs34.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams34) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev4(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  return Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
}

class AdaptFastStrategy {
  params;
  priceHistory = new Map;
  adaptiveMA = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams34();
    this.params = { ...defaultParams34, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxLen = Math.max(Math.floor(this.params.max_period), 20);
    if (history.length > maxLen + 2)
      history.shift();
    if (history.length < Math.floor(this.params.min_period) + 2)
      return;
    const vol = stddev4(history.slice(-Math.min(history.length, 10)));
    const avgPrice = history.reduce((a, b) => a + b, 0) / history.length;
    const relVol = avgPrice > 0 ? vol / avgPrice : 0;
    const volScale = Math.min(1, relVol * this.params.vol_sensitivity);
    const period = Math.max(Math.floor(this.params.min_period), Math.floor(this.params.max_period - (this.params.max_period - this.params.min_period) * volScale));
    const slice = history.slice(-Math.min(history.length, period));
    const maVal = slice.reduce((a, b) => a + b, 0) / slice.length;
    const prevMA = this.adaptiveMA.get(bar.tokenId);
    this.adaptiveMA.set(bar.tokenId, maVal);
    if (prevMA === undefined)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const crossUp = bar.close > maVal && history[history.length - 2] <= prevMA;
    const crossDown = bar.close < maVal && history[history.length - 2] >= prevMA;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (crossDown) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (crossUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_adapt_slow_35.ts
import * as fs35 from "fs";
import * as path35 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams35 = {
  min_period: 5,
  max_period: 25,
  vol_sensitivity: 30,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams35() {
  const paramsPath = path35.join(__dirname, "strat_adapt_slow_35.params.json");
  if (!fs35.existsSync(paramsPath))
    return null;
  try {
    const content = fs35.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams35) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev5(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  return Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
}

class AdaptSlowStrategy {
  params;
  priceHistory = new Map;
  adaptiveMA = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams35();
    this.params = { ...defaultParams35, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxLen = Math.max(Math.floor(this.params.max_period), 20);
    if (history.length > maxLen + 2)
      history.shift();
    if (history.length < Math.floor(this.params.min_period) + 2)
      return;
    const vol = stddev5(history.slice(-Math.min(history.length, 10)));
    const avgPrice = history.reduce((a, b) => a + b, 0) / history.length;
    const relVol = avgPrice > 0 ? vol / avgPrice : 0;
    const volScale = Math.min(1, relVol * this.params.vol_sensitivity);
    const period = Math.max(Math.floor(this.params.min_period), Math.floor(this.params.max_period - (this.params.max_period - this.params.min_period) * volScale));
    const slice = history.slice(-Math.min(history.length, period));
    const maVal = slice.reduce((a, b) => a + b, 0) / slice.length;
    const prevMA = this.adaptiveMA.get(bar.tokenId);
    this.adaptiveMA.set(bar.tokenId, maVal);
    if (prevMA === undefined)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const crossUp = bar.close > maVal && history[history.length - 2] <= prevMA;
    const crossDown = bar.close < maVal && history[history.length - 2] >= prevMA;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (crossDown) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (crossUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_tri_ma_fast_36.ts
import * as fs36 from "fs";
import * as path36 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams36 = {
  fast_period: 3,
  mid_period: 6,
  slow_period: 12,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams36() {
  const paramsPath = path36.join(__dirname, "strat_tri_ma_fast_36.params.json");
  if (!fs36.existsSync(paramsPath))
    return null;
  try {
    const content = fs36.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams36) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TriMAFastStrategy {
  params;
  fastMAs = new Map;
  midMAs = new Map;
  slowMAs = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams36();
    this.params = { ...defaultParams36, ...savedParams, ...params };
    const sorted = [this.params.fast_period, this.params.mid_period, this.params.slow_period].sort((a, b) => a - b);
    this.params.fast_period = Math.max(2, Math.floor(sorted[0]));
    this.params.mid_period = Math.max(3, Math.floor(sorted[1]));
    this.params.slow_period = Math.max(4, Math.floor(sorted[2]));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastMAs.has(bar.tokenId)) {
      this.fastMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.fast_period));
      this.midMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.mid_period));
      this.slowMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.slow_period));
    }
    const fast = this.fastMAs.get(bar.tokenId);
    const mid = this.midMAs.get(bar.tokenId);
    const slow = this.slowMAs.get(bar.tokenId);
    fast.update(bar.close);
    mid.update(bar.close);
    slow.update(bar.close);
    const fv = fast.get(0), mv = mid.get(0), sv = slow.get(0);
    if (fv === undefined || mv === undefined || sv === undefined)
      return;
    const bullish = fv > mv && mv > sv;
    const bearish = fv < mv && mv < sv;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bearish) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullish) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_tri_ma_slow_37.ts
import * as fs37 from "fs";
import * as path37 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams37 = {
  fast_period: 5,
  mid_period: 12,
  slow_period: 20,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams37() {
  const paramsPath = path37.join(__dirname, "strat_tri_ma_slow_37.params.json");
  if (!fs37.existsSync(paramsPath))
    return null;
  try {
    const content = fs37.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams37) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TriMASlowStrategy {
  params;
  fastMAs = new Map;
  midMAs = new Map;
  slowMAs = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams37();
    this.params = { ...defaultParams37, ...savedParams, ...params };
    const sorted = [this.params.fast_period, this.params.mid_period, this.params.slow_period].sort((a, b) => a - b);
    this.params.fast_period = Math.max(2, Math.floor(sorted[0]));
    this.params.mid_period = Math.max(3, Math.floor(sorted[1]));
    this.params.slow_period = Math.max(4, Math.floor(sorted[2]));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.fastMAs.has(bar.tokenId)) {
      this.fastMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.fast_period));
      this.midMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.mid_period));
      this.slowMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.slow_period));
    }
    const fast = this.fastMAs.get(bar.tokenId);
    const mid = this.midMAs.get(bar.tokenId);
    const slow = this.slowMAs.get(bar.tokenId);
    fast.update(bar.close);
    mid.update(bar.close);
    slow.update(bar.close);
    const fv = fast.get(0), mv = mid.get(0), sv = slow.get(0);
    if (fv === undefined || mv === undefined || sv === undefined)
      return;
    const bullish = fv > mv && mv > sv;
    const bearish = fv < mv && mv < sv;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bearish) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullish) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_tight_38.ts
import * as fs38 from "fs";
import * as path38 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams38 = {
  ma_period: 8,
  envelope_pct: 0.03,
  stop_loss: 0.06,
  risk_percent: 0.1
};
function loadSavedParams38() {
  const paramsPath = path38.join(__dirname, "strat_env_tight_38.params.json");
  if (!fs38.existsSync(paramsPath))
    return null;
  try {
    const content = fs38.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams38) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvTightStrategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams38();
    this.params = { ...defaultParams38, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_wide_39.ts
import * as fs39 from "fs";
import * as path39 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams39 = {
  ma_period: 12,
  envelope_pct: 0.05,
  stop_loss: 0.1,
  risk_percent: 0.15
};
function loadSavedParams39() {
  const paramsPath = path39.join(__dirname, "strat_env_wide_39.params.json");
  if (!fs39.existsSync(paramsPath))
    return null;
  try {
    const content = fs39.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams39) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvWideStrategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams39();
    this.params = { ...defaultParams39, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_dip_40.ts
import * as fs40 from "fs";
import * as path40 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams40 = {
  consec_bars: 3,
  buy_on_dip: 1,
  exit_bars: 2,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams40() {
  const paramsPath = path40.join(__dirname, "strat_pat_dip_40.params.json");
  if (!fs40.existsSync(paramsPath))
    return null;
  try {
    const content = fs40.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams40) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatDipStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams40();
    this.params = { ...defaultParams40, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_mom_41.ts
import * as fs41 from "fs";
import * as path41 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams41 = {
  consec_bars: 3,
  buy_on_dip: 0,
  exit_bars: 2,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams41() {
  const paramsPath = path41.join(__dirname, "strat_pat_mom_41.params.json");
  if (!fs41.existsSync(paramsPath))
    return null;
  try {
    const content = fs41.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams41) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatMomStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams41();
    this.params = { ...defaultParams41, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_tight_42.ts
import * as fs42 from "fs";
import * as path42 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams42 = {
  bb_period: 8,
  rsi_period: 5,
  std_mult: 1.8,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams42() {
  const paramsPath = path42.join(__dirname, "strat_combo_tight_42.params.json");
  if (!fs42.existsSync(paramsPath))
    return null;
  try {
    const content = fs42.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams42) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboTightStrategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams42();
    this.params = { ...defaultParams42, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_wide_43.ts
import * as fs43 from "fs";
import * as path43 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams43 = {
  bb_period: 12,
  rsi_period: 7,
  std_mult: 2.2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams43() {
  const paramsPath = path43.join(__dirname, "strat_combo_wide_43.params.json");
  if (!fs43.existsSync(paramsPath))
    return null;
  try {
    const content = fs43.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams43) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev2 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboWideStrategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams43();
    this.params = { ...defaultParams43, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev2(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_tstr_fast_44.ts
import * as fs44 from "fs";
import * as path44 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams44 = {
  lookback: 6,
  entry_strength: 0.7,
  exit_strength: 0.3,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams44() {
  const paramsPath = path44.join(__dirname, "strat_tstr_fast_44.params.json");
  if (!fs44.existsSync(paramsPath))
    return null;
  try {
    const content = fs44.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams44) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TStrFastStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams44();
    this.params = { ...defaultParams44, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  trendStrength(history) {
    let ups = 0;
    for (let i = 1;i < history.length; i++) {
      if (history[i] > history[i - 1])
        ups++;
    }
    return ups / (history.length - 1);
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const period = Math.max(3, Math.floor(this.params.lookback));
    if (history.length > period + 2)
      history.shift();
    if (history.length < period)
      return;
    const strength = this.trendStrength(history);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (strength < this.params.exit_strength) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (strength >= this.params.entry_strength) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_tstr_slow_45.ts
import * as fs45 from "fs";
import * as path45 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams45 = {
  lookback: 12,
  entry_strength: 0.65,
  exit_strength: 0.35,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams45() {
  const paramsPath = path45.join(__dirname, "strat_tstr_slow_45.params.json");
  if (!fs45.existsSync(paramsPath))
    return null;
  try {
    const content = fs45.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams45) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TStrSlowStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams45();
    this.params = { ...defaultParams45, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  trendStrength(history) {
    let ups = 0;
    for (let i = 1;i < history.length; i++) {
      if (history[i] > history[i - 1])
        ups++;
    }
    return ups / (history.length - 1);
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const period = Math.max(3, Math.floor(this.params.lookback));
    if (history.length > period + 2)
      history.shift();
    if (history.length < period)
      return;
    const strength = this.trendStrength(history);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (strength < this.params.exit_strength) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (strength >= this.params.entry_strength) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_swing_short_46.ts
import * as fs46 from "fs";
import * as path46 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams46 = {
  swing_window: 3,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  take_profit: 0.08,
  risk_percent: 0.1
};
function loadSavedParams46() {
  const paramsPath = path46.join(__dirname, "strat_swing_short_46.params.json");
  if (!fs46.existsSync(paramsPath))
    return null;
  try {
    const content = fs46.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams46) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SwingShortStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams46();
    this.params = { ...defaultParams46, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  findSwingLow(history, window) {
    if (history.length < window * 2 + 1)
      return false;
    const idx = history.length - 1 - window;
    const val = history[idx];
    for (let i = idx - window;i <= idx + window; i++) {
      if (i !== idx && history[i] <= val)
        return false;
    }
    return true;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const window = Math.max(2, Math.floor(this.params.swing_window));
    if (history.length > window * 3 + 2)
      history.shift();
    const isSwingLow = this.findSwingLow(history, window);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.take_profit)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (isSwingLow) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_swing_long_47.ts
import * as fs47 from "fs";
import * as path47 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams47 = {
  swing_window: 5,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  take_profit: 0.12,
  risk_percent: 0.15
};
function loadSavedParams47() {
  const paramsPath = path47.join(__dirname, "strat_swing_long_47.params.json");
  if (!fs47.existsSync(paramsPath))
    return null;
  try {
    const content = fs47.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams47) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SwingLongStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams47();
    this.params = { ...defaultParams47, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  findSwingLow(history, window) {
    if (history.length < window * 2 + 1)
      return false;
    const idx = history.length - 1 - window;
    const val = history[idx];
    for (let i = idx - window;i <= idx + window; i++) {
      if (i !== idx && history[i] <= val)
        return false;
    }
    return true;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const window = Math.max(2, Math.floor(this.params.swing_window));
    if (history.length > window * 3 + 2)
      history.shift();
    const isSwingLow = this.findSwingLow(history, window);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.take_profit)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (isSwingLow) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rev_fast_48.ts
import * as fs48 from "fs";
import * as path48 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams48 = {
  lookback: 5,
  drop_threshold: 0.05,
  bounce_threshold: 0.02,
  stop_loss: 0.06,
  take_profit: 0.08,
  risk_percent: 0.1
};
function loadSavedParams48() {
  const paramsPath = path48.join(__dirname, "strat_rev_fast_48.params.json");
  if (!fs48.existsSync(paramsPath))
    return null;
  try {
    const content = fs48.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams48) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RevFastStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams48();
    this.params = { ...defaultParams48, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const lookback = Math.max(3, Math.floor(this.params.lookback));
    if (history.length > lookback + 2)
      history.shift();
    if (history.length < lookback)
      return;
    const recentMin = Math.min(...history.slice(0, -1));
    const dropFromStart = (history[0] - recentMin) / history[0];
    const bounceFromMin = recentMin > 0 ? (bar.close - recentMin) / recentMin : 0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.take_profit)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (dropFromStart >= this.params.drop_threshold && bounceFromMin >= this.params.bounce_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rev_slow_49.ts
import * as fs49 from "fs";
import * as path49 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams49 = {
  lookback: 10,
  drop_threshold: 0.08,
  bounce_threshold: 0.03,
  stop_loss: 0.1,
  take_profit: 0.12,
  risk_percent: 0.15
};
function loadSavedParams49() {
  const paramsPath = path49.join(__dirname, "strat_rev_slow_49.params.json");
  if (!fs49.existsSync(paramsPath))
    return null;
  try {
    const content = fs49.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams49) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RevSlowStrategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams49();
    this.params = { ...defaultParams49, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const lookback = Math.max(3, Math.floor(this.params.lookback));
    if (history.length > lookback + 2)
      history.shift();
    if (history.length < lookback)
      return;
    const recentMin = Math.min(...history.slice(0, -1));
    const dropFromStart = (history[0] - recentMin) / history[0];
    const bounceFromMin = recentMin > 0 ? (bar.close - recentMin) / recentMin : 0;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.take_profit)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (dropFromStart >= this.params.drop_threshold && bounceFromMin >= this.params.bounce_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_tight_50.ts
import * as fs50 from "fs";
import * as path50 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams50 = {
  channel_period: 8,
  channel_width: 0.5,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams50() {
  const paramsPath = path50.join(__dirname, "strat_chan_tight_50.params.json");
  if (!fs50.existsSync(paramsPath))
    return null;
  try {
    const content = fs50.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams50) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanTightStrategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams50();
    this.params = { ...defaultParams50, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_wide_51.ts
import * as fs51 from "fs";
import * as path51 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams51 = {
  channel_period: 15,
  channel_width: 0.7,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams51() {
  const paramsPath = path51.join(__dirname, "strat_chan_wide_51.params.json");
  if (!fs51.existsSync(paramsPath))
    return null;
  try {
    const content = fs51.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams51) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanWideStrategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams51();
    this.params = { ...defaultParams51, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mcross_fast_52.ts
import * as fs52 from "fs";
import * as path52 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams52 = {
  ma_period: 5,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams52() {
  const paramsPath = path52.join(__dirname, "strat_mcross_fast_52.params.json");
  if (!fs52.existsSync(paramsPath))
    return null;
  try {
    const content = fs52.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams52) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MCrossFastStrategy {
  params;
  smaMap = new Map;
  prevPrice = new Map;
  prevMA = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams52();
    this.params = { ...defaultParams52, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined) {
      this.prevPrice.set(bar.tokenId, bar.close);
      return;
    }
    const pp = this.prevPrice.get(bar.tokenId);
    const pm = this.prevMA.get(bar.tokenId);
    this.prevPrice.set(bar.tokenId, bar.close);
    this.prevMA.set(bar.tokenId, maVal);
    if (pp === undefined || pm === undefined)
      return;
    const crossUp = pp <= pm && bar.close > maVal;
    const crossDown = pp >= pm && bar.close < maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (crossDown) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (crossUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mcross_slow_53.ts
import * as fs53 from "fs";
import * as path53 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams53 = {
  ma_period: 12,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams53() {
  const paramsPath = path53.join(__dirname, "strat_mcross_slow_53.params.json");
  if (!fs53.existsSync(paramsPath))
    return null;
  try {
    const content = fs53.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams53) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MCrossSlowStrategy {
  params;
  smaMap = new Map;
  prevPrice = new Map;
  prevMA = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams53();
    this.params = { ...defaultParams53, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined) {
      this.prevPrice.set(bar.tokenId, bar.close);
      return;
    }
    const pp = this.prevPrice.get(bar.tokenId);
    const pm = this.prevMA.get(bar.tokenId);
    this.prevPrice.set(bar.tokenId, bar.close);
    this.prevMA.set(bar.tokenId, maVal);
    if (pp === undefined || pm === undefined)
      return;
    const crossUp = pp <= pm && bar.close > maVal;
    const crossDown = pp >= pm && bar.close < maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (crossDown) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (crossUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v01_54.ts
import * as fs54 from "fs";
import * as path54 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams54 = {
  ma_period: 3,
  rsi_period: 3,
  deviation_threshold: 0.015,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams54() {
  const paramsPath = path54.join(__dirname, "strat_mr_rsi_v01_54.params.json");
  if (!fs54.existsSync(paramsPath))
    return null;
  try {
    const content = fs54.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams54) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV01Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams54();
    this.params = { ...defaultParams54, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v02_55.ts
import * as fs55 from "fs";
import * as path55 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams55 = {
  ma_period: 4,
  rsi_period: 4,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams55() {
  const paramsPath = path55.join(__dirname, "strat_mr_rsi_v02_55.params.json");
  if (!fs55.existsSync(paramsPath))
    return null;
  try {
    const content = fs55.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams55) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV02Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams55();
    this.params = { ...defaultParams55, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v03_56.ts
import * as fs56 from "fs";
import * as path56 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams56 = {
  ma_period: 4,
  rsi_period: 5,
  deviation_threshold: 0.03,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.15
};
function loadSavedParams56() {
  const paramsPath = path56.join(__dirname, "strat_mr_rsi_v03_56.params.json");
  if (!fs56.existsSync(paramsPath))
    return null;
  try {
    const content = fs56.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams56) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV03Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams56();
    this.params = { ...defaultParams56, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v04_57.ts
import * as fs57 from "fs";
import * as path57 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams57 = {
  ma_period: 6,
  rsi_period: 5,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams57() {
  const paramsPath = path57.join(__dirname, "strat_mr_rsi_v04_57.params.json");
  if (!fs57.existsSync(paramsPath))
    return null;
  try {
    const content = fs57.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams57) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV04Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams57();
    this.params = { ...defaultParams57, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v05_58.ts
import * as fs58 from "fs";
import * as path58 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams58 = {
  ma_period: 7,
  rsi_period: 6,
  deviation_threshold: 0.03,
  rsi_oversold: 28,
  rsi_overbought: 72,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams58() {
  const paramsPath = path58.join(__dirname, "strat_mr_rsi_v05_58.params.json");
  if (!fs58.existsSync(paramsPath))
    return null;
  try {
    const content = fs58.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams58) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV05Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams58();
    this.params = { ...defaultParams58, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v06_59.ts
import * as fs59 from "fs";
import * as path59 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams59 = {
  ma_period: 8,
  rsi_period: 7,
  deviation_threshold: 0.04,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.07,
  risk_percent: 0.18
};
function loadSavedParams59() {
  const paramsPath = path59.join(__dirname, "strat_mr_rsi_v06_59.params.json");
  if (!fs59.existsSync(paramsPath))
    return null;
  try {
    const content = fs59.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams59) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV06Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams59();
    this.params = { ...defaultParams59, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v07_60.ts
import * as fs60 from "fs";
import * as path60 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams60 = {
  ma_period: 10,
  rsi_period: 8,
  deviation_threshold: 0.03,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams60() {
  const paramsPath = path60.join(__dirname, "strat_mr_rsi_v07_60.params.json");
  if (!fs60.existsSync(paramsPath))
    return null;
  try {
    const content = fs60.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams60) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV07Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams60();
    this.params = { ...defaultParams60, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v08_61.ts
import * as fs61 from "fs";
import * as path61 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams61 = {
  ma_period: 12,
  rsi_period: 9,
  deviation_threshold: 0.05,
  rsi_oversold: 22,
  rsi_overbought: 78,
  stop_loss: 0.08,
  risk_percent: 0.2
};
function loadSavedParams61() {
  const paramsPath = path61.join(__dirname, "strat_mr_rsi_v08_61.params.json");
  if (!fs61.existsSync(paramsPath))
    return null;
  try {
    const content = fs61.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams61) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV08Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams61();
    this.params = { ...defaultParams61, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v09_62.ts
import * as fs62 from "fs";
import * as path62 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams62 = {
  ma_period: 5,
  rsi_period: 4,
  deviation_threshold: 0.05,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams62() {
  const paramsPath = path62.join(__dirname, "strat_mr_rsi_v09_62.params.json");
  if (!fs62.existsSync(paramsPath))
    return null;
  try {
    const content = fs62.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams62) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV09Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams62();
    this.params = { ...defaultParams62, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v10_63.ts
import * as fs63 from "fs";
import * as path63 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams63 = {
  ma_period: 5,
  rsi_period: 5,
  deviation_threshold: 0.01,
  rsi_oversold: 35,
  rsi_overbought: 65,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams63() {
  const paramsPath = path63.join(__dirname, "strat_mr_rsi_v10_63.params.json");
  if (!fs63.existsSync(paramsPath))
    return null;
  try {
    const content = fs63.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams63) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV10Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams63();
    this.params = { ...defaultParams63, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v11_64.ts
import * as fs64 from "fs";
import * as path64 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams64 = {
  ma_period: 3,
  rsi_period: 3,
  deviation_threshold: 0.01,
  rsi_oversold: 35,
  rsi_overbought: 65,
  stop_loss: 0.06,
  risk_percent: 0.25
};
function loadSavedParams64() {
  const paramsPath = path64.join(__dirname, "strat_mr_rsi_v11_64.params.json");
  if (!fs64.existsSync(paramsPath))
    return null;
  try {
    const content = fs64.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams64) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV11Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams64();
    this.params = { ...defaultParams64, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v12_65.ts
import * as fs65 from "fs";
import * as path65 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams65 = {
  ma_period: 10,
  rsi_period: 8,
  deviation_threshold: 0.04,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.04,
  risk_percent: 0.05
};
function loadSavedParams65() {
  const paramsPath = path65.join(__dirname, "strat_mr_rsi_v12_65.params.json");
  if (!fs65.existsSync(paramsPath))
    return null;
  try {
    const content = fs65.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams65) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV12Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams65();
    this.params = { ...defaultParams65, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v13_66.ts
import * as fs66 from "fs";
import * as path66 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams66 = {
  ma_period: 6,
  rsi_period: 5,
  deviation_threshold: 0.025,
  rsi_oversold: 28,
  rsi_overbought: 72,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams66() {
  const paramsPath = path66.join(__dirname, "strat_mr_rsi_v13_66.params.json");
  if (!fs66.existsSync(paramsPath))
    return null;
  try {
    const content = fs66.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams66) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV13Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams66();
    this.params = { ...defaultParams66, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v14_67.ts
import * as fs67 from "fs";
import * as path67 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams67 = {
  ma_period: 7,
  rsi_period: 6,
  deviation_threshold: 0.035,
  rsi_oversold: 26,
  rsi_overbought: 74,
  stop_loss: 0.06,
  risk_percent: 0.14
};
function loadSavedParams67() {
  const paramsPath = path67.join(__dirname, "strat_mr_rsi_v14_67.params.json");
  if (!fs67.existsSync(paramsPath))
    return null;
  try {
    const content = fs67.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams67) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV14Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams67();
    this.params = { ...defaultParams67, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v15_68.ts
import * as fs68 from "fs";
import * as path68 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams68 = {
  ma_period: 5,
  rsi_period: 4,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.02,
  risk_percent: 0.1
};
function loadSavedParams68() {
  const paramsPath = path68.join(__dirname, "strat_mr_rsi_v15_68.params.json");
  if (!fs68.existsSync(paramsPath))
    return null;
  try {
    const content = fs68.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams68) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV15Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams68();
    this.params = { ...defaultParams68, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v16_69.ts
import * as fs69 from "fs";
import * as path69 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams69 = {
  ma_period: 5,
  rsi_period: 4,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.1,
  risk_percent: 0.1
};
function loadSavedParams69() {
  const paramsPath = path69.join(__dirname, "strat_mr_rsi_v16_69.params.json");
  if (!fs69.existsSync(paramsPath))
    return null;
  try {
    const content = fs69.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams69) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV16Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams69();
    this.params = { ...defaultParams69, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v17_70.ts
import * as fs70 from "fs";
import * as path70 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams70 = {
  ma_period: 6,
  rsi_period: 5,
  deviation_threshold: 0.03,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.3
};
function loadSavedParams70() {
  const paramsPath = path70.join(__dirname, "strat_mr_rsi_v17_70.params.json");
  if (!fs70.existsSync(paramsPath))
    return null;
  try {
    const content = fs70.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams70) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV17Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams70();
    this.params = { ...defaultParams70, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v18_71.ts
import * as fs71 from "fs";
import * as path71 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams71 = {
  ma_period: 6,
  rsi_period: 5,
  deviation_threshold: 0.03,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.05
};
function loadSavedParams71() {
  const paramsPath = path71.join(__dirname, "strat_mr_rsi_v18_71.params.json");
  if (!fs71.existsSync(paramsPath))
    return null;
  try {
    const content = fs71.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams71) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV18Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams71();
    this.params = { ...defaultParams71, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v19_72.ts
import * as fs72 from "fs";
import * as path72 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams72 = {
  ma_period: 3,
  rsi_period: 3,
  deviation_threshold: 0.02,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.04,
  risk_percent: 0.12
};
function loadSavedParams72() {
  const paramsPath = path72.join(__dirname, "strat_mr_rsi_v19_72.params.json");
  if (!fs72.existsSync(paramsPath))
    return null;
  try {
    const content = fs72.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams72) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV19Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams72();
    this.params = { ...defaultParams72, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mr_rsi_v20_73.ts
import * as fs73 from "fs";
import * as path73 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams73 = {
  ma_period: 14,
  rsi_period: 10,
  deviation_threshold: 0.06,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.1,
  risk_percent: 0.15
};
function loadSavedParams73() {
  const paramsPath = path73.join(__dirname, "strat_mr_rsi_v20_73.params.json");
  if (!fs73.existsSync(paramsPath))
    return null;
  try {
    const content = fs73.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams73) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MRRsiV20Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams73();
    this.params = { ...defaultParams73, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const rsiVal = rsi.get(0);
    if (maVal === undefined || rsiVal === undefined)
      return;
    const deviation = (maVal - bar.close) / maVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= maVal || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (deviation >= this.params.deviation_threshold && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v01_74.ts
import * as fs74 from "fs";
import * as path74 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams74 = {
  period: 4,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.1
};
function loadSavedParams74() {
  const paramsPath = path74.join(__dirname, "strat_willr_v01_74.params.json");
  if (!fs74.existsSync(paramsPath))
    return null;
  try {
    const content = fs74.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams74) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV01Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams74();
    this.params = { ...defaultParams74, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v02_75.ts
import * as fs75 from "fs";
import * as path75 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams75 = {
  period: 5,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.08
};
function loadSavedParams75() {
  const paramsPath = path75.join(__dirname, "strat_willr_v02_75.params.json");
  if (!fs75.existsSync(paramsPath))
    return null;
  try {
    const content = fs75.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams75) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV02Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams75();
    this.params = { ...defaultParams75, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v03_76.ts
import * as fs76 from "fs";
import * as path76 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams76 = {
  period: 5,
  oversold_level: -90,
  overbought_level: -10,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams76() {
  const paramsPath = path76.join(__dirname, "strat_willr_v03_76.params.json");
  if (!fs76.existsSync(paramsPath))
    return null;
  try {
    const content = fs76.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams76) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV03Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams76();
    this.params = { ...defaultParams76, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v04_77.ts
import * as fs77 from "fs";
import * as path77 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams77 = {
  period: 8,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams77() {
  const paramsPath = path77.join(__dirname, "strat_willr_v04_77.params.json");
  if (!fs77.existsSync(paramsPath))
    return null;
  try {
    const content = fs77.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams77) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV04Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams77();
    this.params = { ...defaultParams77, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v05_78.ts
import * as fs78 from "fs";
import * as path78 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams78 = {
  period: 8,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams78() {
  const paramsPath = path78.join(__dirname, "strat_willr_v05_78.params.json");
  if (!fs78.existsSync(paramsPath))
    return null;
  try {
    const content = fs78.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams78) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV05Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams78();
    this.params = { ...defaultParams78, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v06_79.ts
import * as fs79 from "fs";
import * as path79 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams79 = {
  period: 8,
  oversold_level: -95,
  overbought_level: -5,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.2
};
function loadSavedParams79() {
  const paramsPath = path79.join(__dirname, "strat_willr_v06_79.params.json");
  if (!fs79.existsSync(paramsPath))
    return null;
  try {
    const content = fs79.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams79) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV06Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams79();
    this.params = { ...defaultParams79, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v07_80.ts
import * as fs80 from "fs";
import * as path80 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams80 = {
  period: 12,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams80() {
  const paramsPath = path80.join(__dirname, "strat_willr_v07_80.params.json");
  if (!fs80.existsSync(paramsPath))
    return null;
  try {
    const content = fs80.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams80) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV07Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams80();
    this.params = { ...defaultParams80, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v08_81.ts
import * as fs81 from "fs";
import * as path81 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams81 = {
  period: 12,
  oversold_level: -90,
  overbought_level: -10,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.18
};
function loadSavedParams81() {
  const paramsPath = path81.join(__dirname, "strat_willr_v08_81.params.json");
  if (!fs81.existsSync(paramsPath))
    return null;
  try {
    const content = fs81.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams81) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV08Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams81();
    this.params = { ...defaultParams81, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v09_82.ts
import * as fs82 from "fs";
import * as path82 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams82 = {
  period: 7,
  oversold_level: -95,
  overbought_level: -25,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams82() {
  const paramsPath = path82.join(__dirname, "strat_willr_v09_82.params.json");
  if (!fs82.existsSync(paramsPath))
    return null;
  try {
    const content = fs82.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams82) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV09Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams82();
    this.params = { ...defaultParams82, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v10_83.ts
import * as fs83 from "fs";
import * as path83 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams83 = {
  period: 6,
  oversold_level: -70,
  overbought_level: -30,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.08
};
function loadSavedParams83() {
  const paramsPath = path83.join(__dirname, "strat_willr_v10_83.params.json");
  if (!fs83.existsSync(paramsPath))
    return null;
  try {
    const content = fs83.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams83) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV10Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams83();
    this.params = { ...defaultParams83, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v11_84.ts
import * as fs84 from "fs";
import * as path84 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams84 = {
  period: 4,
  oversold_level: -75,
  overbought_level: -25,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.25
};
function loadSavedParams84() {
  const paramsPath = path84.join(__dirname, "strat_willr_v11_84.params.json");
  if (!fs84.existsSync(paramsPath))
    return null;
  try {
    const content = fs84.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams84) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV11Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams84();
    this.params = { ...defaultParams84, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v12_85.ts
import * as fs85 from "fs";
import * as path85 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams85 = {
  period: 14,
  oversold_level: -90,
  overbought_level: -10,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.05
};
function loadSavedParams85() {
  const paramsPath = path85.join(__dirname, "strat_willr_v12_85.params.json");
  if (!fs85.existsSync(paramsPath))
    return null;
  try {
    const content = fs85.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams85) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV12Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams85();
    this.params = { ...defaultParams85, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v13_86.ts
import * as fs86 from "fs";
import * as path86 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams86 = {
  period: 7,
  oversold_level: -82,
  overbought_level: -18,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams86() {
  const paramsPath = path86.join(__dirname, "strat_willr_v13_86.params.json");
  if (!fs86.existsSync(paramsPath))
    return null;
  try {
    const content = fs86.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams86) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV13Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams86();
    this.params = { ...defaultParams86, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v14_87.ts
import * as fs87 from "fs";
import * as path87 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams87 = {
  period: 9,
  oversold_level: -78,
  overbought_level: -22,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  risk_percent: 0.14
};
function loadSavedParams87() {
  const paramsPath = path87.join(__dirname, "strat_willr_v14_87.params.json");
  if (!fs87.existsSync(paramsPath))
    return null;
  try {
    const content = fs87.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams87) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV14Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams87();
    this.params = { ...defaultParams87, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v15_88.ts
import * as fs88 from "fs";
import * as path88 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams88 = {
  period: 7,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.02,
  trailing_stop: 0.02,
  risk_percent: 0.1
};
function loadSavedParams88() {
  const paramsPath = path88.join(__dirname, "strat_willr_v15_88.params.json");
  if (!fs88.existsSync(paramsPath))
    return null;
  try {
    const content = fs88.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams88) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV15Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams88();
    this.params = { ...defaultParams88, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v16_89.ts
import * as fs89 from "fs";
import * as path89 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams89 = {
  period: 7,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.12,
  trailing_stop: 0.08,
  risk_percent: 0.1
};
function loadSavedParams89() {
  const paramsPath = path89.join(__dirname, "strat_willr_v16_89.params.json");
  if (!fs89.existsSync(paramsPath))
    return null;
  try {
    const content = fs89.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams89) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV16Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams89();
    this.params = { ...defaultParams89, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v17_90.ts
import * as fs90 from "fs";
import * as path90 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams90 = {
  period: 6,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.3
};
function loadSavedParams90() {
  const paramsPath = path90.join(__dirname, "strat_willr_v17_90.params.json");
  if (!fs90.existsSync(paramsPath))
    return null;
  try {
    const content = fs90.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams90) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV17Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams90();
    this.params = { ...defaultParams90, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v18_91.ts
import * as fs91 from "fs";
import * as path91 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams91 = {
  period: 6,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.05
};
function loadSavedParams91() {
  const paramsPath = path91.join(__dirname, "strat_willr_v18_91.params.json");
  if (!fs91.existsSync(paramsPath))
    return null;
  try {
    const content = fs91.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams91) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV18Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams91();
    this.params = { ...defaultParams91, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v19_92.ts
import * as fs92 from "fs";
import * as path92 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams92 = {
  period: 3,
  oversold_level: -80,
  overbought_level: -20,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams92() {
  const paramsPath = path92.join(__dirname, "strat_willr_v19_92.params.json");
  if (!fs92.existsSync(paramsPath))
    return null;
  try {
    const content = fs92.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams92) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV19Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams92();
    this.params = { ...defaultParams92, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_willr_v20_93.ts
import * as fs93 from "fs";
import * as path93 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams93 = {
  period: 18,
  oversold_level: -85,
  overbought_level: -15,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams93() {
  const paramsPath = path93.join(__dirname, "strat_willr_v20_93.params.json");
  if (!fs93.existsSync(paramsPath))
    return null;
  try {
    const content = fs93.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams93) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class WillRV20Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams93();
    this.params = { ...defaultParams93, ...savedParams, ...params };
    this.params.period = Math.max(3, Math.floor(this.params.period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.period)
      history.shift();
    if (history.length < this.params.period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const wr = highest === lowest ? -50 : (highest - bar.close) / (highest - lowest) * -100;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const high = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, high);
        if (bar.close < high * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (wr >= this.params.overbought_level) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (wr <= this.params.oversold_level) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v01_94.ts
import * as fs94 from "fs";
import * as path94 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams94 = {
  ma_period: 4,
  envelope_pct: 0.01,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams94() {
  const paramsPath = path94.join(__dirname, "strat_env_v01_94.params.json");
  if (!fs94.existsSync(paramsPath))
    return null;
  try {
    const content = fs94.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams94) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV01Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams94();
    this.params = { ...defaultParams94, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v02_95.ts
import * as fs95 from "fs";
import * as path95 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams95 = {
  ma_period: 5,
  envelope_pct: 0.015,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams95() {
  const paramsPath = path95.join(__dirname, "strat_env_v02_95.params.json");
  if (!fs95.existsSync(paramsPath))
    return null;
  try {
    const content = fs95.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams95) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV02Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams95();
    this.params = { ...defaultParams95, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v03_96.ts
import * as fs96 from "fs";
import * as path96 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams96 = {
  ma_period: 5,
  envelope_pct: 0.025,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams96() {
  const paramsPath = path96.join(__dirname, "strat_env_v03_96.params.json");
  if (!fs96.existsSync(paramsPath))
    return null;
  try {
    const content = fs96.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams96) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV03Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams96();
    this.params = { ...defaultParams96, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v04_97.ts
import * as fs97 from "fs";
import * as path97 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams97 = {
  ma_period: 5,
  envelope_pct: 0.04,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams97() {
  const paramsPath = path97.join(__dirname, "strat_env_v04_97.params.json");
  if (!fs97.existsSync(paramsPath))
    return null;
  try {
    const content = fs97.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams97) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV04Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams97();
    this.params = { ...defaultParams97, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v05_98.ts
import * as fs98 from "fs";
import * as path98 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams98 = {
  ma_period: 8,
  envelope_pct: 0.02,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams98() {
  const paramsPath = path98.join(__dirname, "strat_env_v05_98.params.json");
  if (!fs98.existsSync(paramsPath))
    return null;
  try {
    const content = fs98.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams98) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV05Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams98();
    this.params = { ...defaultParams98, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v06_99.ts
import * as fs99 from "fs";
import * as path99 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams99 = {
  ma_period: 8,
  envelope_pct: 0.03,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams99() {
  const paramsPath = path99.join(__dirname, "strat_env_v06_99.params.json");
  if (!fs99.existsSync(paramsPath))
    return null;
  try {
    const content = fs99.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams99) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV06Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams99();
    this.params = { ...defaultParams99, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v07_100.ts
import * as fs100 from "fs";
import * as path100 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams100 = {
  ma_period: 8,
  envelope_pct: 0.05,
  stop_loss: 0.08,
  risk_percent: 0.18
};
function loadSavedParams100() {
  const paramsPath = path100.join(__dirname, "strat_env_v07_100.params.json");
  if (!fs100.existsSync(paramsPath))
    return null;
  try {
    const content = fs100.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams100) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV07Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams100();
    this.params = { ...defaultParams100, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v08_101.ts
import * as fs101 from "fs";
import * as path101 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams101 = {
  ma_period: 12,
  envelope_pct: 0.02,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams101() {
  const paramsPath = path101.join(__dirname, "strat_env_v08_101.params.json");
  if (!fs101.existsSync(paramsPath))
    return null;
  try {
    const content = fs101.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams101) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV08Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams101();
    this.params = { ...defaultParams101, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v09_102.ts
import * as fs102 from "fs";
import * as path102 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams102 = {
  ma_period: 12,
  envelope_pct: 0.04,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams102() {
  const paramsPath = path102.join(__dirname, "strat_env_v09_102.params.json");
  if (!fs102.existsSync(paramsPath))
    return null;
  try {
    const content = fs102.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams102) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV09Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams102();
    this.params = { ...defaultParams102, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v10_103.ts
import * as fs103 from "fs";
import * as path103 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams103 = {
  ma_period: 12,
  envelope_pct: 0.06,
  stop_loss: 0.1,
  risk_percent: 0.2
};
function loadSavedParams103() {
  const paramsPath = path103.join(__dirname, "strat_env_v10_103.params.json");
  if (!fs103.existsSync(paramsPath))
    return null;
  try {
    const content = fs103.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams103) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV10Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams103();
    this.params = { ...defaultParams103, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v11_104.ts
import * as fs104 from "fs";
import * as path104 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams104 = {
  ma_period: 4,
  envelope_pct: 0.015,
  stop_loss: 0.06,
  risk_percent: 0.25
};
function loadSavedParams104() {
  const paramsPath = path104.join(__dirname, "strat_env_v11_104.params.json");
  if (!fs104.existsSync(paramsPath))
    return null;
  try {
    const content = fs104.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams104) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV11Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams104();
    this.params = { ...defaultParams104, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v12_105.ts
import * as fs105 from "fs";
import * as path105 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams105 = {
  ma_period: 15,
  envelope_pct: 0.05,
  stop_loss: 0.04,
  risk_percent: 0.05
};
function loadSavedParams105() {
  const paramsPath = path105.join(__dirname, "strat_env_v12_105.params.json");
  if (!fs105.existsSync(paramsPath))
    return null;
  try {
    const content = fs105.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams105) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV12Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams105();
    this.params = { ...defaultParams105, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v13_106.ts
import * as fs106 from "fs";
import * as path106 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams106 = {
  ma_period: 7,
  envelope_pct: 0.025,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams106() {
  const paramsPath = path106.join(__dirname, "strat_env_v13_106.params.json");
  if (!fs106.existsSync(paramsPath))
    return null;
  try {
    const content = fs106.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams106) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV13Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams106();
    this.params = { ...defaultParams106, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v14_107.ts
import * as fs107 from "fs";
import * as path107 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams107 = {
  ma_period: 9,
  envelope_pct: 0.035,
  stop_loss: 0.06,
  risk_percent: 0.14
};
function loadSavedParams107() {
  const paramsPath = path107.join(__dirname, "strat_env_v14_107.params.json");
  if (!fs107.existsSync(paramsPath))
    return null;
  try {
    const content = fs107.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams107) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV14Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams107();
    this.params = { ...defaultParams107, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v15_108.ts
import * as fs108 from "fs";
import * as path108 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams108 = {
  ma_period: 6,
  envelope_pct: 0.02,
  stop_loss: 0.02,
  risk_percent: 0.1
};
function loadSavedParams108() {
  const paramsPath = path108.join(__dirname, "strat_env_v15_108.params.json");
  if (!fs108.existsSync(paramsPath))
    return null;
  try {
    const content = fs108.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams108) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV15Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams108();
    this.params = { ...defaultParams108, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v16_109.ts
import * as fs109 from "fs";
import * as path109 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams109 = {
  ma_period: 6,
  envelope_pct: 0.02,
  stop_loss: 0.12,
  risk_percent: 0.1
};
function loadSavedParams109() {
  const paramsPath = path109.join(__dirname, "strat_env_v16_109.params.json");
  if (!fs109.existsSync(paramsPath))
    return null;
  try {
    const content = fs109.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams109) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV16Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams109();
    this.params = { ...defaultParams109, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v17_110.ts
import * as fs110 from "fs";
import * as path110 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams110 = {
  ma_period: 7,
  envelope_pct: 0.03,
  stop_loss: 0.06,
  risk_percent: 0.3
};
function loadSavedParams110() {
  const paramsPath = path110.join(__dirname, "strat_env_v17_110.params.json");
  if (!fs110.existsSync(paramsPath))
    return null;
  try {
    const content = fs110.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams110) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV17Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams110();
    this.params = { ...defaultParams110, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v18_111.ts
import * as fs111 from "fs";
import * as path111 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams111 = {
  ma_period: 7,
  envelope_pct: 0.03,
  stop_loss: 0.06,
  risk_percent: 0.05
};
function loadSavedParams111() {
  const paramsPath = path111.join(__dirname, "strat_env_v18_111.params.json");
  if (!fs111.existsSync(paramsPath))
    return null;
  try {
    const content = fs111.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams111) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV18Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams111();
    this.params = { ...defaultParams111, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v19_112.ts
import * as fs112 from "fs";
import * as path112 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams112 = {
  ma_period: 3,
  envelope_pct: 0.008,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams112() {
  const paramsPath = path112.join(__dirname, "strat_env_v19_112.params.json");
  if (!fs112.existsSync(paramsPath))
    return null;
  try {
    const content = fs112.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams112) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV19Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams112();
    this.params = { ...defaultParams112, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_env_v20_113.ts
import * as fs113 from "fs";
import * as path113 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams113 = {
  ma_period: 18,
  envelope_pct: 0.06,
  stop_loss: 0.1,
  risk_percent: 0.15
};
function loadSavedParams113() {
  const paramsPath = path113.join(__dirname, "strat_env_v20_113.params.json");
  if (!fs113.existsSync(paramsPath))
    return null;
  try {
    const content = fs113.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams113) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class EnvV20Strategy {
  params;
  smaMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams113();
    this.params = { ...defaultParams113, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(Math.max(3, Math.floor(this.params.ma_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    sma.update(bar.close);
    const maVal = sma.get(0);
    if (maVal === undefined)
      return;
    const upperEnv = maVal * (1 + this.params.envelope_pct);
    const lowerEnv = maVal * (1 - this.params.envelope_pct);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperEnv || bar.close >= maVal) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerEnv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v01_114.ts
import * as fs114 from "fs";
import * as path114 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams114 = {
  channel_period: 4,
  channel_width: 0.3,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.08
};
function loadSavedParams114() {
  const paramsPath = path114.join(__dirname, "strat_chan_v01_114.params.json");
  if (!fs114.existsSync(paramsPath))
    return null;
  try {
    const content = fs114.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams114) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV01Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams114();
    this.params = { ...defaultParams114, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v02_115.ts
import * as fs115 from "fs";
import * as path115 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams115 = {
  channel_period: 5,
  channel_width: 0.4,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams115() {
  const paramsPath = path115.join(__dirname, "strat_chan_v02_115.params.json");
  if (!fs115.existsSync(paramsPath))
    return null;
  try {
    const content = fs115.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams115) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV02Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams115();
    this.params = { ...defaultParams115, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v03_116.ts
import * as fs116 from "fs";
import * as path116 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams116 = {
  channel_period: 5,
  channel_width: 0.5,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams116() {
  const paramsPath = path116.join(__dirname, "strat_chan_v03_116.params.json");
  if (!fs116.existsSync(paramsPath))
    return null;
  try {
    const content = fs116.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams116) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV03Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams116();
    this.params = { ...defaultParams116, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v04_117.ts
import * as fs117 from "fs";
import * as path117 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams117 = {
  channel_period: 5,
  channel_width: 0.7,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams117() {
  const paramsPath = path117.join(__dirname, "strat_chan_v04_117.params.json");
  if (!fs117.existsSync(paramsPath))
    return null;
  try {
    const content = fs117.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams117) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV04Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams117();
    this.params = { ...defaultParams117, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v05_118.ts
import * as fs118 from "fs";
import * as path118 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams118 = {
  channel_period: 8,
  channel_width: 0.4,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams118() {
  const paramsPath = path118.join(__dirname, "strat_chan_v05_118.params.json");
  if (!fs118.existsSync(paramsPath))
    return null;
  try {
    const content = fs118.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams118) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV05Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams118();
    this.params = { ...defaultParams118, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v06_119.ts
import * as fs119 from "fs";
import * as path119 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams119 = {
  channel_period: 8,
  channel_width: 0.5,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams119() {
  const paramsPath = path119.join(__dirname, "strat_chan_v06_119.params.json");
  if (!fs119.existsSync(paramsPath))
    return null;
  try {
    const content = fs119.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams119) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV06Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams119();
    this.params = { ...defaultParams119, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v07_120.ts
import * as fs120 from "fs";
import * as path120 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams120 = {
  channel_period: 8,
  channel_width: 0.8,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.18
};
function loadSavedParams120() {
  const paramsPath = path120.join(__dirname, "strat_chan_v07_120.params.json");
  if (!fs120.existsSync(paramsPath))
    return null;
  try {
    const content = fs120.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams120) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV07Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams120();
    this.params = { ...defaultParams120, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v08_121.ts
import * as fs121 from "fs";
import * as path121 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams121 = {
  channel_period: 12,
  channel_width: 0.4,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.1
};
function loadSavedParams121() {
  const paramsPath = path121.join(__dirname, "strat_chan_v08_121.params.json");
  if (!fs121.existsSync(paramsPath))
    return null;
  try {
    const content = fs121.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams121) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV08Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams121();
    this.params = { ...defaultParams121, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v09_122.ts
import * as fs122 from "fs";
import * as path122 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams122 = {
  channel_period: 12,
  channel_width: 0.6,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams122() {
  const paramsPath = path122.join(__dirname, "strat_chan_v09_122.params.json");
  if (!fs122.existsSync(paramsPath))
    return null;
  try {
    const content = fs122.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams122) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV09Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams122();
    this.params = { ...defaultParams122, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v10_123.ts
import * as fs123 from "fs";
import * as path123 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams123 = {
  channel_period: 12,
  channel_width: 0.9,
  stop_loss: 0.1,
  trailing_stop: 0.07,
  risk_percent: 0.2
};
function loadSavedParams123() {
  const paramsPath = path123.join(__dirname, "strat_chan_v10_123.params.json");
  if (!fs123.existsSync(paramsPath))
    return null;
  try {
    const content = fs123.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams123) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV10Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams123();
    this.params = { ...defaultParams123, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v11_124.ts
import * as fs124 from "fs";
import * as path124 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams124 = {
  channel_period: 4,
  channel_width: 0.3,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.25
};
function loadSavedParams124() {
  const paramsPath = path124.join(__dirname, "strat_chan_v11_124.params.json");
  if (!fs124.existsSync(paramsPath))
    return null;
  try {
    const content = fs124.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams124) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV11Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams124();
    this.params = { ...defaultParams124, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v12_125.ts
import * as fs125 from "fs";
import * as path125 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams125 = {
  channel_period: 15,
  channel_width: 0.7,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.05
};
function loadSavedParams125() {
  const paramsPath = path125.join(__dirname, "strat_chan_v12_125.params.json");
  if (!fs125.existsSync(paramsPath))
    return null;
  try {
    const content = fs125.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams125) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV12Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams125();
    this.params = { ...defaultParams125, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v13_126.ts
import * as fs126 from "fs";
import * as path126 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams126 = {
  channel_period: 7,
  channel_width: 0.5,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams126() {
  const paramsPath = path126.join(__dirname, "strat_chan_v13_126.params.json");
  if (!fs126.existsSync(paramsPath))
    return null;
  try {
    const content = fs126.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams126) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV13Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams126();
    this.params = { ...defaultParams126, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v14_127.ts
import * as fs127 from "fs";
import * as path127 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams127 = {
  channel_period: 9,
  channel_width: 0.6,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  risk_percent: 0.14
};
function loadSavedParams127() {
  const paramsPath = path127.join(__dirname, "strat_chan_v14_127.params.json");
  if (!fs127.existsSync(paramsPath))
    return null;
  try {
    const content = fs127.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams127) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV14Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams127();
    this.params = { ...defaultParams127, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v15_128.ts
import * as fs128 from "fs";
import * as path128 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams128 = {
  channel_period: 7,
  channel_width: 0.5,
  stop_loss: 0.02,
  trailing_stop: 0.02,
  risk_percent: 0.1
};
function loadSavedParams128() {
  const paramsPath = path128.join(__dirname, "strat_chan_v15_128.params.json");
  if (!fs128.existsSync(paramsPath))
    return null;
  try {
    const content = fs128.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams128) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV15Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams128();
    this.params = { ...defaultParams128, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v16_129.ts
import * as fs129 from "fs";
import * as path129 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams129 = {
  channel_period: 7,
  channel_width: 0.5,
  stop_loss: 0.12,
  trailing_stop: 0.08,
  risk_percent: 0.1
};
function loadSavedParams129() {
  const paramsPath = path129.join(__dirname, "strat_chan_v16_129.params.json");
  if (!fs129.existsSync(paramsPath))
    return null;
  try {
    const content = fs129.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams129) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV16Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams129();
    this.params = { ...defaultParams129, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v17_130.ts
import * as fs130 from "fs";
import * as path130 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams130 = {
  channel_period: 6,
  channel_width: 0.5,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.3
};
function loadSavedParams130() {
  const paramsPath = path130.join(__dirname, "strat_chan_v17_130.params.json");
  if (!fs130.existsSync(paramsPath))
    return null;
  try {
    const content = fs130.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams130) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV17Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams130();
    this.params = { ...defaultParams130, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v18_131.ts
import * as fs131 from "fs";
import * as path131 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams131 = {
  channel_period: 6,
  channel_width: 0.5,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.05
};
function loadSavedParams131() {
  const paramsPath = path131.join(__dirname, "strat_chan_v18_131.params.json");
  if (!fs131.existsSync(paramsPath))
    return null;
  try {
    const content = fs131.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams131) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV18Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams131();
    this.params = { ...defaultParams131, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v19_132.ts
import * as fs132 from "fs";
import * as path132 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams132 = {
  channel_period: 3,
  channel_width: 0.2,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.08
};
function loadSavedParams132() {
  const paramsPath = path132.join(__dirname, "strat_chan_v19_132.params.json");
  if (!fs132.existsSync(paramsPath))
    return null;
  try {
    const content = fs132.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams132) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV19Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams132();
    this.params = { ...defaultParams132, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_chan_v20_133.ts
import * as fs133 from "fs";
import * as path133 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams133 = {
  channel_period: 18,
  channel_width: 1,
  stop_loss: 0.1,
  trailing_stop: 0.07,
  risk_percent: 0.15
};
function loadSavedParams133() {
  const paramsPath = path133.join(__dirname, "strat_chan_v20_133.params.json");
  if (!fs133.existsSync(paramsPath))
    return null;
  try {
    const content = fs133.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams133) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChanV20Strategy {
  params;
  smaMap = new Map;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams133();
    this.params = { ...defaultParams133, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.channel_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.priceHistory.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const history = this.priceHistory.get(bar.tokenId);
    sma.update(bar.close);
    history.push(bar.close);
    if (history.length > period)
      history.shift();
    const maVal = sma.get(0);
    if (maVal === undefined || history.length < period)
      return;
    const high = Math.max(...history);
    const low = Math.min(...history);
    const range = high - low;
    const upperChannel = maVal + range * this.params.channel_width;
    const lowerChannel = maVal - range * this.params.channel_width;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperChannel) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerChannel) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v01_134.ts
import * as fs134 from "fs";
import * as path134 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams134 = {
  bb_period: 4,
  rsi_period: 3,
  std_mult: 1.5,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams134() {
  const paramsPath = path134.join(__dirname, "strat_combo_v01_134.params.json");
  if (!fs134.existsSync(paramsPath))
    return null;
  try {
    const content = fs134.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams134) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev3 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV01Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams134();
    this.params = { ...defaultParams134, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev3(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v02_135.ts
import * as fs135 from "fs";
import * as path135 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams135 = {
  bb_period: 5,
  rsi_period: 3,
  std_mult: 1.8,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams135() {
  const paramsPath = path135.join(__dirname, "strat_combo_v02_135.params.json");
  if (!fs135.existsSync(paramsPath))
    return null;
  try {
    const content = fs135.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams135) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev4 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV02Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams135();
    this.params = { ...defaultParams135, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev4(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v03_136.ts
import * as fs136 from "fs";
import * as path136 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams136 = {
  bb_period: 6,
  rsi_period: 4,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams136() {
  const paramsPath = path136.join(__dirname, "strat_combo_v03_136.params.json");
  if (!fs136.existsSync(paramsPath))
    return null;
  try {
    const content = fs136.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams136) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev5 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV03Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams136();
    this.params = { ...defaultParams136, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev5(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v04_137.ts
import * as fs137 from "fs";
import * as path137 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams137 = {
  bb_period: 6,
  rsi_period: 5,
  std_mult: 2.5,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams137() {
  const paramsPath = path137.join(__dirname, "strat_combo_v04_137.params.json");
  if (!fs137.existsSync(paramsPath))
    return null;
  try {
    const content = fs137.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams137) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev6 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV04Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams137();
    this.params = { ...defaultParams137, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev6(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v05_138.ts
import * as fs138 from "fs";
import * as path138 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams138 = {
  bb_period: 8,
  rsi_period: 5,
  std_mult: 1.5,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams138() {
  const paramsPath = path138.join(__dirname, "strat_combo_v05_138.params.json");
  if (!fs138.existsSync(paramsPath))
    return null;
  try {
    const content = fs138.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams138) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev7 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV05Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams138();
    this.params = { ...defaultParams138, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev7(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v06_139.ts
import * as fs139 from "fs";
import * as path139 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams139 = {
  bb_period: 8,
  rsi_period: 6,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams139() {
  const paramsPath = path139.join(__dirname, "strat_combo_v06_139.params.json");
  if (!fs139.existsSync(paramsPath))
    return null;
  try {
    const content = fs139.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams139) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev8 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV06Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams139();
    this.params = { ...defaultParams139, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev8(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v07_140.ts
import * as fs140 from "fs";
import * as path140 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams140 = {
  bb_period: 10,
  rsi_period: 7,
  std_mult: 2.5,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.08,
  risk_percent: 0.18
};
function loadSavedParams140() {
  const paramsPath = path140.join(__dirname, "strat_combo_v07_140.params.json");
  if (!fs140.existsSync(paramsPath))
    return null;
  try {
    const content = fs140.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams140) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev9 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV07Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams140();
    this.params = { ...defaultParams140, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev9(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v08_141.ts
import * as fs141 from "fs";
import * as path141 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams141 = {
  bb_period: 12,
  rsi_period: 7,
  std_mult: 1.5,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams141() {
  const paramsPath = path141.join(__dirname, "strat_combo_v08_141.params.json");
  if (!fs141.existsSync(paramsPath))
    return null;
  try {
    const content = fs141.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams141) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev10 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV08Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams141();
    this.params = { ...defaultParams141, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev10(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v09_142.ts
import * as fs142 from "fs";
import * as path142 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams142 = {
  bb_period: 12,
  rsi_period: 8,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams142() {
  const paramsPath = path142.join(__dirname, "strat_combo_v09_142.params.json");
  if (!fs142.existsSync(paramsPath))
    return null;
  try {
    const content = fs142.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams142) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev11 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV09Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams142();
    this.params = { ...defaultParams142, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev11(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v10_143.ts
import * as fs143 from "fs";
import * as path143 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams143 = {
  bb_period: 15,
  rsi_period: 9,
  std_mult: 2.5,
  rsi_oversold: 20,
  rsi_overbought: 80,
  stop_loss: 0.1,
  risk_percent: 0.2
};
function loadSavedParams143() {
  const paramsPath = path143.join(__dirname, "strat_combo_v10_143.params.json");
  if (!fs143.existsSync(paramsPath))
    return null;
  try {
    const content = fs143.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams143) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev12 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV10Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams143();
    this.params = { ...defaultParams143, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev12(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v11_144.ts
import * as fs144 from "fs";
import * as path144 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams144 = {
  bb_period: 4,
  rsi_period: 3,
  std_mult: 1.3,
  rsi_oversold: 35,
  rsi_overbought: 65,
  stop_loss: 0.06,
  risk_percent: 0.25
};
function loadSavedParams144() {
  const paramsPath = path144.join(__dirname, "strat_combo_v11_144.params.json");
  if (!fs144.existsSync(paramsPath))
    return null;
  try {
    const content = fs144.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams144) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev13 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV11Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams144();
    this.params = { ...defaultParams144, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev13(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v12_145.ts
import * as fs145 from "fs";
import * as path145 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams145 = {
  bb_period: 14,
  rsi_period: 8,
  std_mult: 2.8,
  rsi_oversold: 18,
  rsi_overbought: 82,
  stop_loss: 0.04,
  risk_percent: 0.05
};
function loadSavedParams145() {
  const paramsPath = path145.join(__dirname, "strat_combo_v12_145.params.json");
  if (!fs145.existsSync(paramsPath))
    return null;
  try {
    const content = fs145.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams145) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev14 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV12Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams145();
    this.params = { ...defaultParams145, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev14(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v13_146.ts
import * as fs146 from "fs";
import * as path146 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams146 = {
  bb_period: 7,
  rsi_period: 5,
  std_mult: 1.8,
  rsi_oversold: 28,
  rsi_overbought: 72,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams146() {
  const paramsPath = path146.join(__dirname, "strat_combo_v13_146.params.json");
  if (!fs146.existsSync(paramsPath))
    return null;
  try {
    const content = fs146.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams146) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev15 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV13Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams146();
    this.params = { ...defaultParams146, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev15(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v14_147.ts
import * as fs147 from "fs";
import * as path147 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams147 = {
  bb_period: 9,
  rsi_period: 6,
  std_mult: 2.2,
  rsi_oversold: 26,
  rsi_overbought: 74,
  stop_loss: 0.06,
  risk_percent: 0.14
};
function loadSavedParams147() {
  const paramsPath = path147.join(__dirname, "strat_combo_v14_147.params.json");
  if (!fs147.existsSync(paramsPath))
    return null;
  try {
    const content = fs147.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams147) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev16 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV14Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams147();
    this.params = { ...defaultParams147, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev16(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v15_148.ts
import * as fs148 from "fs";
import * as path148 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams148 = {
  bb_period: 6,
  rsi_period: 4,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.02,
  risk_percent: 0.1
};
function loadSavedParams148() {
  const paramsPath = path148.join(__dirname, "strat_combo_v15_148.params.json");
  if (!fs148.existsSync(paramsPath))
    return null;
  try {
    const content = fs148.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams148) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev17 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV15Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams148();
    this.params = { ...defaultParams148, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev17(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v16_149.ts
import * as fs149 from "fs";
import * as path149 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams149 = {
  bb_period: 6,
  rsi_period: 4,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.12,
  risk_percent: 0.1
};
function loadSavedParams149() {
  const paramsPath = path149.join(__dirname, "strat_combo_v16_149.params.json");
  if (!fs149.existsSync(paramsPath))
    return null;
  try {
    const content = fs149.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams149) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev18 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV16Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams149();
    this.params = { ...defaultParams149, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev18(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v17_150.ts
import * as fs150 from "fs";
import * as path150 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams150 = {
  bb_period: 7,
  rsi_period: 5,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.3
};
function loadSavedParams150() {
  const paramsPath = path150.join(__dirname, "strat_combo_v17_150.params.json");
  if (!fs150.existsSync(paramsPath))
    return null;
  try {
    const content = fs150.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams150) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev19 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV17Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams150();
    this.params = { ...defaultParams150, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev19(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v18_151.ts
import * as fs151 from "fs";
import * as path151 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams151 = {
  bb_period: 7,
  rsi_period: 5,
  std_mult: 2,
  rsi_oversold: 25,
  rsi_overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.05
};
function loadSavedParams151() {
  const paramsPath = path151.join(__dirname, "strat_combo_v18_151.params.json");
  if (!fs151.existsSync(paramsPath))
    return null;
  try {
    const content = fs151.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams151) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev20 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV18Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams151();
    this.params = { ...defaultParams151, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev20(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v19_152.ts
import * as fs152 from "fs";
import * as path152 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams152 = {
  bb_period: 3,
  rsi_period: 3,
  std_mult: 1.2,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams152() {
  const paramsPath = path152.join(__dirname, "strat_combo_v19_152.params.json");
  if (!fs152.existsSync(paramsPath))
    return null;
  try {
    const content = fs152.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams152) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev21 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV19Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams152();
    this.params = { ...defaultParams152, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev21(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_combo_v20_153.ts
import * as fs153 from "fs";
import * as path153 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams153 = {
  bb_period: 18,
  rsi_period: 10,
  std_mult: 3,
  rsi_oversold: 15,
  rsi_overbought: 85,
  stop_loss: 0.1,
  risk_percent: 0.15
};
function loadSavedParams153() {
  const paramsPath = path153.join(__dirname, "strat_combo_v20_153.params.json");
  if (!fs153.existsSync(paramsPath))
    return null;
  try {
    const content = fs153.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams153) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StdDev22 {
  prices = [];
  period;
  constructor(period) {
    this.period = period;
  }
  update(price) {
    this.prices.push(price);
    if (this.prices.length > this.period)
      this.prices.shift();
  }
  get() {
    if (this.prices.length < this.period)
      return;
    const mean = this.prices.reduce((a, b) => a + b, 0) / this.prices.length;
    return Math.sqrt(this.prices.reduce((s, p) => s + (p - mean) ** 2, 0) / this.prices.length);
  }
}

class ComboV20Strategy {
  params;
  smaMap = new Map;
  stdMap = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams153();
    this.params = { ...defaultParams153, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.stdMap.set(bar.tokenId, new StdDev22(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
    }
    const sma = this.smaMap.get(bar.tokenId);
    const std = this.stdMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    sma.update(bar.close);
    std.update(bar.close);
    rsi.update(bar.close);
    const maVal = sma.get(0);
    const stdVal = std.get();
    const rsiVal = rsi.get(0);
    if (maVal === undefined || stdVal === undefined || rsiVal === undefined)
      return;
    const lowerBand = maVal - this.params.std_mult * stdVal;
    const upperBand = maVal + this.params.std_mult * stdVal;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= upperBand || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.9) {
      if (bar.close <= lowerBand && rsiVal <= this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v01_154.ts
import * as fs154 from "fs";
import * as path154 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams154 = {
  k_period: 3,
  d_period: 2,
  oversold: 15,
  overbought: 85,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams154() {
  const paramsPath = path154.join(__dirname, "strat_stoch_v01_154.params.json");
  if (!fs154.existsSync(paramsPath))
    return null;
  try {
    const content = fs154.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams154) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV01Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams154();
    this.params = { ...defaultParams154, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v02_155.ts
import * as fs155 from "fs";
import * as path155 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams155 = {
  k_period: 4,
  d_period: 2,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams155() {
  const paramsPath = path155.join(__dirname, "strat_stoch_v02_155.params.json");
  if (!fs155.existsSync(paramsPath))
    return null;
  try {
    const content = fs155.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams155) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV02Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams155();
    this.params = { ...defaultParams155, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v03_156.ts
import * as fs156 from "fs";
import * as path156 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams156 = {
  k_period: 5,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams156() {
  const paramsPath = path156.join(__dirname, "strat_stoch_v03_156.params.json");
  if (!fs156.existsSync(paramsPath))
    return null;
  try {
    const content = fs156.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams156) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV03Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams156();
    this.params = { ...defaultParams156, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v04_157.ts
import * as fs157 from "fs";
import * as path157 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams157 = {
  k_period: 5,
  d_period: 3,
  oversold: 15,
  overbought: 85,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams157() {
  const paramsPath = path157.join(__dirname, "strat_stoch_v04_157.params.json");
  if (!fs157.existsSync(paramsPath))
    return null;
  try {
    const content = fs157.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams157) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV04Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams157();
    this.params = { ...defaultParams157, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v05_158.ts
import * as fs158 from "fs";
import * as path158 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams158 = {
  k_period: 7,
  d_period: 3,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams158() {
  const paramsPath = path158.join(__dirname, "strat_stoch_v05_158.params.json");
  if (!fs158.existsSync(paramsPath))
    return null;
  try {
    const content = fs158.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams158) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV05Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams158();
    this.params = { ...defaultParams158, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v06_159.ts
import * as fs159 from "fs";
import * as path159 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams159 = {
  k_period: 8,
  d_period: 4,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams159() {
  const paramsPath = path159.join(__dirname, "strat_stoch_v06_159.params.json");
  if (!fs159.existsSync(paramsPath))
    return null;
  try {
    const content = fs159.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams159) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV06Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams159();
    this.params = { ...defaultParams159, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v07_160.ts
import * as fs160 from "fs";
import * as path160 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams160 = {
  k_period: 10,
  d_period: 4,
  oversold: 15,
  overbought: 85,
  stop_loss: 0.08,
  risk_percent: 0.18
};
function loadSavedParams160() {
  const paramsPath = path160.join(__dirname, "strat_stoch_v07_160.params.json");
  if (!fs160.existsSync(paramsPath))
    return null;
  try {
    const content = fs160.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams160) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV07Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams160();
    this.params = { ...defaultParams160, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v08_161.ts
import * as fs161 from "fs";
import * as path161 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams161 = {
  k_period: 12,
  d_period: 5,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams161() {
  const paramsPath = path161.join(__dirname, "strat_stoch_v08_161.params.json");
  if (!fs161.existsSync(paramsPath))
    return null;
  try {
    const content = fs161.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams161) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV08Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams161();
    this.params = { ...defaultParams161, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v09_162.ts
import * as fs162 from "fs";
import * as path162 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams162 = {
  k_period: 12,
  d_period: 5,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams162() {
  const paramsPath = path162.join(__dirname, "strat_stoch_v09_162.params.json");
  if (!fs162.existsSync(paramsPath))
    return null;
  try {
    const content = fs162.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams162) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV09Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams162();
    this.params = { ...defaultParams162, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v10_163.ts
import * as fs163 from "fs";
import * as path163 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams163 = {
  k_period: 14,
  d_period: 6,
  oversold: 15,
  overbought: 85,
  stop_loss: 0.1,
  risk_percent: 0.2
};
function loadSavedParams163() {
  const paramsPath = path163.join(__dirname, "strat_stoch_v10_163.params.json");
  if (!fs163.existsSync(paramsPath))
    return null;
  try {
    const content = fs163.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams163) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV10Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams163();
    this.params = { ...defaultParams163, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v11_164.ts
import * as fs164 from "fs";
import * as path164 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams164 = {
  k_period: 3,
  d_period: 2,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.06,
  risk_percent: 0.25
};
function loadSavedParams164() {
  const paramsPath = path164.join(__dirname, "strat_stoch_v11_164.params.json");
  if (!fs164.existsSync(paramsPath))
    return null;
  try {
    const content = fs164.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams164) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV11Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams164();
    this.params = { ...defaultParams164, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v12_165.ts
import * as fs165 from "fs";
import * as path165 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams165 = {
  k_period: 14,
  d_period: 6,
  oversold: 10,
  overbought: 90,
  stop_loss: 0.04,
  risk_percent: 0.05
};
function loadSavedParams165() {
  const paramsPath = path165.join(__dirname, "strat_stoch_v12_165.params.json");
  if (!fs165.existsSync(paramsPath))
    return null;
  try {
    const content = fs165.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams165) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV12Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams165();
    this.params = { ...defaultParams165, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v13_166.ts
import * as fs166 from "fs";
import * as path166 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams166 = {
  k_period: 6,
  d_period: 3,
  oversold: 22,
  overbought: 78,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams166() {
  const paramsPath = path166.join(__dirname, "strat_stoch_v13_166.params.json");
  if (!fs166.existsSync(paramsPath))
    return null;
  try {
    const content = fs166.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams166) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV13Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams166();
    this.params = { ...defaultParams166, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v14_167.ts
import * as fs167 from "fs";
import * as path167 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams167 = {
  k_period: 9,
  d_period: 4,
  oversold: 18,
  overbought: 82,
  stop_loss: 0.06,
  risk_percent: 0.14
};
function loadSavedParams167() {
  const paramsPath = path167.join(__dirname, "strat_stoch_v14_167.params.json");
  if (!fs167.existsSync(paramsPath))
    return null;
  try {
    const content = fs167.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams167) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV14Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams167();
    this.params = { ...defaultParams167, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v15_168.ts
import * as fs168 from "fs";
import * as path168 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams168 = {
  k_period: 6,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.02,
  risk_percent: 0.1
};
function loadSavedParams168() {
  const paramsPath = path168.join(__dirname, "strat_stoch_v15_168.params.json");
  if (!fs168.existsSync(paramsPath))
    return null;
  try {
    const content = fs168.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams168) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV15Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams168();
    this.params = { ...defaultParams168, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v16_169.ts
import * as fs169 from "fs";
import * as path169 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams169 = {
  k_period: 6,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.12,
  risk_percent: 0.1
};
function loadSavedParams169() {
  const paramsPath = path169.join(__dirname, "strat_stoch_v16_169.params.json");
  if (!fs169.existsSync(paramsPath))
    return null;
  try {
    const content = fs169.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams169) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV16Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams169();
    this.params = { ...defaultParams169, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v17_170.ts
import * as fs170 from "fs";
import * as path170 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams170 = {
  k_period: 7,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.06,
  risk_percent: 0.3
};
function loadSavedParams170() {
  const paramsPath = path170.join(__dirname, "strat_stoch_v17_170.params.json");
  if (!fs170.existsSync(paramsPath))
    return null;
  try {
    const content = fs170.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams170) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV17Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams170();
    this.params = { ...defaultParams170, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v18_171.ts
import * as fs171 from "fs";
import * as path171 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams171 = {
  k_period: 7,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.06,
  risk_percent: 0.05
};
function loadSavedParams171() {
  const paramsPath = path171.join(__dirname, "strat_stoch_v18_171.params.json");
  if (!fs171.existsSync(paramsPath))
    return null;
  try {
    const content = fs171.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams171) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV18Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams171();
    this.params = { ...defaultParams171, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v19_172.ts
import * as fs172 from "fs";
import * as path172 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams172 = {
  k_period: 3,
  d_period: 2,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams172() {
  const paramsPath = path172.join(__dirname, "strat_stoch_v19_172.params.json");
  if (!fs172.existsSync(paramsPath))
    return null;
  try {
    const content = fs172.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams172) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV19Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams172();
    this.params = { ...defaultParams172, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v20_173.ts
import * as fs173 from "fs";
import * as path173 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams173 = {
  k_period: 18,
  d_period: 7,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams173() {
  const paramsPath = path173.join(__dirname, "strat_stoch_v20_173.params.json");
  if (!fs173.existsSync(paramsPath))
    return null;
  try {
    const content = fs173.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams173) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV20Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams173();
    this.params = { ...defaultParams173, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v01_174.ts
import * as fs174 from "fs";
import * as path174 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams174 = {
  consec_bars: 2,
  exit_bars: 1,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.08
};
function loadSavedParams174() {
  const paramsPath = path174.join(__dirname, "strat_pat_v01_174.params.json");
  if (!fs174.existsSync(paramsPath))
    return null;
  try {
    const content = fs174.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams174) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV01Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams174();
    this.params = { ...defaultParams174, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v02_175.ts
import * as fs175 from "fs";
import * as path175 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams175 = {
  consec_bars: 2,
  exit_bars: 2,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams175() {
  const paramsPath = path175.join(__dirname, "strat_pat_v02_175.params.json");
  if (!fs175.existsSync(paramsPath))
    return null;
  try {
    const content = fs175.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams175) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV02Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams175();
    this.params = { ...defaultParams175, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v03_176.ts
import * as fs176 from "fs";
import * as path176 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams176 = {
  consec_bars: 3,
  exit_bars: 1,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams176() {
  const paramsPath = path176.join(__dirname, "strat_pat_v03_176.params.json");
  if (!fs176.existsSync(paramsPath))
    return null;
  try {
    const content = fs176.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams176) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV03Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams176();
    this.params = { ...defaultParams176, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v04_177.ts
import * as fs177 from "fs";
import * as path177 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams177 = {
  consec_bars: 3,
  exit_bars: 2,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams177() {
  const paramsPath = path177.join(__dirname, "strat_pat_v04_177.params.json");
  if (!fs177.existsSync(paramsPath))
    return null;
  try {
    const content = fs177.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams177) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV04Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams177();
    this.params = { ...defaultParams177, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v05_178.ts
import * as fs178 from "fs";
import * as path178 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams178 = {
  consec_bars: 3,
  exit_bars: 3,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams178() {
  const paramsPath = path178.join(__dirname, "strat_pat_v05_178.params.json");
  if (!fs178.existsSync(paramsPath))
    return null;
  try {
    const content = fs178.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams178) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV05Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams178();
    this.params = { ...defaultParams178, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v06_179.ts
import * as fs179 from "fs";
import * as path179 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams179 = {
  consec_bars: 4,
  exit_bars: 1,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams179() {
  const paramsPath = path179.join(__dirname, "strat_pat_v06_179.params.json");
  if (!fs179.existsSync(paramsPath))
    return null;
  try {
    const content = fs179.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams179) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV06Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams179();
    this.params = { ...defaultParams179, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v07_180.ts
import * as fs180 from "fs";
import * as path180 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams180 = {
  consec_bars: 4,
  exit_bars: 2,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.18
};
function loadSavedParams180() {
  const paramsPath = path180.join(__dirname, "strat_pat_v07_180.params.json");
  if (!fs180.existsSync(paramsPath))
    return null;
  try {
    const content = fs180.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams180) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV07Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams180();
    this.params = { ...defaultParams180, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v08_181.ts
import * as fs181 from "fs";
import * as path181 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams181 = {
  consec_bars: 4,
  exit_bars: 3,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.18
};
function loadSavedParams181() {
  const paramsPath = path181.join(__dirname, "strat_pat_v08_181.params.json");
  if (!fs181.existsSync(paramsPath))
    return null;
  try {
    const content = fs181.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams181) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV08Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams181();
    this.params = { ...defaultParams181, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v09_182.ts
import * as fs182 from "fs";
import * as path182 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams182 = {
  consec_bars: 5,
  exit_bars: 2,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  risk_percent: 0.15
};
function loadSavedParams182() {
  const paramsPath = path182.join(__dirname, "strat_pat_v09_182.params.json");
  if (!fs182.existsSync(paramsPath))
    return null;
  try {
    const content = fs182.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams182) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV09Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams182();
    this.params = { ...defaultParams182, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v10_183.ts
import * as fs183 from "fs";
import * as path183 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams183 = {
  consec_bars: 5,
  exit_bars: 3,
  stop_loss: 0.1,
  trailing_stop: 0.07,
  risk_percent: 0.2
};
function loadSavedParams183() {
  const paramsPath = path183.join(__dirname, "strat_pat_v10_183.params.json");
  if (!fs183.existsSync(paramsPath))
    return null;
  try {
    const content = fs183.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams183) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV10Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams183();
    this.params = { ...defaultParams183, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v11_184.ts
import * as fs184 from "fs";
import * as path184 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams184 = {
  consec_bars: 2,
  exit_bars: 1,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.25
};
function loadSavedParams184() {
  const paramsPath = path184.join(__dirname, "strat_pat_v11_184.params.json");
  if (!fs184.existsSync(paramsPath))
    return null;
  try {
    const content = fs184.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams184) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV11Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams184();
    this.params = { ...defaultParams184, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v12_185.ts
import * as fs185 from "fs";
import * as path185 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams185 = {
  consec_bars: 4,
  exit_bars: 3,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.05
};
function loadSavedParams185() {
  const paramsPath = path185.join(__dirname, "strat_pat_v12_185.params.json");
  if (!fs185.existsSync(paramsPath))
    return null;
  try {
    const content = fs185.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams185) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV12Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams185();
    this.params = { ...defaultParams185, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v13_186.ts
import * as fs186 from "fs";
import * as path186 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams186 = {
  consec_bars: 3,
  exit_bars: 2,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.12
};
function loadSavedParams186() {
  const paramsPath = path186.join(__dirname, "strat_pat_v13_186.params.json");
  if (!fs186.existsSync(paramsPath))
    return null;
  try {
    const content = fs186.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams186) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV13Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams186();
    this.params = { ...defaultParams186, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v14_187.ts
import * as fs187 from "fs";
import * as path187 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams187 = {
  consec_bars: 3,
  exit_bars: 1,
  stop_loss: 0.06,
  trailing_stop: 0.04,
  risk_percent: 0.14
};
function loadSavedParams187() {
  const paramsPath = path187.join(__dirname, "strat_pat_v14_187.params.json");
  if (!fs187.existsSync(paramsPath))
    return null;
  try {
    const content = fs187.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams187) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV14Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams187();
    this.params = { ...defaultParams187, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v15_188.ts
import * as fs188 from "fs";
import * as path188 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams188 = {
  consec_bars: 3,
  exit_bars: 2,
  stop_loss: 0.02,
  trailing_stop: 0.02,
  risk_percent: 0.1
};
function loadSavedParams188() {
  const paramsPath = path188.join(__dirname, "strat_pat_v15_188.params.json");
  if (!fs188.existsSync(paramsPath))
    return null;
  try {
    const content = fs188.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams188) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV15Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams188();
    this.params = { ...defaultParams188, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v16_189.ts
import * as fs189 from "fs";
import * as path189 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams189 = {
  consec_bars: 3,
  exit_bars: 2,
  stop_loss: 0.12,
  trailing_stop: 0.08,
  risk_percent: 0.1
};
function loadSavedParams189() {
  const paramsPath = path189.join(__dirname, "strat_pat_v16_189.params.json");
  if (!fs189.existsSync(paramsPath))
    return null;
  try {
    const content = fs189.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams189) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV16Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams189();
    this.params = { ...defaultParams189, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v17_190.ts
import * as fs190 from "fs";
import * as path190 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams190 = {
  consec_bars: 2,
  exit_bars: 1,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.3
};
function loadSavedParams190() {
  const paramsPath = path190.join(__dirname, "strat_pat_v17_190.params.json");
  if (!fs190.existsSync(paramsPath))
    return null;
  try {
    const content = fs190.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams190) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV17Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams190();
    this.params = { ...defaultParams190, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v18_191.ts
import * as fs191 from "fs";
import * as path191 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams191 = {
  consec_bars: 2,
  exit_bars: 1,
  stop_loss: 0.05,
  trailing_stop: 0.04,
  risk_percent: 0.05
};
function loadSavedParams191() {
  const paramsPath = path191.join(__dirname, "strat_pat_v18_191.params.json");
  if (!fs191.existsSync(paramsPath))
    return null;
  try {
    const content = fs191.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams191) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV18Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams191();
    this.params = { ...defaultParams191, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v19_192.ts
import * as fs192 from "fs";
import * as path192 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams192 = {
  consec_bars: 2,
  exit_bars: 1,
  stop_loss: 0.03,
  trailing_stop: 0.02,
  risk_percent: 0.1
};
function loadSavedParams192() {
  const paramsPath = path192.join(__dirname, "strat_pat_v19_192.params.json");
  if (!fs192.existsSync(paramsPath))
    return null;
  try {
    const content = fs192.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams192) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV19Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams192();
    this.params = { ...defaultParams192, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pat_v20_193.ts
import * as fs193 from "fs";
import * as path193 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams193 = {
  consec_bars: 5,
  exit_bars: 4,
  stop_loss: 0.1,
  trailing_stop: 0.08,
  risk_percent: 0.15
};
function loadSavedParams193() {
  const paramsPath = path193.join(__dirname, "strat_pat_v20_193.params.json");
  if (!fs193.existsSync(paramsPath))
    return null;
  try {
    const content = fs193.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams193) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PatV20Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams193();
    this.params = { ...defaultParams193, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId))
      this.priceHistory.set(bar.tokenId, []);
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const required = Math.max(3, Math.floor(this.params.consec_bars)) + 1;
    if (history.length > required + 2)
      history.shift();
    if (history.length < required)
      return;
    let consecUp = 0, consecDown = 0;
    for (let i = history.length - 1;i > 0; i--) {
      if (history[i] > history[i - 1]) {
        if (consecDown > 0)
          break;
        consecUp++;
      } else if (history[i] < history[i - 1]) {
        if (consecUp > 0)
          break;
        consecDown++;
      } else
        break;
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (consecDown >= Math.floor(this.params.exit_bars)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const buySignal = this.params.buy_on_dip > 0.5 ? consecDown >= Math.floor(this.params.consec_bars) : consecUp >= Math.floor(this.params.consec_bars);
      if (buySignal) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v01_194.ts
import * as fs194 from "fs";
import * as path194 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams194 = {
  rsi_period: 3,
  divergence_lookback: 4,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.03,
  risk_percent: 0.08
};
function loadSavedParams194() {
  const paramsPath = path194.join(__dirname, "strat_rsi_d_v01_194.params.json");
  if (!fs194.existsSync(paramsPath))
    return null;
  try {
    const content = fs194.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams194) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV01Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams194();
    this.params = { ...defaultParams194, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v02_195.ts
import * as fs195 from "fs";
import * as path195 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams195 = {
  rsi_period: 4,
  divergence_lookback: 5,
  oversold: 30,
  overbought: 70,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams195() {
  const paramsPath = path195.join(__dirname, "strat_rsi_d_v02_195.params.json");
  if (!fs195.existsSync(paramsPath))
    return null;
  try {
    const content = fs195.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams195) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV02Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams195();
    this.params = { ...defaultParams195, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v03_196.ts
import * as fs196 from "fs";
import * as path196 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams196 = {
  rsi_period: 6,
  divergence_lookback: 7,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams196() {
  const paramsPath = path196.join(__dirname, "strat_rsi_d_v03_196.params.json");
  if (!fs196.existsSync(paramsPath))
    return null;
  try {
    const content = fs196.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams196) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV03Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams196();
    this.params = { ...defaultParams196, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v04_197.ts
import * as fs197 from "fs";
import * as path197 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams197 = {
  rsi_period: 8,
  divergence_lookback: 10,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams197() {
  const paramsPath = path197.join(__dirname, "strat_rsi_d_v04_197.params.json");
  if (!fs197.existsSync(paramsPath))
    return null;
  try {
    const content = fs197.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams197) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV04Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams197();
    this.params = { ...defaultParams197, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v05_198.ts
import * as fs198 from "fs";
import * as path198 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams198 = {
  rsi_period: 4,
  divergence_lookback: 5,
  oversold: 30,
  overbought: 70,
  stop_loss: 0.06,
  risk_percent: 0.25
};
function loadSavedParams198() {
  const paramsPath = path198.join(__dirname, "strat_rsi_d_v05_198.params.json");
  if (!fs198.existsSync(paramsPath))
    return null;
  try {
    const content = fs198.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams198) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV05Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams198();
    this.params = { ...defaultParams198, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v06_199.ts
import * as fs199 from "fs";
import * as path199 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams199 = {
  rsi_period: 10,
  divergence_lookback: 12,
  oversold: 18,
  overbought: 82,
  stop_loss: 0.04,
  risk_percent: 0.05
};
function loadSavedParams199() {
  const paramsPath = path199.join(__dirname, "strat_rsi_d_v06_199.params.json");
  if (!fs199.existsSync(paramsPath))
    return null;
  try {
    const content = fs199.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams199) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV06Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams199();
    this.params = { ...defaultParams199, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_d_v07_200.ts
import * as fs200 from "fs";
import * as path200 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams200 = {
  rsi_period: 6,
  divergence_lookback: 8,
  oversold: 25,
  overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.12
};
function loadSavedParams200() {
  const paramsPath = path200.join(__dirname, "strat_rsi_d_v07_200.params.json");
  if (!fs200.existsSync(paramsPath))
    return null;
  try {
    const content = fs200.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams200) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiDV07Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams200();
    this.params = { ...defaultParams200, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    if (prices.length < this.params.divergence_lookback)
      return;
    const priceLow = Math.min(...prices.slice(0, -1));
    const rsiLow = Math.min(...rsis.slice(0, -1));
    const bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bullishDiv) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v20_tweak_201.ts
import * as fs201 from "fs";
import * as path201 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams201 = {
  k_period: 8,
  d_period: 3,
  oversold_base: 20,
  overbought_base: 80,
  volatility_period: 20,
  level_adjustment_factor: 10,
  stop_loss: 0.08,
  risk_percent: 0.15
};
function loadSavedParams201() {
  const paramsPath = path201.join(__dirname, "strat_stoch_v20_tweak_201.params.json");
  if (!fs201.existsSync(paramsPath))
    return null;
  try {
    const content = fs201.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams201) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev6(values) {
  if (values.length < 2)
    return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const sqDiffs = values.reduce((sum, v) => sum + (v - mean) * (v - mean), 0);
  return Math.sqrt(sqDiffs / values.length);
}

class StochV20Tweak201Strategy {
  params;
  priceHistory = new Map;
  highHistory = new Map;
  lowHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams201();
    const merged = { ...defaultParams201, ...savedParams, ...params };
    this.params = merged;
    this.params.k_period = Math.max(6, Math.min(12, Math.floor(this.params.k_period)));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  getVolatilityAdjustedLevels(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.volatility_period) {
      return {
        oversold: this.params.oversold_base,
        overbought: this.params.overbought_base
      };
    }
    const relevantHistory = history.slice(-this.params.volatility_period);
    const vol = stddev6(relevantHistory);
    const meanPrice = relevantHistory.reduce((a, b) => a + b, 0) / relevantHistory.length;
    const volatilityPct = meanPrice > 0 ? vol / meanPrice * 100 : 0;
    const adjustment = volatilityPct * this.params.level_adjustment_factor / 10;
    return {
      oversold: Math.max(5, this.params.oversold_base - adjustment),
      overbought: Math.min(95, this.params.overbought_base + adjustment)
    };
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.highHistory.set(bar.tokenId, []);
      this.lowHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const highHistory = this.highHistory.get(bar.tokenId);
    const lowHistory = this.lowHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    highHistory.push(bar.high);
    lowHistory.push(bar.low);
    const maxPeriod = Math.max(this.params.k_period, this.params.volatility_period);
    if (history.length > maxPeriod)
      history.shift();
    if (highHistory.length > maxPeriod)
      highHistory.shift();
    if (lowHistory.length > maxPeriod)
      lowHistory.shift();
    if (history.length < this.params.k_period)
      return;
    const periodHighs = highHistory.slice(-this.params.k_period);
    const periodLows = lowHistory.slice(-this.params.k_period);
    const highest = Math.max(...periodHighs);
    const lowest = Math.min(...periodLows);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    const { oversold, overbought } = this.getVolatilityAdjustedLevels(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v06_tweak_202.ts
import * as fs202 from "fs";
import * as path202 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams202 = {
  k_period: 12,
  d_period: 5,
  oversold: 15,
  overbought: 85,
  stop_loss: 0.05,
  risk_percent: 0.12,
  ma_period: 20,
  use_trend_filter: true,
  use_mtf_confirmation: true,
  use_dynamic_sizing: true,
  mtf_threshold: 0.5
};
function loadSavedParams202() {
  const paramsPath = path202.join(__dirname, "strat_stoch_v06_tweak_202.params.json");
  if (!fs202.existsSync(paramsPath))
    return null;
  try {
    const content = fs202.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams202) {
        if (typeof value === "number") {
          params[key] = value;
        } else if (typeof value === "boolean") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV06Tweak202Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams202() || {};
    this.params = { ...defaultParams202, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
    this.params.ma_period = Math.max(5, Math.floor(this.params.ma_period));
  }
  onInit(_ctx) {}
  getOrCreateTokenData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        priceHistory: [],
        kValues: [],
        slowKValues: [],
        fastKValues: [],
        maValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calculateStochastic(priceHistory, period) {
    if (priceHistory.length < period)
      return null;
    const relevantHistory = priceHistory.slice(-period);
    const highest = Math.max(...relevantHistory);
    const lowest = Math.min(...relevantHistory);
    if (highest === lowest)
      return 50;
    const currentPrice = priceHistory[priceHistory.length - 1];
    return (currentPrice - lowest) / (highest - lowest) * 100;
  }
  calculateMA(priceHistory, period) {
    if (priceHistory.length < period)
      return null;
    const relevantPrices = priceHistory.slice(-period);
    return relevantPrices.reduce((a, b) => a + b, 0) / period;
  }
  calculateSignalStrength(baseK, slowK, fastK, isOversold) {
    let strength = 1;
    if (this.params.use_mtf_confirmation && slowK !== null && fastK !== null) {
      const slowConfirm = isOversold ? slowK <= this.params.oversold : slowK >= this.params.overbought;
      const fastConfirm = isOversold ? fastK <= this.params.oversold : fastK >= this.params.overbought;
      if (slowConfirm && fastConfirm) {
        strength += this.params.mtf_threshold;
      } else if (slowConfirm || fastConfirm) {
        strength += this.params.mtf_threshold * 0.5;
      }
    }
    const oversoldDepth = isOversold ? Math.max(0, (this.params.oversold - baseK) / this.params.oversold) : Math.max(0, (baseK - this.params.overbought) / (100 - this.params.overbought));
    strength += oversoldDepth * 0.5;
    return Math.min(strength, 2);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateTokenData(bar.tokenId);
    data.priceHistory.push(bar.close);
    const maxPeriod = Math.max(this.params.k_period * 2, this.params.ma_period);
    if (data.priceHistory.length > maxPeriod * 2) {
      data.priceHistory.shift();
    }
    const baseK = this.calculateStochastic(data.priceHistory, this.params.k_period);
    if (baseK === null)
      return;
    data.kValues.push(baseK);
    if (data.kValues.length > this.params.d_period) {
      data.kValues.shift();
    }
    if (this.params.use_mtf_confirmation) {
      const slowK = this.calculateStochastic(data.priceHistory, this.params.k_period * 2);
      const fastK = this.calculateStochastic(data.priceHistory, Math.max(3, Math.floor(this.params.k_period * 0.5)));
      if (slowK !== null) {
        data.slowKValues.push(slowK);
        if (data.slowKValues.length > this.params.d_period)
          data.slowKValues.shift();
      }
      if (fastK !== null) {
        data.fastKValues.push(fastK);
        if (data.fastKValues.length > this.params.d_period)
          data.fastKValues.shift();
      }
    }
    if (this.params.use_trend_filter) {
      const ma = this.calculateMA(data.priceHistory, this.params.ma_period);
      if (ma !== null) {
        data.maValues.push(ma);
        if (data.maValues.length > 5)
          data.maValues.shift();
      }
    }
    if (data.kValues.length < this.params.d_period)
      return;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (baseK >= this.params.overbought && baseK < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      let trendOk = true;
      if (this.params.use_trend_filter && data.maValues.length >= 2) {
        const maDirection = data.maValues[data.maValues.length - 1] > data.maValues[0];
        trendOk = maDirection;
      }
      if (trendOk && baseK <= this.params.oversold && baseK > d) {
        const slowK = data.slowKValues.length > 0 ? data.slowKValues[data.slowKValues.length - 1] : null;
        const fastK = data.fastKValues.length > 0 ? data.fastKValues[data.fastKValues.length - 1] : null;
        const signalStrength = this.calculateSignalStrength(baseK, slowK, fastK, true);
        let positionSize = this.params.risk_percent;
        if (this.params.use_dynamic_sizing) {
          positionSize = Math.min(this.params.risk_percent * signalStrength, 0.25);
        }
        const cash = ctx.getCapital() * positionSize * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v09_tweak_203.ts
import * as fs203 from "fs";
import * as path203 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams203 = {
  k_period: 10,
  d_period: 4,
  oversold: 25,
  overbought: 75,
  rsi_period: 14,
  rsi_oversold_max: 40,
  rsi_overbought_min: 60,
  divergence_lookback: 5,
  enable_divergence: true,
  enable_rsi_confirm: true,
  profit_level_1: 0.05,
  profit_level_2: 0.1,
  partial_close_pct_1: 0.5,
  partial_close_pct_2: 0.5,
  stop_loss: 0.07,
  risk_percent: 0.15
};
function loadSavedParams203() {
  const paramsPath = path203.join(__dirname, "strat_stoch_v09_tweak_203.params.json");
  if (!fs203.existsSync(paramsPath))
    return null;
  try {
    const content = fs203.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams203) {
        if (typeof value === "number" || typeof value === "boolean") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV09Tweak203Strategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  priceKHistory = new Map;
  rsiMap = new Map;
  entryPrice = new Map;
  initialSize = new Map;
  profitLevel1Hit = new Map;
  profitLevel2Hit = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams203();
    const merged = { ...defaultParams203, ...savedParams || {}, ...params };
    this.params = merged;
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
  }
  onInit(_ctx) {}
  calculateStochastic(history) {
    const highest = Math.max(...history);
    const lowest = Math.min(...history);
    return highest === lowest ? 50 : (history[history.length - 1] - lowest) / (highest - lowest) * 100;
  }
  detectBullishDivergence(priceKHist) {
    if (priceKHist.length < this.params.divergence_lookback * 2)
      return false;
    const lookback = this.params.divergence_lookback;
    const recent = priceKHist.slice(-lookback);
    const previous = priceKHist.slice(-lookback * 2, -lookback);
    const recentLowPrice = Math.min(...recent.map((p) => p.price));
    const prevLowPrice = Math.min(...previous.map((p) => p.price));
    const recentLowK = Math.min(...recent.map((p) => p.k));
    const prevLowK = Math.min(...previous.map((p) => p.k));
    const priceMakingLowerLows = recentLowPrice < prevLowPrice * 0.99;
    const stochMakingHigherLows = recentLowK > prevLowK * 1.01;
    return priceMakingLowerLows && stochMakingHigherLows;
  }
  detectBearishDivergence(priceKHist) {
    if (priceKHist.length < this.params.divergence_lookback * 2)
      return false;
    const lookback = this.params.divergence_lookback;
    const recent = priceKHist.slice(-lookback);
    const previous = priceKHist.slice(-lookback * 2, -lookback);
    const recentHighPrice = Math.max(...recent.map((p) => p.price));
    const prevHighPrice = Math.max(...previous.map((p) => p.price));
    const recentHighK = Math.max(...recent.map((p) => p.k));
    const prevHighK = Math.max(...previous.map((p) => p.k));
    const priceMakingHigherHighs = recentHighPrice > prevHighPrice * 1.01;
    const stochMakingLowerHighs = recentHighK < prevHighK * 0.99;
    return priceMakingHigherHighs && stochMakingLowerHighs;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
      this.priceKHistory.set(bar.tokenId, []);
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    const priceKHist = this.priceKHistory.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    history.push(bar.close);
    rsi.update(bar.close);
    if (history.length > this.params.k_period)
      history.shift();
    if (history.length < this.params.k_period)
      return;
    const k = this.calculateStochastic(history);
    kVals.push(k);
    priceKHist.push({ price: bar.close, k });
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (priceKHist.length > this.params.divergence_lookback * 3)
      priceKHist.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const rsiVal = rsi.get(0);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (!entry)
        return;
      if (bar.close < entry * (1 - this.params.stop_loss)) {
        ctx.close(bar.tokenId);
        this.entryPrice.delete(bar.tokenId);
        this.initialSize.delete(bar.tokenId);
        this.profitLevel1Hit.delete(bar.tokenId);
        this.profitLevel2Hit.delete(bar.tokenId);
        return;
      }
      const pl1Hit = this.profitLevel1Hit.get(bar.tokenId) || false;
      const pl2Hit = this.profitLevel2Hit.get(bar.tokenId) || false;
      const initialPosSize = this.initialSize.get(bar.tokenId) || position.size;
      if (!pl1Hit && bar.close >= entry * (1 + this.params.profit_level_1)) {
        const closeSize = initialPosSize * this.params.partial_close_pct_1;
        if (closeSize > 0 && closeSize < position.size) {
          ctx.sell(bar.tokenId, closeSize);
        }
        this.profitLevel1Hit.set(bar.tokenId, true);
      }
      if (pl1Hit && !pl2Hit && bar.close >= entry * (1 + this.params.profit_level_2)) {
        const remainingSize = position.size;
        if (remainingSize > 0) {
          ctx.sell(bar.tokenId, remainingSize);
        }
        this.profitLevel2Hit.set(bar.tokenId, true);
        this.entryPrice.delete(bar.tokenId);
        this.initialSize.delete(bar.tokenId);
        return;
      }
      const bearishDiv = this.params.enable_divergence && this.detectBearishDivergence(priceKHist);
      if (k >= this.params.overbought && k < d && !bearishDiv) {
        ctx.close(bar.tokenId);
        this.entryPrice.delete(bar.tokenId);
        this.initialSize.delete(bar.tokenId);
        this.profitLevel1Hit.delete(bar.tokenId);
        this.profitLevel2Hit.delete(bar.tokenId);
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const stochOversold = k <= this.params.oversold && k > d;
      const bullishDiv = this.params.enable_divergence && this.detectBullishDivergence(priceKHist);
      const rsiConfirm = !this.params.enable_rsi_confirm || rsiVal !== undefined && rsiVal <= this.params.rsi_oversold_max;
      if ((stochOversold || bullishDiv) && rsiConfirm) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.initialSize.set(bar.tokenId, size);
            this.profitLevel1Hit.set(bar.tokenId, false);
            this.profitLevel2Hit.set(bar.tokenId, false);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_adaptive_204.ts
import * as fs204 from "fs";
import * as path204 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams204 = {
  min_k_period: 3,
  max_k_period: 14,
  d_period: 3,
  percentile_lookback: 20,
  oversold_percentile: 15,
  overbought_percentile: 85,
  atr_period: 14,
  min_atr_threshold: 0.005,
  volatility_scale: 50,
  stop_loss: 0.04,
  risk_percent: 0.1
};
function loadSavedParams204() {
  const paramsPath = path204.join(__dirname, "strat_stoch_adaptive_204.params.json");
  if (!fs204.existsSync(paramsPath))
    return null;
  try {
    const content = fs204.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams204) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function percentile(values, p) {
  if (values.length === 0)
    return 50;
  const sorted = [...values].sort((a, b) => a - b);
  const index = p / 100 * (sorted.length - 1);
  const lower = Math.floor(index);
  const upper = Math.ceil(index);
  const weight = index - lower;
  if (upper >= sorted.length)
    return sorted[lower];
  return sorted[lower] * (1 - weight) + sorted[upper] * weight;
}
function mean(values) {
  if (values.length === 0)
    return 0;
  return values.reduce((a, b) => a + b, 0) / values.length;
}

class StochAdaptiveStrategy {
  params;
  priceHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  atrIndicators = new Map;
  kHistory = new Map;
  atrHistory = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams204();
    const mergedParams = { ...defaultParams204, ...savedParams, ...params };
    const minKPeriod = Math.max(2, Math.floor(mergedParams.min_k_period));
    const maxKPeriod = Math.max(minKPeriod + 1, Math.floor(mergedParams.max_k_period));
    this.params = {
      min_k_period: minKPeriod,
      max_k_period: maxKPeriod,
      d_period: Math.max(2, Math.floor(mergedParams.d_period)),
      percentile_lookback: Math.max(5, Math.floor(mergedParams.percentile_lookback)),
      oversold_percentile: mergedParams.oversold_percentile,
      overbought_percentile: mergedParams.overbought_percentile,
      atr_period: Math.max(5, Math.floor(mergedParams.atr_period)),
      min_atr_threshold: mergedParams.min_atr_threshold,
      volatility_scale: mergedParams.volatility_scale,
      stop_loss: mergedParams.stop_loss,
      risk_percent: mergedParams.risk_percent
    };
  }
  getATR(tokenId) {
    let atr = this.atrIndicators.get(tokenId);
    if (!atr) {
      atr = new ATR(this.params.atr_period);
      this.atrIndicators.set(tokenId, atr);
    }
    return atr;
  }
  getAdaptiveKPeriod(tokenId, currentATR, currentPrice) {
    const atrHistory = this.atrHistory.get(tokenId) || [];
    if (atrHistory.length < 5) {
      return Math.floor((this.params.min_k_period + this.params.max_k_period) / 2);
    }
    const avgATR = mean(atrHistory);
    const relVol = avgATR > 0 ? currentATR / avgATR : 1;
    const volScale = Math.min(1, Math.max(0, (relVol - 0.5) * this.params.volatility_scale));
    const adaptivePeriod = Math.floor(this.params.max_k_period - (this.params.max_k_period - this.params.min_k_period) * volScale);
    return Math.max(this.params.min_k_period, Math.min(this.params.max_k_period, adaptivePeriod));
  }
  getAdaptiveLevels(tokenId) {
    const kHistory = this.kHistory.get(tokenId) || [];
    if (kHistory.length < this.params.percentile_lookback) {
      return { oversold: 20, overbought: 80 };
    }
    const oversold = percentile(kHistory, this.params.oversold_percentile);
    const overbought = percentile(kHistory, this.params.overbought_percentile);
    return { oversold, overbought };
  }
  checkVolatilityThreshold(tokenId, currentATR, currentPrice) {
    if (currentPrice <= 0)
      return false;
    const relATR = currentATR / currentPrice;
    return relATR >= this.params.min_atr_threshold;
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
      this.kHistory.set(bar.tokenId, []);
      this.atrHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    const kHistory = this.kHistory.get(bar.tokenId);
    const atrHistory = this.atrHistory.get(bar.tokenId);
    const atr = this.getATR(bar.tokenId);
    atr.update(bar.high, bar.low, bar.close);
    const currentATR = atr.get(0);
    if (currentATR !== undefined) {
      atrHistory.push(currentATR);
      if (atrHistory.length > this.params.atr_period * 2) {
        atrHistory.shift();
      }
    }
    const isVolatileEnough = currentATR !== undefined && this.checkVolatilityThreshold(bar.tokenId, currentATR, bar.close);
    const kPeriod = this.getAdaptiveKPeriod(bar.tokenId, currentATR || 0, bar.close);
    history.push(bar.close);
    const maxHistoryLen = Math.max(kPeriod, this.params.max_k_period) + 5;
    if (history.length > maxHistoryLen) {
      history.shift();
    }
    if (history.length < kPeriod)
      return;
    const periodHistory = history.slice(-kPeriod);
    const highest = Math.max(...periodHistory);
    const lowest = Math.min(...periodHistory);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period) {
      kVals.shift();
    }
    kHistory.push(k);
    if (kHistory.length > this.params.percentile_lookback) {
      kHistory.shift();
    }
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const levels = this.getAdaptiveLevels(bar.tokenId);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= levels.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (!isVolatileEnough)
        return;
      if (k <= levels.oversold && k > d) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_stoch_combo_205.ts
import * as fs205 from "fs";
import * as path205 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams205 = {
  rsi_period: 14,
  divergence_lookback: 5,
  k_period: 14,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  signal_window: 3,
  stop_loss: 0.05,
  risk_percent: 0.1
};
function loadSavedParams205() {
  const paramsPath = path205.join(__dirname, "strat_rsi_stoch_combo_205.params.json");
  if (!fs205.existsSync(paramsPath))
    return null;
  try {
    const content = fs205.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams205) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RsiStochCombo205Strategy {
  params;
  rsiMap = new Map;
  priceHistory = new Map;
  rsiHistory = new Map;
  stochPriceHistory = new Map;
  kValues = new Map;
  divergenceSignalBar = new Map;
  stochSignalBar = new Map;
  entryPrice = new Map;
  barCount = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams205();
    this.params = { ...defaultParams205, ...savedParams, ...params };
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
    this.params.divergence_lookback = Math.max(3, Math.floor(this.params.divergence_lookback));
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
    this.params.signal_window = Math.max(1, Math.floor(this.params.signal_window));
  }
  onInit(_ctx) {}
  onNext(ctx, bar) {
    const currentBarCount = (this.barCount.get(bar.tokenId) || 0) + 1;
    this.barCount.set(bar.tokenId, currentBarCount);
    if (!this.rsiMap.has(bar.tokenId)) {
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
      this.priceHistory.set(bar.tokenId, []);
      this.rsiHistory.set(bar.tokenId, []);
      this.stochPriceHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiVal = rsi.get(0);
    if (rsiVal === undefined)
      return;
    const prices = this.priceHistory.get(bar.tokenId);
    const rsis = this.rsiHistory.get(bar.tokenId);
    prices.push(bar.close);
    rsis.push(rsiVal);
    if (prices.length > this.params.divergence_lookback) {
      prices.shift();
      rsis.shift();
    }
    const stochHistory = this.stochPriceHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    stochHistory.push(bar.close);
    if (stochHistory.length > this.params.k_period) {
      stochHistory.shift();
    }
    let k;
    let d;
    if (stochHistory.length >= this.params.k_period) {
      const highest = Math.max(...stochHistory);
      const lowest = Math.min(...stochHistory);
      k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
      kVals.push(k);
      if (kVals.length > this.params.d_period) {
        kVals.shift();
      }
      if (kVals.length >= this.params.d_period) {
        d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
      }
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.divergenceSignalBar.delete(bar.tokenId);
          this.stochSignalBar.delete(bar.tokenId);
          return;
        }
        if (rsiVal >= this.params.overbought || k !== undefined && k >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.divergenceSignalBar.delete(bar.tokenId);
          this.stochSignalBar.delete(bar.tokenId);
        }
      }
      return;
    }
    if (bar.close > 0.05 && bar.close < 0.95) {
      let bearishDiv = false;
      if (prices.length >= this.params.divergence_lookback) {
        const priceHigh = Math.max(...prices.slice(0, -1));
        const rsiHigh = Math.max(...rsis.slice(0, -1));
        bearishDiv = bar.close >= priceHigh && rsiVal < rsiHigh && rsiVal > this.params.overbought;
      }
      let bullishDiv = false;
      if (prices.length >= this.params.divergence_lookback) {
        const priceLow = Math.min(...prices.slice(0, -1));
        const rsiLow = Math.min(...rsis.slice(0, -1));
        bullishDiv = bar.close <= priceLow && rsiVal > rsiLow && rsiVal < this.params.oversold;
      }
      let stochOversold = false;
      let stochOverbought = false;
      if (k !== undefined && d !== undefined) {
        stochOversold = k <= this.params.oversold && k > d;
        stochOverbought = k >= this.params.overbought && k < d;
      }
      const window = this.params.signal_window;
      if (bullishDiv) {
        this.divergenceSignalBar.set(bar.tokenId, currentBarCount);
      }
      if (stochOversold) {
        this.stochSignalBar.set(bar.tokenId, currentBarCount);
      }
      const divBar = this.divergenceSignalBar.get(bar.tokenId);
      const stochBar = this.stochSignalBar.get(bar.tokenId);
      const hasDivergenceSignal = divBar !== undefined && currentBarCount - divBar <= window;
      const hasStochSignal = stochBar !== undefined && currentBarCount - stochBar <= window;
      if (hasDivergenceSignal && hasStochSignal && bar.close > 0.05 && bar.close < 0.95) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.divergenceSignalBar.delete(bar.tokenId);
            this.stochSignalBar.delete(bar.tokenId);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_volatility_breakout_206.ts
import * as fs206 from "fs";
import * as path206 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams206 = {
  atr_period: 14,
  atr_multiplier: 0.5,
  lookback: 20,
  volume_period: 10,
  stop_loss: 0.04,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams206() {
  const paramsPath = path206.join(__dirname, "strat_volatility_breakout_206.params.json");
  if (!fs206.existsSync(paramsPath))
    return null;
  try {
    const content = fs206.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams206) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class VolatilityBreakoutStrategy {
  params;
  atrIndicators = new Map;
  priceHistory = new Map;
  highHistory = new Map;
  lowHistory = new Map;
  volumeHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  lowestPrice = new Map;
  positionSide = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams206();
    const mergedParams = { ...defaultParams206, ...savedParams, ...params };
    this.params = {
      atr_period: Math.max(2, Math.floor(mergedParams.atr_period)),
      atr_multiplier: mergedParams.atr_multiplier,
      lookback: Math.max(2, Math.floor(mergedParams.lookback)),
      volume_period: Math.max(2, Math.floor(mergedParams.volume_period)),
      stop_loss: mergedParams.stop_loss,
      trailing_stop: mergedParams.trailing_stop,
      risk_percent: mergedParams.risk_percent
    };
  }
  onInit(_ctx) {
    console.log(`Volatility Breakout Strategy initialized with params:`);
    console.log(`  ATR Period: ${this.params.atr_period}`);
    console.log(`  ATR Multiplier: ${this.params.atr_multiplier}`);
    console.log(`  Lookback: ${this.params.lookback}`);
    console.log(`  Volume Period: ${this.params.volume_period}`);
    console.log(`  Stop Loss: ${(this.params.stop_loss * 100).toFixed(2)}%`);
    console.log(`  Trailing Stop: ${(this.params.trailing_stop * 100).toFixed(2)}%`);
    console.log(`  Risk Percent: ${(this.params.risk_percent * 100).toFixed(2)}%`);
  }
  onNext(ctx, bar) {
    if (!this.atrIndicators.has(bar.tokenId)) {
      this.atrIndicators.set(bar.tokenId, new ATR(this.params.atr_period));
      this.priceHistory.set(bar.tokenId, []);
      this.highHistory.set(bar.tokenId, []);
      this.lowHistory.set(bar.tokenId, []);
      this.volumeHistory.set(bar.tokenId, []);
    }
    const atrIndicator = this.atrIndicators.get(bar.tokenId);
    const priceHist = this.priceHistory.get(bar.tokenId);
    const highHist = this.highHistory.get(bar.tokenId);
    const lowHist = this.lowHistory.get(bar.tokenId);
    const volumeHist = this.volumeHistory.get(bar.tokenId);
    atrIndicator.update(bar.high, bar.low, bar.close);
    const atr = atrIndicator.get(0);
    priceHist.push(bar.close);
    highHist.push(bar.high);
    lowHist.push(bar.low);
    const priceRange = bar.high - bar.low;
    const volumeProxy = priceRange > 0 ? priceRange : 0;
    volumeHist.push(volumeProxy);
    if (priceHist.length > this.params.lookback) {
      priceHist.shift();
      highHist.shift();
      lowHist.shift();
    }
    if (volumeHist.length > this.params.volume_period) {
      volumeHist.shift();
    }
    if (priceHist.length < this.params.lookback || atr === undefined) {
      return;
    }
    const avgVolume = volumeHist.length > 0 ? volumeHist.reduce((a, b) => a + b, 0) / volumeHist.length : 0;
    const volumeConfirmed = volumeProxy > avgVolume;
    const recentHigh = Math.max(...highHist.slice(0, -1));
    const recentLow = Math.min(...lowHist.slice(0, -1));
    const longBreakoutLevel = recentHigh + this.params.atr_multiplier * atr;
    const shortBreakoutLevel = recentLow - this.params.atr_multiplier * atr;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const side = this.positionSide.get(bar.tokenId);
      if (entry !== undefined && side !== undefined) {
        if (side === "long" && bar.close < entry * (1 - this.params.stop_loss)) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss (long) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.clearPositionState(bar.tokenId);
          return;
        }
        if (side === "short" && bar.close > entry * (1 + this.params.stop_loss)) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss (short) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.clearPositionState(bar.tokenId);
          return;
        }
        if (side === "long") {
          const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
          this.highestPrice.set(bar.tokenId, highest);
          if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop (long) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.clearPositionState(bar.tokenId);
            return;
          }
        }
        if (side === "short") {
          const lowest = Math.min(this.lowestPrice.get(bar.tokenId) ?? entry, bar.close);
          this.lowestPrice.set(bar.tokenId, lowest);
          if (bar.close > lowest * (1 + this.params.trailing_stop) && bar.close < entry) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop (short) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.clearPositionState(bar.tokenId);
            return;
          }
        }
        if (side === "long" && bar.close < shortBreakoutLevel && volumeConfirmed) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Exit long (opposite signal) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.clearPositionState(bar.tokenId);
          return;
        }
        if (side === "short" && bar.close > longBreakoutLevel && volumeConfirmed) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Exit short (opposite signal) for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.clearPositionState(bar.tokenId);
          return;
        }
      }
    } else {
      if (!volumeConfirmed) {
        return;
      }
      const feeBuffer = 0.995;
      const cash = ctx.getCapital() * this.params.risk_percent * feeBuffer;
      if (bar.close > longBreakoutLevel) {
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Long breakout for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, level: ${longBreakoutLevel.toFixed(4)}, ATR: ${atr.toFixed(4)}`);
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.positionSide.set(bar.tokenId, "long");
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
        return;
      }
      if (bar.close < shortBreakoutLevel) {
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Short breakout for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, level: ${shortBreakoutLevel.toFixed(4)}, ATR: ${atr.toFixed(4)}`);
          const result = ctx.sell(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.lowestPrice.set(bar.tokenId, bar.close);
            this.positionSide.set(bar.tokenId, "short");
          } else {
            console.error(`  Order failed: ${result.error}`);
          }
        }
      }
    }
  }
  clearPositionState(tokenId) {
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.lowestPrice.delete(tokenId);
    this.positionSide.delete(tokenId);
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        const side = this.positionSide.get(pos.tokenId) ?? "long";
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${side} ${pos.size.toFixed(2)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_trend_following_ma_207.ts
import * as fs207 from "fs";
import * as path207 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams207 = {
  fast_period: 10,
  medium_period: 25,
  slow_period: 50,
  adx_period: 14,
  adx_threshold: 25,
  pullback_threshold: 0.005,
  stop_loss: 0.03,
  trailing_stop: 0.025,
  risk_percent: 0.15,
  take_profit_enabled: false,
  take_profit: 0.08
};

class ADX extends Indicator {
  period;
  highs = [];
  lows = [];
  closes = [];
  prevClose = null;
  plusDMValues = [];
  minusDMValues = [];
  trValues = [];
  prevADX = null;
  smoothedTR = 0;
  smoothedPlusDM = 0;
  smoothedMinusDM = 0;
  initialized = false;
  constructor(period) {
    super();
    this.period = period;
  }
  update(high, low, close) {
    this.highs.push(high);
    this.lows.push(low);
    this.closes.push(close);
    if (this.highs.length > this.period + 1) {
      this.highs.shift();
      this.lows.shift();
      this.closes.shift();
    }
    if (this.closes.length < 2) {
      this.prevClose = close;
      return;
    }
    const prevHigh = this.highs[this.highs.length - 2];
    const prevLow = this.lows[this.lows.length - 2];
    const plusDM = high - prevHigh > prevLow - low ? Math.max(high - prevHigh, 0) : 0;
    const minusDM = prevLow - low > high - prevHigh ? Math.max(prevLow - low, 0) : 0;
    const tr = Math.max(high - low, Math.abs(high - this.prevClose), Math.abs(low - this.prevClose));
    this.plusDMValues.push(plusDM);
    this.minusDMValues.push(minusDM);
    this.trValues.push(tr);
    if (this.plusDMValues.length > this.period) {
      this.plusDMValues.shift();
      this.minusDMValues.shift();
      this.trValues.shift();
    }
    if (this.plusDMValues.length === this.period && !this.initialized) {
      this.smoothedTR = this.trValues.reduce((a, b) => a + b, 0);
      this.smoothedPlusDM = this.plusDMValues.reduce((a, b) => a + b, 0);
      this.smoothedMinusDM = this.minusDMValues.reduce((a, b) => a + b, 0);
      this.initialized = true;
    } else if (this.initialized) {
      this.smoothedTR = this.smoothedTR - this.smoothedTR / this.period + tr;
      this.smoothedPlusDM = this.smoothedPlusDM - this.smoothedPlusDM / this.period + plusDM;
      this.smoothedMinusDM = this.smoothedMinusDM - this.smoothedMinusDM / this.period + minusDM;
    }
    if (this.initialized && this.smoothedTR > 0) {
      const plusDI = this.smoothedPlusDM / this.smoothedTR * 100;
      const minusDI = this.smoothedMinusDM / this.smoothedTR * 100;
      const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI + 0.0001) * 100;
      if (this.prevADX === null) {
        this.prevADX = dx;
      } else {
        this.prevADX = (this.prevADX * (this.period - 1) + dx) / this.period;
      }
      this.push(this.prevADX);
    }
    this.prevClose = close;
  }
}
function loadSavedParams207() {
  const paramsPath = path207.join(__dirname, "strat_trend_following_ma_207.params.json");
  if (!fs207.existsSync(paramsPath))
    return null;
  try {
    const content = fs207.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams207) {
        if (typeof value === "number") {
          params[key] = value;
        } else if (typeof value === "boolean") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TrendFollowingMAStrategy {
  params;
  fastMAs = new Map;
  mediumMAs = new Map;
  slowMAs = new Map;
  adxs = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  pullbackTriggered = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams207();
    const mergedParams = { ...defaultParams207, ...savedParams, ...params };
    const sorted = [
      mergedParams.fast_period,
      mergedParams.medium_period,
      mergedParams.slow_period
    ].sort((a, b) => a - b);
    this.params = {
      fast_period: Math.max(2, Math.floor(sorted[0])),
      medium_period: Math.max(3, Math.floor(sorted[1])),
      slow_period: Math.max(4, Math.floor(sorted[2])),
      adx_period: mergedParams.adx_period,
      adx_threshold: mergedParams.adx_threshold,
      pullback_threshold: mergedParams.pullback_threshold,
      stop_loss: mergedParams.stop_loss,
      trailing_stop: mergedParams.trailing_stop,
      risk_percent: mergedParams.risk_percent,
      take_profit_enabled: mergedParams.take_profit_enabled,
      take_profit: mergedParams.take_profit
    };
  }
  onInit(_ctx) {
    console.log(`TrendFollowingMAStrategy initialized with params:`);
    console.log(`  Fast MA period: ${this.params.fast_period}`);
    console.log(`  Medium MA period: ${this.params.medium_period}`);
    console.log(`  Slow MA period: ${this.params.slow_period}`);
    console.log(`  ADX period: ${this.params.adx_period}`);
    console.log(`  ADX threshold: ${this.params.adx_threshold}`);
    console.log(`  Pullback threshold: ${this.params.pullback_threshold * 100}%`);
    console.log(`  Stop loss: ${this.params.stop_loss * 100}%`);
    console.log(`  Trailing stop: ${this.params.trailing_stop * 100}%`);
    console.log(`  Risk percent: ${this.params.risk_percent * 100}%`);
    console.log(`  Take Profit: ${this.params.take_profit_enabled ? `${this.params.take_profit * 100}%` : "disabled"}`);
  }
  onNext(ctx, bar) {
    if (!this.fastMAs.has(bar.tokenId)) {
      this.fastMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.fast_period));
      this.mediumMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.medium_period));
      this.slowMAs.set(bar.tokenId, new SimpleMovingAverage(this.params.slow_period));
      this.adxs.set(bar.tokenId, new ADX(this.params.adx_period));
      this.pullbackTriggered.set(bar.tokenId, false);
    }
    const fastMA = this.fastMAs.get(bar.tokenId);
    const mediumMA = this.mediumMAs.get(bar.tokenId);
    const slowMA = this.slowMAs.get(bar.tokenId);
    const adx = this.adxs.get(bar.tokenId);
    fastMA.update(bar.close);
    mediumMA.update(bar.close);
    slowMA.update(bar.close);
    adx.update(bar.high, bar.low, bar.close);
    const fastVal = fastMA.get(0);
    const mediumVal = mediumMA.get(0);
    const slowVal = slowMA.get(0);
    const adxVal = adx.get(0);
    if (fastVal === undefined || mediumVal === undefined || slowVal === undefined)
      return;
    const bullishAlignment = fastVal > mediumVal && mediumVal > slowVal;
    const bearishAlignment = fastVal < mediumVal && mediumVal < slowVal;
    const strongTrend = adxVal !== undefined && adxVal > this.params.adx_threshold;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Stop loss triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.pullbackTriggered.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPrice.get(bar.tokenId) ?? entry, bar.close);
        this.highestPrice.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Trailing stop triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.pullbackTriggered.delete(bar.tokenId);
          return;
        }
        if (this.params.take_profit_enabled) {
          const tpPrice = entry * (1 + this.params.take_profit);
          if (bar.close >= tpPrice) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Take profit triggered for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
            ctx.close(bar.tokenId);
            this.entryPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            this.pullbackTriggered.delete(bar.tokenId);
            return;
          }
        }
        if (bearishAlignment) {
          console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] Bearish alignment exit for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}`);
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          this.pullbackTriggered.delete(bar.tokenId);
        }
      }
    } else {
      if (bullishAlignment && strongTrend) {
        const distanceToMedium = Math.abs(bar.close - mediumVal) / mediumVal;
        const isNearMediumMA = distanceToMedium <= this.params.pullback_threshold;
        if (isNearMediumMA && bar.close >= mediumVal) {
          const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
          const size = cash / bar.close;
          if (size > 0 && cash <= ctx.getCapital()) {
            console.log(`[${new Date(bar.timestamp * 1000).toISOString()}] BUY signal for ${bar.tokenId.slice(0, 8)}... at ${bar.close.toFixed(4)}, size: ${size.toFixed(4)}, ADX: ${adxVal?.toFixed(2) ?? "N/A"}`);
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.entryPrice.set(bar.tokenId, bar.close);
              this.highestPrice.set(bar.tokenId, bar.close);
              this.pullbackTriggered.set(bar.tokenId, true);
            } else {
              console.error(`  Order failed: ${result.error}`);
            }
          }
        }
      }
    }
  }
  onComplete(ctx) {
    console.log(`
Strategy completed.`);
    const positions = ctx.portfolio.getAllPositions();
    if (positions.length > 0) {
      console.log(`Open positions: ${positions.length}`);
      for (const pos of positions) {
        console.log(`  ${pos.tokenId.slice(0, 8)}...: ${pos.size.toFixed(4)} @ ${pos.avgPrice.toFixed(4)}`);
      }
    }
  }
}

// src/strategies/strat_mean_reversion_band_208.ts
import * as fs208 from "fs";
import * as path208 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams208 = {
  bb_period: 20,
  bb_stddev_mult: 2,
  rsi_period: 14,
  rsi_oversold: 30,
  rsi_overbought: 70,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.1
};
function loadSavedParams208() {
  const paramsPath = path208.join(__dirname, "strat_mean_reversion_band_208.params.json");
  if (!fs208.existsSync(paramsPath))
    return null;
  try {
    const content = fs208.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams208) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MeanReversionBandV208Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  priceHistoryMap = new Map;
  entryPriceMap = new Map;
  highestPriceMap = new Map;
  lowestPriceMap = new Map;
  prevPriceMap = new Map;
  positionSideMap = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams208() ?? {};
    const merged = { ...defaultParams208 };
    for (const [key, value] of Object.entries(savedParams)) {
      if (typeof value === "number" && key in defaultParams208) {
        merged[key] = value;
      }
    }
    for (const [key, value] of Object.entries(params)) {
      if (typeof value === "number" && key in defaultParams208) {
        merged[key] = value;
      }
    }
    this.params = merged;
  }
  onInit(_ctx) {}
  calculateBollingerBands(prices) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (prices.length < period)
      return;
    const recentPrices = prices.slice(-period);
    const sum = recentPrices.reduce((a, b) => a + b, 0);
    const mean2 = sum / period;
    const squaredDiffs = recentPrices.map((p) => Math.pow(p - mean2, 2));
    const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
    const stddev7 = Math.sqrt(variance);
    const multiplier = Math.max(0.5, this.params.bb_stddev_mult);
    return {
      upper: mean2 + multiplier * stddev7,
      middle: mean2,
      lower: mean2 - multiplier * stddev7
    };
  }
  isRising(priceHistory) {
    if (priceHistory.length < 2)
      return false;
    const current = priceHistory[priceHistory.length - 1];
    const previous = priceHistory[priceHistory.length - 2];
    return current > previous;
  }
  isFalling(priceHistory) {
    if (priceHistory.length < 2)
      return false;
    const current = priceHistory[priceHistory.length - 1];
    const previous = priceHistory[priceHistory.length - 2];
    return current < previous;
  }
  onNext(ctx, bar) {
    const period = Math.max(3, Math.floor(this.params.bb_period));
    if (!this.smaMap.has(bar.tokenId)) {
      this.smaMap.set(bar.tokenId, new SimpleMovingAverage(period));
      this.rsiMap.set(bar.tokenId, new RSI(Math.max(3, Math.floor(this.params.rsi_period))));
      this.priceHistoryMap.set(bar.tokenId, []);
    }
    const sma = this.smaMap.get(bar.tokenId);
    const rsi = this.rsiMap.get(bar.tokenId);
    const priceHistory = this.priceHistoryMap.get(bar.tokenId);
    sma.update(bar.close);
    rsi.update(bar.close);
    priceHistory.push(bar.close);
    if (priceHistory.length > period * 2) {
      priceHistory.shift();
    }
    const bb = this.calculateBollingerBands(priceHistory);
    const rsiVal = rsi.get(0);
    if (!bb || rsiVal === undefined)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const side = this.positionSideMap.get(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPriceMap.get(bar.tokenId);
      if (!entry)
        return;
      if (side === "long") {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
        const highest = Math.max(this.highestPriceMap.get(bar.tokenId) ?? entry, bar.close);
        this.highestPriceMap.set(bar.tokenId, highest);
        if (bar.close < highest * (1 - this.params.trailing_stop) && bar.close > entry) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
        if (bar.close >= bb.middle || rsiVal >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
      } else if (side === "short") {
        if (bar.close > entry * (1 + this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
        const lowest = Math.min(this.lowestPriceMap.get(bar.tokenId) ?? entry, bar.close);
        this.lowestPriceMap.set(bar.tokenId, lowest);
        if (bar.close > lowest * (1 + this.params.trailing_stop) && bar.close < entry) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
        if (bar.close <= bb.middle || rsiVal <= this.params.rsi_oversold) {
          ctx.close(bar.tokenId);
          this.entryPriceMap.delete(bar.tokenId);
          this.highestPriceMap.delete(bar.tokenId);
          this.lowestPriceMap.delete(bar.tokenId);
          this.positionSideMap.delete(bar.tokenId);
          return;
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const isPriceRising = this.isRising(priceHistory);
      const isPriceFalling = this.isFalling(priceHistory);
      if (bar.close <= bb.lower && isPriceRising && rsiVal > this.params.rsi_oversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPriceMap.set(bar.tokenId, bar.close);
            this.highestPriceMap.set(bar.tokenId, bar.close);
            this.positionSideMap.set(bar.tokenId, "long");
          }
        }
      } else if (bar.close >= bb.upper && isPriceFalling && rsiVal < this.params.rsi_overbought) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPriceMap.set(bar.tokenId, bar.close);
            this.lowestPriceMap.set(bar.tokenId, bar.close);
            this.positionSideMap.set(bar.tokenId, "short");
          }
        }
      }
    }
    this.prevPriceMap.set(bar.tokenId, bar.close);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v20_tweak2_209.ts
import * as fs209 from "fs";
import * as path209 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams209 = {
  k_period: 7,
  d_period: 3,
  oversold_base: 15,
  overbought_base: 70,
  volatility_period: 10,
  level_adjustment_factor: 10,
  momentum_period: 5,
  momentum_threshold: 0.01,
  stop_loss: 0.06,
  risk_percent: 0.2
};
function loadSavedParams209() {
  const paramsPath = path209.join(__dirname, "strat_stoch_v20_tweak2_209.params.json");
  if (!fs209.existsSync(paramsPath))
    return null;
  try {
    const content = fs209.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams209) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function stddev7(values) {
  if (values.length < 2)
    return 0;
  const mean2 = values.reduce((a, b) => a + b, 0) / values.length;
  const sqDiffs = values.reduce((sum, v) => sum + (v - mean2) * (v - mean2), 0);
  return Math.sqrt(sqDiffs / values.length);
}

class StochV20Tweak2_209Strategy {
  params;
  priceHistory = new Map;
  highHistory = new Map;
  lowHistory = new Map;
  kValues = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams209();
    const merged = { ...defaultParams209, ...savedParams, ...params };
    this.params = merged;
    this.params.k_period = Math.max(5, Math.min(15, Math.floor(this.params.k_period)));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
  }
  onInit(_ctx) {}
  getVolatilityAdjustedLevels(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.volatility_period) {
      return {
        oversold: this.params.oversold_base,
        overbought: this.params.overbought_base
      };
    }
    const relevantHistory = history.slice(-this.params.volatility_period);
    const vol = stddev7(relevantHistory);
    const meanPrice = relevantHistory.reduce((a, b) => a + b, 0) / relevantHistory.length;
    const volatilityPct = meanPrice > 0 ? vol / meanPrice * 100 : 0;
    const adjustment = volatilityPct * this.params.level_adjustment_factor / 10;
    return {
      oversold: Math.max(5, this.params.oversold_base - adjustment),
      overbought: Math.min(95, this.params.overbought_base + adjustment)
    };
  }
  getMomentum(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.momentum_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.highHistory.set(bar.tokenId, []);
      this.lowHistory.set(bar.tokenId, []);
      this.kValues.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const highHistory = this.highHistory.get(bar.tokenId);
    const lowHistory = this.lowHistory.get(bar.tokenId);
    const kVals = this.kValues.get(bar.tokenId);
    history.push(bar.close);
    highHistory.push(bar.high);
    lowHistory.push(bar.low);
    const maxPeriod = Math.max(this.params.k_period, this.params.volatility_period, this.params.momentum_period + 1);
    if (history.length > maxPeriod)
      history.shift();
    if (highHistory.length > maxPeriod)
      highHistory.shift();
    if (lowHistory.length > maxPeriod)
      lowHistory.shift();
    if (history.length < this.params.k_period)
      return;
    const periodHighs = highHistory.slice(-this.params.k_period);
    const periodLows = lowHistory.slice(-this.params.k_period);
    const highest = Math.max(...periodHighs);
    const lowest = Math.min(...periodLows);
    const k = highest === lowest ? 50 : (bar.close - lowest) / (highest - lowest) * 100;
    kVals.push(k);
    if (kVals.length > this.params.d_period)
      kVals.shift();
    if (kVals.length < this.params.d_period)
      return;
    const d = kVals.reduce((a, b) => a + b, 0) / kVals.length;
    const position = ctx.getPosition(bar.tokenId);
    const { oversold, overbought } = this.getVolatilityAdjustedLevels(bar.tokenId);
    const momentum = this.getMomentum(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= oversold && k > d && momentum > this.params.momentum_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mean_reversion_band2_210.ts
import * as fs210 from "fs";
import * as path210 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams210 = {
  bb_period: 20,
  bb_stddev_mult: 1.8,
  rsi_period: 18,
  rsi_oversold: 25,
  rsi_overbought: 65,
  momentum_lookback: 3,
  stop_loss: 0.04,
  trailing_stop: 0.04,
  risk_percent: 0.15
};
function loadSavedParams210() {
  const paramsPath = path210.join(__dirname, "strat_mean_reversion_band2_210.params.json");
  if (!fs210.existsSync(paramsPath))
    return null;
  try {
    const content = fs210.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams210) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function calcStdDev(values, mean2) {
  if (values.length < 2)
    return 0;
  const sqDiffs = values.reduce((sum, v) => sum + (v - mean2) * (v - mean2), 0);
  return Math.sqrt(sqDiffs / values.length);
}

class MeanReversionBand2_210Strategy {
  params;
  smaMap = new Map;
  rsiMap = new Map;
  priceHistoryMap = new Map;
  entryPriceMap = new Map;
  highestPriceMap = new Map;
  lowestPriceMap = new Map;
  prevPriceMap = new Map;
  positionSideMap = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams210() ?? {};
    const merged = { ...defaultParams210 };
    for (const [key, value] of Object.entries({ ...savedParams, ...params })) {
      if (key !== "metadata" && typeof value === "number") {
        merged[key] = value;
      }
    }
    this.params = merged;
    this.params.bb_period = Math.max(5, Math.floor(this.params.bb_period));
    this.params.rsi_period = Math.max(3, Math.floor(this.params.rsi_period));
  }
  onInit(_ctx) {}
  getBollingerBands(tokenId) {
    const history = this.priceHistoryMap.get(tokenId);
    if (!history || history.length < this.params.bb_period)
      return null;
    const slice = history.slice(-this.params.bb_period);
    const mean2 = slice.reduce((a, b) => a + b, 0) / slice.length;
    const std = calcStdDev(slice, mean2);
    const offset = std * this.params.bb_stddev_mult;
    return {
      upper: mean2 + offset,
      middle: mean2,
      lower: mean2 - offset,
      width: offset * 2 / mean2
    };
  }
  getMomentum(tokenId) {
    const history = this.priceHistoryMap.get(tokenId);
    if (!history || history.length < this.params.momentum_lookback + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_lookback];
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    if (!this.priceHistoryMap.has(bar.tokenId)) {
      this.priceHistoryMap.set(bar.tokenId, []);
      this.rsiMap.set(bar.tokenId, new RSI(this.params.rsi_period));
    }
    const history = this.priceHistoryMap.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.bb_period + 10)
      history.shift();
    const rsi = this.rsiMap.get(bar.tokenId);
    rsi.update(bar.close);
    const rsiValue = rsi.get(0);
    const bb = this.getBollingerBands(bar.tokenId);
    if (!bb || rsiValue === null || rsiValue === undefined)
      return;
    const prevPrice = this.prevPriceMap.get(bar.tokenId) ?? bar.close;
    this.prevPriceMap.set(bar.tokenId, bar.close);
    const position = ctx.getPosition(bar.tokenId);
    const momentum = this.getMomentum(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPriceMap.get(bar.tokenId);
      const side = this.positionSideMap.get(bar.tokenId);
      const highest = this.highestPriceMap.get(bar.tokenId) ?? bar.close;
      const lowest = this.lowestPriceMap.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (side === "long") {
          this.highestPriceMap.set(bar.tokenId, Math.max(highest, bar.close));
          const newHighest = this.highestPriceMap.get(bar.tokenId);
          if (bar.close < entry * (1 - this.params.stop_loss)) {
            ctx.close(bar.tokenId);
            this.clearPosition(bar.tokenId);
            return;
          }
          if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
            ctx.close(bar.tokenId);
            this.clearPosition(bar.tokenId);
            return;
          }
          if (bar.close >= bb.middle && rsiValue >= this.params.rsi_overbought) {
            ctx.close(bar.tokenId);
            this.clearPosition(bar.tokenId);
          }
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bar.close <= bb.lower && bar.close > prevPrice && rsiValue <= this.params.rsi_oversold && momentum > 0) {
        const sizeMultiplier = Math.max(0.5, 1 - bb.width);
        const cash = ctx.getCapital() * this.params.risk_percent * sizeMultiplier * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPriceMap.set(bar.tokenId, bar.close);
            this.highestPriceMap.set(bar.tokenId, bar.close);
            this.positionSideMap.set(bar.tokenId, "long");
          }
        }
      }
    }
  }
  clearPosition(tokenId) {
    this.entryPriceMap.delete(tokenId);
    this.highestPriceMap.delete(tokenId);
    this.lowestPriceMap.delete(tokenId);
    this.positionSideMap.delete(tokenId);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_v06_tweak2_211.ts
import * as fs211 from "fs";
import * as path211 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams211 = {
  k_period: 8,
  d_period: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.04,
  risk_percent: 0.2,
  ma_period: 30,
  mtf_fast_period: 5,
  mtf_slow_period: 14
};
function loadSavedParams211() {
  const paramsPath = path211.join(__dirname, "strat_stoch_v06_tweak2_211.params.json");
  if (!fs211.existsSync(paramsPath))
    return null;
  try {
    const content = fs211.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams211) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochV06Tweak2_211Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams211() || {};
    this.params = { ...defaultParams211, ...savedParams, ...params };
    this.params.k_period = Math.max(3, Math.floor(this.params.k_period));
    this.params.d_period = Math.max(2, Math.floor(this.params.d_period));
    this.params.ma_period = Math.max(5, Math.floor(this.params.ma_period));
  }
  onInit(_ctx) {}
  getOrCreateTokenData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        priceHistory: [],
        kValues: [],
        fastKValues: [],
        slowKValues: [],
        maValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calculateStochastic(priceHistory, period) {
    if (priceHistory.length < period)
      return null;
    const slice = priceHistory.slice(-period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    if (high === low)
      return 50;
    return (priceHistory[priceHistory.length - 1] - low) / (high - low) * 100;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateTokenData(bar.tokenId);
    data.priceHistory.push(bar.close);
    const maxPeriod = Math.max(this.params.k_period, this.params.ma_period, this.params.mtf_slow_period);
    if (data.priceHistory.length > maxPeriod + 10)
      data.priceHistory.shift();
    const k = this.calculateStochastic(data.priceHistory, this.params.k_period);
    if (k === null)
      return;
    data.kValues.push(k);
    if (data.kValues.length > this.params.d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.d_period)
      return;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    const fastK = this.calculateStochastic(data.priceHistory, this.params.mtf_fast_period);
    const slowK = this.calculateStochastic(data.priceHistory, this.params.mtf_slow_period);
    if (fastK !== null) {
      data.fastKValues.push(fastK);
      if (data.fastKValues.length > 3)
        data.fastKValues.shift();
    }
    if (slowK !== null) {
      data.slowKValues.push(slowK);
      if (data.slowKValues.length > 3)
        data.slowKValues.shift();
    }
    if (data.priceHistory.length >= this.params.ma_period) {
      const ma = data.priceHistory.slice(-this.params.ma_period).reduce((a, b) => a + b, 0) / this.params.ma_period;
      data.maValues.push(ma);
      if (data.maValues.length > 5)
        data.maValues.shift();
    }
    const position = ctx.getPosition(bar.tokenId);
    const mtfBullish = data.fastKValues.length > 0 && data.slowKValues.length > 0 && data.fastKValues[data.fastKValues.length - 1] > data.slowKValues[data.slowKValues.length - 1];
    const trendUp = data.maValues.length > 0 && bar.close > data.maValues[data.maValues.length - 1];
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (k >= this.params.overbought && k < d) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (k <= this.params.oversold && k > d && mtfBullish && trendUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_momentum_vol_212.ts
import * as fs212 from "fs";
import * as path212 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams212 = {
  momentum_period: 5,
  momentum_threshold: 0.02,
  volatility_period: 10,
  volatility_multiplier: 1.2,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams212() {
  const paramsPath = path212.join(__dirname, "strat_momentum_vol_212.params.json");
  if (!fs212.existsSync(paramsPath))
    return null;
  try {
    const content = fs212.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams212) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function calcVolatility(prices) {
  if (prices.length < 2)
    return 0;
  const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
  const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
  return Math.sqrt(sqDiffs / prices.length) / mean2;
}

class MomentumVol212Strategy {
  params;
  priceHistory = new Map;
  volatilityHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams212();
    this.params = { ...defaultParams212, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getMomentum(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.momentum_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  isVolatilityHigh(tokenId) {
    const volHistory = this.volatilityHistory.get(tokenId) || [];
    if (volHistory.length < 2)
      return false;
    const currentVol = volHistory[volHistory.length - 1];
    const avgVol = volHistory.slice(0, -1).reduce((a, b) => a + b, 0) / (volHistory.length - 1);
    return currentVol > avgVol * this.params.volatility_multiplier;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.volatilityHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const volHistory = this.volatilityHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxPeriod = Math.max(this.params.momentum_period + 1, this.params.volatility_period);
    if (history.length > maxPeriod + 10)
      history.shift();
    if (history.length >= this.params.volatility_period) {
      const currentVol = calcVolatility(history.slice(-this.params.volatility_period));
      volHistory.push(currentVol);
      if (volHistory.length > 20)
        volHistory.shift();
    }
    const momentum = this.getMomentum(bar.tokenId);
    const highVolatility = this.isVolatilityHigh(bar.tokenId);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (momentum < -this.params.momentum_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (momentum > this.params.momentum_threshold && highVolatility) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_roc_adaptive_213.ts
import * as fs213 from "fs";
import * as path213 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams213 = {
  roc_period: 5,
  volatility_period: 14,
  base_threshold: 0.015,
  threshold_scale: 2,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams213() {
  const paramsPath = path213.join(__dirname, "strat_roc_adaptive_213.params.json");
  if (!fs213.existsSync(paramsPath))
    return null;
  try {
    const content = fs213.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams213) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function calcStdDev2(values) {
  if (values.length < 2)
    return 0;
  const mean2 = values.reduce((a, b) => a + b, 0) / values.length;
  const sqDiffs = values.reduce((sum, v) => sum + (v - mean2) * (v - mean2), 0);
  return Math.sqrt(sqDiffs / values.length);
}

class RocAdaptive213Strategy {
  params;
  priceHistory = new Map;
  rocHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams213();
    this.params = { ...defaultParams213, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getRoc(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.roc_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.roc_period];
    return (current - past) / past;
  }
  getAdaptiveThreshold(tokenId) {
    const rocHistory = this.rocHistory.get(tokenId) || [];
    if (rocHistory.length < this.params.volatility_period) {
      return this.params.base_threshold;
    }
    const recentRoc = rocHistory.slice(-this.params.volatility_period);
    const rocStdDev = calcStdDev2(recentRoc);
    return this.params.base_threshold + rocStdDev * this.params.threshold_scale;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.rocHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const rocHist = this.rocHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxPeriod = Math.max(this.params.roc_period + 1, this.params.volatility_period + 10);
    if (history.length > maxPeriod)
      history.shift();
    const roc = this.getRoc(bar.tokenId);
    rocHist.push(roc);
    if (rocHist.length > this.params.volatility_period + 10)
      rocHist.shift();
    const threshold = this.getAdaptiveThreshold(bar.tokenId);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (roc < -threshold) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (roc > threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  clearPosition(tokenId) {
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_keltner_breakout_214.ts
import * as fs214 from "fs";
import * as path214 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams214 = {
  ema_period: 20,
  atr_period: 14,
  atr_multiplier: 2,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams214() {
  const paramsPath = path214.join(__dirname, "strat_keltner_breakout_214.params.json");
  if (!fs214.existsSync(paramsPath))
    return null;
  try {
    const content = fs214.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams214) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class KeltnerBreakout214Strategy {
  params;
  priceHistory = new Map;
  atrMap = new Map;
  emaValues = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams214();
    this.params = { ...defaultParams214, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  updateEMA(tokenId, price) {
    const prevEMA = this.emaValues.get(tokenId);
    const k = 2 / (this.params.ema_period + 1);
    if (prevEMA === undefined) {
      this.emaValues.set(tokenId, price);
      return price;
    }
    const newEMA = price * k + prevEMA * (1 - k);
    this.emaValues.set(tokenId, newEMA);
    return newEMA;
  }
  getKeltnerChannel(tokenId) {
    const ema = this.emaValues.get(tokenId);
    const atr = this.atrMap.get(tokenId);
    if (ema === undefined || !atr)
      return null;
    const atrValue = atr.get(0);
    if (atrValue === undefined)
      return null;
    const offset = atrValue * this.params.atr_multiplier;
    return {
      upper: ema + offset,
      middle: ema,
      lower: ema - offset
    };
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.atrMap.set(bar.tokenId, new ATR(this.params.atr_period));
    }
    const history = this.priceHistory.get(bar.tokenId);
    const atr = this.atrMap.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.ema_period + 10)
      history.shift();
    atr.update(bar.high, bar.low, bar.close);
    this.updateEMA(bar.tokenId, bar.close);
    const channel = this.getKeltnerChannel(bar.tokenId);
    if (!channel)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < channel.middle) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bar.close > channel.upper) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  clearPosition(tokenId) {
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_macd_stoch_combo_215.ts
import * as fs215 from "fs";
import * as path215 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams215 = {
  macd_fast: 12,
  macd_slow: 26,
  macd_signal: 9,
  stoch_k_period: 14,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 80,
  signal_window: 3,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams215() {
  const paramsPath = path215.join(__dirname, "strat_macd_stoch_combo_215.params.json");
  if (!fs215.existsSync(paramsPath))
    return null;
  try {
    const content = fs215.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams215) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MacdStochCombo215Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams215();
    this.params = { ...defaultParams215, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        fastEMA: 0,
        slowEMA: 0,
        macdLine: [],
        signalLine: 0,
        kValues: [],
        macdCrossUpBar: -100,
        stochOversoldBar: -100,
        barCount: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  updateEMA(prevEMA, price, period) {
    const k = 2 / (period + 1);
    return price * k + prevEMA * (1 - k);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.barCount++;
    const maxPeriod = Math.max(this.params.macd_slow, this.params.stoch_k_period) + 10;
    if (data.prices.length > maxPeriod)
      data.prices.shift();
    if (data.prices.length < this.params.macd_slow)
      return;
    if (data.fastEMA === 0) {
      data.fastEMA = data.prices.slice(-this.params.macd_fast).reduce((a, b) => a + b, 0) / this.params.macd_fast;
      data.slowEMA = data.prices.slice(-this.params.macd_slow).reduce((a, b) => a + b, 0) / this.params.macd_slow;
    } else {
      data.fastEMA = this.updateEMA(data.fastEMA, bar.close, this.params.macd_fast);
      data.slowEMA = this.updateEMA(data.slowEMA, bar.close, this.params.macd_slow);
    }
    const prevMacd = data.macdLine.length > 0 ? data.macdLine[data.macdLine.length - 1] : 0;
    const macd = data.fastEMA - data.slowEMA;
    data.macdLine.push(macd);
    if (data.macdLine.length > this.params.macd_signal + 1)
      data.macdLine.shift();
    if (data.macdLine.length >= this.params.macd_signal) {
      const prevSignal = data.signalLine;
      data.signalLine = this.updateEMA(data.signalLine || data.macdLine[0], macd, this.params.macd_signal);
      if (prevMacd <= prevSignal && macd > data.signalLine) {
        data.macdCrossUpBar = data.barCount;
      }
    }
    if (data.prices.length >= this.params.stoch_k_period) {
      const slice = data.prices.slice(-this.params.stoch_k_period);
      const high = Math.max(...slice);
      const low = Math.min(...slice);
      const k = high === low ? 50 : (bar.close - low) / (high - low) * 100;
      data.kValues.push(k);
      if (data.kValues.length > this.params.stoch_d_period)
        data.kValues.shift();
      if (k <= this.params.stoch_oversold) {
        data.stochOversoldBar = data.barCount;
      }
    }
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        const k = data.kValues.length > 0 ? data.kValues[data.kValues.length - 1] : 50;
        if (k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const macdRecent = data.barCount - data.macdCrossUpBar <= this.params.signal_window;
      const stochRecent = data.barCount - data.stochOversoldBar <= this.params.signal_window;
      if (macdRecent && stochRecent) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            data.macdCrossUpBar = -100;
            data.stochOversoldBar = -100;
          }
        }
      }
    }
  }
  clearPosition(tokenId) {
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_support_resistance_stoch_216.ts
import * as fs216 from "fs";
import * as path216 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams216 = {
  lookback: 20,
  bounce_threshold: 0.02,
  stoch_k_period: 14,
  stoch_d_period: 3,
  stoch_oversold: 25,
  stoch_overbought: 75,
  stop_loss: 0.05,
  risk_percent: 0.15
};
function loadSavedParams216() {
  const paramsPath = path216.join(__dirname, "strat_support_resistance_stoch_216.params.json");
  if (!fs216.existsSync(paramsPath))
    return null;
  try {
    const content = fs216.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams216) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SupportResistanceStoch216Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams216();
    this.params = { ...defaultParams216, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  findSupportLevel(data) {
    if (data.lows.length < this.params.lookback)
      return null;
    const recentLows = data.lows.slice(-this.params.lookback);
    return Math.min(...recentLows);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.stoch_k_period) + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const support = this.findSupportLevel(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || support === null)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = Math.abs(bar.close - support) / support < this.params.bounce_threshold;
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_momentum_vol_tweak_217.ts
import * as fs217 from "fs";
import * as path217 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams217 = {
  momentum_period: 8,
  momentum_threshold: 0.036,
  volatility_period: 16,
  volatility_multiplier: 1.02,
  ema_period: 20,
  stop_loss: 0.043,
  trailing_stop: 0.034,
  risk_percent: 0.19
};
function loadSavedParams217() {
  const paramsPath = path217.join(__dirname, "strat_momentum_vol_tweak_217.params.json");
  if (!fs217.existsSync(paramsPath))
    return null;
  try {
    const content = fs217.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams217) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}
function calcVolatility2(prices) {
  if (prices.length < 2)
    return 0;
  const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
  const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
  return Math.sqrt(sqDiffs / prices.length) / mean2;
}

class MomentumVolTweak217Strategy {
  params;
  priceHistory = new Map;
  volatilityHistory = new Map;
  emaValues = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams217();
    this.params = { ...defaultParams217, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  updateEMA(tokenId, price) {
    const prevEMA = this.emaValues.get(tokenId);
    const k = 2 / (this.params.ema_period + 1);
    if (prevEMA === undefined) {
      this.emaValues.set(tokenId, price);
      return price;
    }
    const newEMA = price * k + prevEMA * (1 - k);
    this.emaValues.set(tokenId, newEMA);
    return newEMA;
  }
  getMomentum(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.momentum_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  isVolatilityHigh(tokenId) {
    const volHistory = this.volatilityHistory.get(tokenId) || [];
    if (volHistory.length < 2)
      return false;
    const currentVol = volHistory[volHistory.length - 1];
    const avgVol = volHistory.slice(0, -1).reduce((a, b) => a + b, 0) / (volHistory.length - 1);
    return currentVol > avgVol * this.params.volatility_multiplier;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.volatilityHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const volHistory = this.volatilityHistory.get(bar.tokenId);
    history.push(bar.close);
    const ema = this.updateEMA(bar.tokenId, bar.close);
    const maxPeriod = Math.max(this.params.momentum_period + 1, this.params.volatility_period, this.params.ema_period);
    if (history.length > maxPeriod + 10)
      history.shift();
    if (history.length >= this.params.volatility_period) {
      const currentVol = calcVolatility2(history.slice(-this.params.volatility_period));
      volHistory.push(currentVol);
      if (volHistory.length > 20)
        volHistory.shift();
    }
    const momentum = this.getMomentum(bar.tokenId);
    const highVolatility = this.isVolatilityHigh(bar.tokenId);
    const trendUp = bar.close > ema;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (momentum < -this.params.momentum_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (momentum > this.params.momentum_threshold && highVolatility && trendUp) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_support_resistance_tweak_218.ts
import * as fs218 from "fs";
import * as path218 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams218 = {
  lookback: 15,
  bounce_threshold: 0.028,
  stoch_k_period: 16,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.07,
  trailing_stop: 0.04,
  risk_percent: 0.18
};
function loadSavedParams218() {
  const paramsPath = path218.join(__dirname, "strat_support_resistance_tweak_218.params.json");
  if (!fs218.existsSync(paramsPath))
    return null;
  try {
    const content = fs218.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams218) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SupportResistanceTweak218Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams218();
    this.params = { ...defaultParams218, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.stoch_k_period) + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_keltner_tweak_219.ts
import * as fs219 from "fs";
import * as path219 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams219 = {
  ema_period: 25,
  atr_period: 12,
  atr_multiplier: 2.5,
  momentum_period: 5,
  momentum_threshold: 0.01,
  stop_loss: 0.04,
  trailing_stop: 0.022,
  risk_percent: 0.11
};
function loadSavedParams219() {
  const paramsPath = path219.join(__dirname, "strat_keltner_tweak_219.params.json");
  if (!fs219.existsSync(paramsPath))
    return null;
  try {
    const content = fs219.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams219) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class KeltnerTweak219Strategy {
  params;
  priceHistory = new Map;
  atrMap = new Map;
  emaValues = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams219();
    this.params = { ...defaultParams219, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  updateEMA(tokenId, price) {
    const prevEMA = this.emaValues.get(tokenId);
    const k = 2 / (this.params.ema_period + 1);
    if (prevEMA === undefined) {
      this.emaValues.set(tokenId, price);
      return price;
    }
    const newEMA = price * k + prevEMA * (1 - k);
    this.emaValues.set(tokenId, newEMA);
    return newEMA;
  }
  getMomentum(tokenId) {
    const history = this.priceHistory.get(tokenId) || [];
    if (history.length < this.params.momentum_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  getKeltnerChannel(tokenId) {
    const ema = this.emaValues.get(tokenId);
    const atr = this.atrMap.get(tokenId);
    if (ema === undefined || !atr)
      return null;
    const atrValue = atr.get(0);
    if (atrValue === undefined)
      return null;
    const offset = atrValue * this.params.atr_multiplier;
    return {
      upper: ema + offset,
      middle: ema,
      lower: ema - offset
    };
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.atrMap.set(bar.tokenId, new ATR(this.params.atr_period));
    }
    const history = this.priceHistory.get(bar.tokenId);
    const atr = this.atrMap.get(bar.tokenId);
    history.push(bar.close);
    if (history.length > this.params.ema_period + 10)
      history.shift();
    atr.update(bar.high, bar.low, bar.close);
    this.updateEMA(bar.tokenId, bar.close);
    const channel = this.getKeltnerChannel(bar.tokenId);
    const momentum = this.getMomentum(bar.tokenId);
    if (!channel)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
          return;
        }
        if (bar.close < channel.middle || momentum < -this.params.momentum_threshold) {
          ctx.close(bar.tokenId);
          this.clearPosition(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (bar.close > channel.upper && momentum > this.params.momentum_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  clearPosition(tokenId) {
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_dual_momentum_220.ts
import * as fs220 from "fs";
import * as path220 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams220 = {
  fast_period: 5,
  slow_period: 15,
  volatility_period: 10,
  momentum_threshold: 0.02,
  vol_adj_factor: 0.5,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams220() {
  const paramsPath = path220.join(__dirname, "strat_dual_momentum_220.params.json");
  if (!fs220.existsSync(paramsPath))
    return null;
  try {
    const content = fs220.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams220) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class DualMomentum220Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams220();
    this.params = { ...defaultParams220, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getFastMomentum(history) {
    if (history.length < this.params.fast_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.fast_period];
    return (current - past) / past;
  }
  getSlowMomentum(history) {
    if (history.length < this.params.slow_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.slow_period];
    return (current - past) / past;
  }
  getVolatility(history) {
    if (history.length < this.params.volatility_period)
      return 1;
    const slice = history.slice(-this.params.volatility_period);
    const mean2 = slice.reduce((a, b) => a + b, 0) / slice.length;
    const variance = slice.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0) / slice.length;
    return Math.sqrt(variance) / mean2;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxPeriod = Math.max(this.params.slow_period + 1, this.params.volatility_period) + 5;
    if (history.length > maxPeriod)
      history.shift();
    const fastMom = this.getFastMomentum(history);
    const slowMom = this.getSlowMomentum(history);
    const vol = this.getVolatility(history);
    const volAdjMom = fastMom / (1 + vol * this.params.vol_adj_factor);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (fastMom < -this.params.momentum_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const threshold = this.params.momentum_threshold;
      if (fastMom > threshold && slowMom > 0 && volAdjMom > threshold * 0.5) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_price_range_breakout_221.ts
import * as fs221 from "fs";
import * as path221 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams221 = {
  lookback: 15,
  range_threshold: 0.03,
  breakout_multiplier: 1.2,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams221() {
  const paramsPath = path221.join(__dirname, "strat_price_range_breakout_221.params.json");
  if (!fs221.existsSync(paramsPath))
    return null;
  try {
    const content = fs221.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams221) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PriceRangeBreakout221Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams221();
    this.params = { ...defaultParams221, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        rangeHigh: 0,
        rangeLow: 0,
        inConsolidation: false
      });
    }
    return this.tokenData.get(tokenId);
  }
  detectConsolidation(data) {
    if (data.highs.length < this.params.lookback) {
      data.inConsolidation = false;
      return;
    }
    const recentHighs = data.highs.slice(-this.params.lookback);
    const recentLows = data.lows.slice(-this.params.lookback);
    const rangeHigh = Math.max(...recentHighs);
    const rangeLow = Math.min(...recentLows);
    const range = (rangeHigh - rangeLow) / rangeLow;
    data.rangeHigh = rangeHigh;
    data.rangeLow = rangeLow;
    data.inConsolidation = range < this.params.range_threshold;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.lookback + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    this.detectConsolidation(data);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (data.inConsolidation && data.rangeHigh > 0) {
        const breakoutLevel = data.rangeHigh * this.params.breakout_multiplier;
        if (bar.close > data.rangeHigh && bar.close < breakoutLevel) {
          const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
          const size = cash / bar.close;
          if (size > 0 && cash <= ctx.getCapital()) {
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.entryPrice.set(bar.tokenId, bar.close);
              this.highestPrice.set(bar.tokenId, bar.close);
            }
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_velocity_222.ts
import * as fs222 from "fs";
import * as path222 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams222 = {
  velocity_period: 5,
  acceleration_period: 3,
  velocity_threshold: 0.015,
  acceleration_threshold: 0.005,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams222() {
  const paramsPath = path222.join(__dirname, "strat_velocity_222.params.json");
  if (!fs222.existsSync(paramsPath))
    return null;
  try {
    const content = fs222.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams222) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class Velocity222Strategy {
  params;
  priceHistory = new Map;
  velocityHistory = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams222();
    this.params = { ...defaultParams222, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getVelocity(history) {
    if (history.length < this.params.velocity_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.velocity_period];
    return (current - past) / past / this.params.velocity_period;
  }
  getAcceleration(velocities) {
    if (velocities.length < this.params.acceleration_period + 1)
      return 0;
    const current = velocities[velocities.length - 1];
    const past = velocities[velocities.length - 1 - this.params.acceleration_period];
    return current - past;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
      this.velocityHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    const velocities = this.velocityHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxPeriod = this.params.velocity_period + this.params.acceleration_period + 10;
    if (history.length > maxPeriod)
      history.shift();
    const velocity = this.getVelocity(history);
    velocities.push(velocity);
    if (velocities.length > this.params.acceleration_period + 5)
      velocities.shift();
    const acceleration = this.getAcceleration(velocities);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (acceleration < -this.params.acceleration_threshold) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (velocity > this.params.velocity_threshold && acceleration > this.params.acceleration_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_triple_ema_223.ts
import * as fs223 from "fs";
import * as path223 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams223 = {
  fast_period: 5,
  medium_period: 12,
  slow_period: 26,
  stop_loss: 0.05,
  trailing_stop: 0.03,
  risk_percent: 0.15
};
function loadSavedParams223() {
  const paramsPath = path223.join(__dirname, "strat_triple_ema_223.params.json");
  if (!fs223.existsSync(paramsPath))
    return null;
  try {
    const content = fs223.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams223) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class TripleEMA223Strategy {
  params;
  emaData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams223();
    this.params = { ...defaultParams223, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateEMA(tokenId) {
    if (!this.emaData.has(tokenId)) {
      this.emaData.set(tokenId, { fast: null, medium: null, slow: null });
    }
    return this.emaData.get(tokenId);
  }
  updateEMA(current, price, period) {
    const k = 2 / (period + 1);
    if (current === null)
      return price;
    return price * k + current * (1 - k);
  }
  onNext(ctx, bar) {
    const ema = this.getOrCreateEMA(bar.tokenId);
    ema.fast = this.updateEMA(ema.fast, bar.close, this.params.fast_period);
    ema.medium = this.updateEMA(ema.medium, bar.close, this.params.medium_period);
    ema.slow = this.updateEMA(ema.slow, bar.close, this.params.slow_period);
    if (ema.fast === null || ema.medium === null || ema.slow === null)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (ema.fast < ema.medium) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (ema.fast > ema.medium && ema.medium > ema.slow && bar.close > ema.fast) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_mean_rev_momentum_224.ts
import * as fs224 from "fs";
import * as path224 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams224 = {
  lookback: 20,
  oversold_percentile: 20,
  momentum_period: 3,
  momentum_threshold: 0.005,
  stop_loss: 0.05,
  take_profit: 0.08,
  risk_percent: 0.15
};
function loadSavedParams224() {
  const paramsPath = path224.join(__dirname, "strat_mean_rev_momentum_224.params.json");
  if (!fs224.existsSync(paramsPath))
    return null;
  try {
    const content = fs224.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams224) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MeanRevMomentum224Strategy {
  params;
  priceHistory = new Map;
  entryPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams224();
    this.params = { ...defaultParams224, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getPercentile(history, current) {
    if (history.length < 2)
      return 50;
    const sorted = [...history].sort((a, b) => a - b);
    let count = 0;
    for (const v of sorted) {
      if (v < current)
        count++;
    }
    return count / sorted.length * 100;
  }
  getMomentum(history) {
    if (history.length < this.params.momentum_period + 1)
      return 0;
    const current = history[history.length - 1];
    const past = history[history.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    if (!this.priceHistory.has(bar.tokenId)) {
      this.priceHistory.set(bar.tokenId, []);
    }
    const history = this.priceHistory.get(bar.tokenId);
    history.push(bar.close);
    const maxPeriod = Math.max(this.params.lookback, this.params.momentum_period + 1) + 5;
    if (history.length > maxPeriod)
      history.shift();
    const percentile2 = this.getPercentile(history.slice(0, -1), bar.close);
    const momentum = this.getMomentum(history);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      if (entry) {
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close > entry * (1 + this.params.take_profit)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          return;
        }
        if (percentile2 > 80) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (percentile2 <= this.params.oversold_percentile && momentum > this.params.momentum_threshold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_225.ts
import * as fs225 from "fs";
import * as path225 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams225 = {
  base_lookback: 15,
  min_lookback: 8,
  max_lookback: 30,
  volatility_period: 12,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.09,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams225() {
  const paramsPath = path225.join(__dirname, "strat_sr_adaptive_225.params.json");
  if (!fs225.existsSync(paramsPath))
    return null;
  try {
    const content = fs225.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams225) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptive225Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams225();
    this.params = { ...defaultParams225, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_exit_226.ts
import * as fs226 from "fs";
import * as path226 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams226 = {
  lookback: 15,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.09,
  trailing_stop: 0.05,
  profit_target: 0.15,
  max_hold_bars: 50,
  risk_percent: 0.15
};
function loadSavedParams226() {
  const paramsPath = path226.join(__dirname, "strat_sr_multi_exit_226.params.json");
  if (!fs226.existsSync(paramsPath))
    return null;
  try {
    const content = fs226.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams226) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiExit226Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams226();
    this.params = { ...defaultParams226, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.stoch_k_period) + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_momentum_filter_227.ts
import * as fs227 from "fs";
import * as path227 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams227 = {
  lookback: 15,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  momentum_period: 5,
  momentum_min: 0.005,
  stop_loss: 0.09,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams227() {
  const paramsPath = path227.join(__dirname, "strat_sr_momentum_filter_227.params.json");
  if (!fs227.existsSync(paramsPath))
    return null;
  try {
    const content = fs227.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams227) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMomentumFilter227Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams227();
    this.params = { ...defaultParams227, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  getMomentum(data) {
    if (data.prices.length < this.params.momentum_period + 1)
      return 0;
    const current = data.prices[data.prices.length - 1];
    const past = data.prices[data.prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.stoch_k_period, this.params.momentum_period) + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    const momentum = this.getMomentum(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const momentumPositive = momentum >= this.params.momentum_min;
      if (nearSupport && bouncing && stochOversold && momentumPositive) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_pivot_point_228.ts
import * as fs228 from "fs";
import * as path228 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams228 = {
  pivot_period: 20,
  bounce_threshold: 0.025,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams228() {
  const paramsPath = path228.join(__dirname, "strat_pivot_point_228.params.json");
  if (!fs228.existsSync(paramsPath))
    return null;
  try {
    const content = fs228.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams228) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class PivotPoint228Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams228();
    this.params = { ...defaultParams228, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        highs: [],
        lows: [],
        closes: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calculatePivotLevels(data) {
    if (data.highs.length < this.params.pivot_period)
      return null;
    const recentHighs = data.highs.slice(-this.params.pivot_period);
    const recentLows = data.lows.slice(-this.params.pivot_period);
    const recentCloses = data.closes.slice(-this.params.pivot_period);
    const high = Math.max(...recentHighs);
    const low = Math.min(...recentLows);
    const close = recentCloses[recentCloses.length - 1];
    const pivot = (high + low + close) / 3;
    const s1 = 2 * pivot - high;
    const s2 = pivot - (high - low);
    const r1 = 2 * pivot - low;
    const r2 = pivot + (high - low);
    return { pivot, s1, s2, r1, r2 };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    data.closes.push(bar.close);
    const maxPeriod = this.params.pivot_period + 10;
    if (data.highs.length > maxPeriod) {
      data.highs.shift();
      data.lows.shift();
      data.closes.shift();
    }
    const levels = this.calculatePivotLevels(data);
    if (!levels)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevClose = data.closes.length > 1 ? data.closes[data.closes.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= levels.r1) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearS1 = Math.abs(bar.close - levels.s1) / levels.s1 < this.params.bounce_threshold;
      const nearS2 = Math.abs(bar.close - levels.s2) / levels.s2 < this.params.bounce_threshold;
      const bouncing = bar.close > prevClose;
      if ((nearS1 || nearS2) && bouncing) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_range_mean_revert_229.ts
import * as fs229 from "fs";
import * as path229 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams229 = {
  lookback: 25,
  range_percentile: 0.1,
  oversold_percentile: 0.15,
  overbought_percentile: 0.85,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams229() {
  const paramsPath = path229.join(__dirname, "strat_range_mean_revert_229.params.json");
  if (!fs229.existsSync(paramsPath))
    return null;
  try {
    const content = fs229.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams229) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RangeMeanRevert229Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams229();
    this.params = { ...defaultParams229, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, { prices: [] });
    }
    return this.tokenData.get(tokenId);
  }
  isRangeBound(data) {
    if (data.prices.length < this.params.lookback)
      return false;
    const recentPrices = data.prices.slice(-this.params.lookback);
    const high = Math.max(...recentPrices);
    const low = Math.min(...recentPrices);
    const mean2 = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
    const range = (high - low) / mean2;
    return range < this.params.range_percentile * 2;
  }
  getPercentileRank(data) {
    if (data.prices.length < this.params.lookback)
      return 0.5;
    const recentPrices = data.prices.slice(-this.params.lookback);
    const currentPrice = data.prices[data.prices.length - 1];
    const high = Math.max(...recentPrices);
    const low = Math.min(...recentPrices);
    if (high === low)
      return 0.5;
    return (currentPrice - low) / (high - low);
  }
  getMean(data) {
    if (data.prices.length < this.params.lookback)
      return data.prices[data.prices.length - 1];
    const recentPrices = data.prices.slice(-this.params.lookback);
    return recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    const maxPeriod = this.params.lookback + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
    }
    const percentileRank = this.getPercentileRank(data);
    const mean2 = this.getMean(data);
    const rangeBound = this.isRangeBound(data);
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= mean2) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (percentileRank >= this.params.overbought_percentile) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const oversold = percentileRank <= this.params.oversold_percentile;
      const bouncing = bar.close > prevPrice;
      if (rangeBound && oversold && bouncing) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_breakout_confirmation_230.ts
import * as fs230 from "fs";
import * as path230 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams230 = {
  lookback: 20,
  breakout_threshold: 0.015,
  volatility_period: 12,
  volatility_multiplier: 1.2,
  stop_loss: 0.07,
  trailing_stop: 0.045,
  risk_percent: 0.15
};
function loadSavedParams230() {
  const paramsPath = path230.join(__dirname, "strat_breakout_confirmation_230.params.json");
  if (!fs230.existsSync(paramsPath))
    return null;
  try {
    const content = fs230.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams230) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class BreakoutConfirmation230Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams230();
    this.params = { ...defaultParams230, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, { prices: [], highs: [] });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getResistance(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback - 1, -1);
    return Math.max(...recentHighs);
  }
  isVolatilityHigh(data) {
    if (data.prices.length < this.params.volatility_period * 2)
      return false;
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period * 2, -this.params.volatility_period));
    if (historicalVol === 0)
      return false;
    return recentVol > historicalVol * this.params.volatility_multiplier;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    const maxPeriod = Math.max(this.params.lookback, this.params.volatility_period * 2) + 10;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
    }
    const resistance = this.getResistance(data);
    const highVolatility = this.isVolatilityHigh(data);
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      if (resistance !== null) {
        const breakoutAmount = (bar.close - resistance) / resistance;
        const isBreakout = breakoutAmount > this.params.breakout_threshold;
        if (isBreakout && highVolatility) {
          const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
          const size = cash / bar.close;
          if (size > 0 && cash <= ctx.getCapital()) {
            const result = ctx.buy(bar.tokenId, size);
            if (result.success) {
              this.entryPrice.set(bar.tokenId, bar.close);
              this.highestPrice.set(bar.tokenId, bar.close);
            }
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_stoch_rsi_231.ts
import * as fs231 from "fs";
import * as path231 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams231 = {
  rsi_period: 14,
  stoch_period: 14,
  k_smooth: 3,
  d_smooth: 3,
  oversold: 20,
  overbought: 80,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams231() {
  const paramsPath = path231.join(__dirname, "strat_stoch_rsi_231.params.json");
  if (!fs231.existsSync(paramsPath))
    return null;
  try {
    const content = fs231.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams231) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class StochRSI231Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams231();
    this.params = { ...defaultParams231, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        rsiValues: [],
        kValues: [],
        dValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calculateRSI(data) {
    if (data.prices.length < this.params.rsi_period + 1)
      return null;
    const prices = data.prices.slice(-this.params.rsi_period - 1);
    let gains = 0;
    let losses = 0;
    for (let i = 1;i < prices.length; i++) {
      const change = prices[i] - prices[i - 1];
      if (change > 0) {
        gains += change;
      } else {
        losses -= change;
      }
    }
    if (losses === 0)
      return 100;
    if (gains === 0)
      return 0;
    const rs = gains / this.params.rsi_period / (losses / this.params.rsi_period);
    return 100 - 100 / (1 + rs);
  }
  calculateStochRSI(data) {
    if (data.rsiValues.length < this.params.stoch_period)
      return null;
    const rsiSlice = data.rsiValues.slice(-this.params.stoch_period);
    const high = Math.max(...rsiSlice);
    const low = Math.min(...rsiSlice);
    const current = data.rsiValues[data.rsiValues.length - 1];
    if (high === low)
      return null;
    const rawK = (current - low) / (high - low) * 100;
    data.kValues.push(rawK);
    if (data.kValues.length > this.params.k_smooth)
      data.kValues.shift();
    if (data.kValues.length < this.params.k_smooth)
      return null;
    const k = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    data.dValues.push(k);
    if (data.dValues.length > this.params.d_smooth)
      data.dValues.shift();
    if (data.dValues.length < this.params.d_smooth)
      return null;
    const d = data.dValues.reduce((a, b) => a + b, 0) / data.dValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    const maxPeriod = this.params.rsi_period + this.params.stoch_period + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
    }
    const rsi = this.calculateRSI(data);
    if (rsi !== null) {
      data.rsiValues.push(rsi);
      if (data.rsiValues.length > this.params.stoch_period + 10) {
        data.rsiValues.shift();
      }
    }
    const stochRSI = this.calculateStochRSI(data);
    if (!stochRSI)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (stochRSI.k >= this.params.overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const oversold = stochRSI.k <= this.params.oversold;
      const crossingUp = stochRSI.k > stochRSI.d;
      const bouncing = bar.close > prevPrice;
      if (oversold && crossingUp && bouncing) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_channel_breakout_232.ts
import * as fs232 from "fs";
import * as path232 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams232 = {
  channel_period: 20,
  entry_threshold: 0.01,
  confirmation_bars: 2,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams232() {
  const paramsPath = path232.join(__dirname, "strat_channel_breakout_232.params.json");
  if (!fs232.existsSync(paramsPath))
    return null;
  try {
    const content = fs232.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams232) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ChannelBreakout232Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams232();
    this.params = { ...defaultParams232, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        highs: [],
        lows: [],
        closes: [],
        breakoutBars: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  getChannel(data) {
    if (data.highs.length < this.params.channel_period)
      return null;
    const highs = data.highs.slice(-this.params.channel_period - 1, -1);
    const lows = data.lows.slice(-this.params.channel_period - 1, -1);
    const upper = Math.max(...highs);
    const lower = Math.min(...lows);
    const mid = (upper + lower) / 2;
    return { upper, lower, mid };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    data.closes.push(bar.close);
    const maxPeriod = this.params.channel_period + 10;
    if (data.highs.length > maxPeriod) {
      data.highs.shift();
      data.lows.shift();
      data.closes.shift();
    }
    const channel = this.getChannel(data);
    if (!channel)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          data.breakoutBars = 0;
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          data.breakoutBars = 0;
          return;
        }
        if (bar.close < channel.mid) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          data.breakoutBars = 0;
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const breakoutAmount = (bar.close - channel.upper) / channel.upper;
      const isBreakout = breakoutAmount > this.params.entry_threshold;
      if (isBreakout) {
        data.breakoutBars++;
      } else {
        data.breakoutBars = 0;
      }
      if (data.breakoutBars >= this.params.confirmation_bars) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            data.breakoutBars = 0;
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_tweak_233.ts
import * as fs233 from "fs";
import * as path233 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams233 = {
  base_lookback: 20,
  min_lookback: 6,
  max_lookback: 40,
  volatility_period: 10,
  base_bounce_threshold: 0.03,
  vol_bounce_scale: 1.5,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.09,
  trailing_stop: 0.06,
  risk_percent: 0.16
};
function loadSavedParams233() {
  const paramsPath = path233.join(__dirname, "strat_sr_adaptive_tweak_233.params.json");
  if (!fs233.existsSync(paramsPath))
    return null;
  try {
    const content = fs233.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams233) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveTweak233Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams233();
    this.params = { ...defaultParams233, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getAdaptiveBounceThreshold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_bounce_threshold;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return this.params.base_bounce_threshold * (1 + recentVol * this.params.vol_bounce_scale);
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const adaptiveBounce = this.getAdaptiveBounceThreshold(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < adaptiveBounce);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_multi_exit_234.ts
import * as fs234 from "fs";
import * as path234 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams234 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.09,
  trailing_stop: 0.06,
  profit_target: 0.12,
  max_hold_bars: 50,
  risk_percent: 0.16
};
function loadSavedParams234() {
  const paramsPath = path234.join(__dirname, "strat_sr_adaptive_multi_exit_234.params.json");
  if (!fs234.existsSync(paramsPath))
    return null;
  try {
    const content = fs234.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams234) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveMultiExit234Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams234();
    this.params = { ...defaultParams234, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_momentum_235.ts
import * as fs235 from "fs";
import * as path235 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams235 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  momentum_period: 5,
  momentum_min: 0.005,
  stop_loss: 0.09,
  trailing_stop: 0.06,
  risk_percent: 0.16
};
function loadSavedParams235() {
  const paramsPath = path235.join(__dirname, "strat_sr_adaptive_momentum_235.params.json");
  if (!fs235.existsSync(paramsPath))
    return null;
  try {
    const content = fs235.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams235) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveMomentum235Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams235();
    this.params = { ...defaultParams235, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  getMomentum(data) {
    if (data.prices.length < this.params.momentum_period + 1)
      return 0;
    const current = data.prices[data.prices.length - 1];
    const past = data.prices[data.prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    const momentum = this.getMomentum(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const momentumPositive = momentum >= this.params.momentum_min;
      if (nearSupport && bouncing && stochOversold && momentumPositive) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_rsi_adaptive_support_236.ts
import * as fs236 from "fs";
import * as path236 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams236 = {
  rsi_period: 14,
  rsi_oversold: 30,
  rsi_overbought: 70,
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams236() {
  const paramsPath = path236.join(__dirname, "strat_rsi_adaptive_support_236.params.json");
  if (!fs236.existsSync(paramsPath))
    return null;
  try {
    const content = fs236.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams236) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class RSIAdaptiveSupport236Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams236();
    this.params = { ...defaultParams236, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, { prices: [], highs: [], lows: [] });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  calculateRSI(data) {
    if (data.prices.length < this.params.rsi_period + 1)
      return null;
    const prices = data.prices.slice(-this.params.rsi_period - 1);
    let gains = 0;
    let losses = 0;
    for (let i = 1;i < prices.length; i++) {
      const change = prices[i] - prices[i - 1];
      if (change > 0) {
        gains += change;
      } else {
        losses -= change;
      }
    }
    if (losses === 0)
      return 100;
    if (gains === 0)
      return 0;
    const rs = gains / this.params.rsi_period / (losses / this.params.rsi_period);
    return 100 - 100 / (1 + rs);
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const rsi = this.calculateRSI(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (rsi === null || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || rsi >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const rsiOversold = rsi <= this.params.rsi_oversold;
      if (nearSupport && bouncing && rsiOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_dynamic_stoch_237.ts
import * as fs237 from "fs";
import * as path237 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams237 = {
  lookback: 20,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  base_oversold: 25,
  base_overbought: 75,
  vol_period: 12,
  vol_scale: 100,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams237() {
  const paramsPath = path237.join(__dirname, "strat_dynamic_stoch_237.params.json");
  if (!fs237.existsSync(paramsPath))
    return null;
  try {
    const content = fs237.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams237) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class DynamicStoch237Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams237();
    this.params = { ...defaultParams237, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getDynamicThresholds(data) {
    if (data.prices.length < this.params.vol_period) {
      return { oversold: this.params.base_oversold, overbought: this.params.base_overbought };
    }
    const vol = this.calcVolatility(data.prices.slice(-this.params.vol_period));
    const adjustment = vol * this.params.vol_scale;
    const oversold = Math.max(10, this.params.base_oversold - adjustment);
    const overbought = Math.min(90, this.params.base_overbought + adjustment);
    return { oversold, overbought };
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.vol_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    const { oversold, overbought } = this.getDynamicThresholds(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_volatility_sizing_238.ts
import * as fs238 from "fs";
import * as path238 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams238 = {
  lookback: 20,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  vol_period: 12,
  base_risk: 0.15,
  min_risk: 0.08,
  max_risk: 0.25,
  vol_scale: 2,
  stop_loss: 0.08,
  trailing_stop: 0.05
};
function loadSavedParams238() {
  const paramsPath = path238.join(__dirname, "strat_volatility_sizing_238.params.json");
  if (!fs238.existsSync(paramsPath))
    return null;
  try {
    const content = fs238.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams238) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class VolatilitySizing238Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams238();
    this.params = { ...defaultParams238, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getVolatilityAdjustedRisk(data) {
    if (data.prices.length < this.params.vol_period) {
      return this.params.base_risk;
    }
    const vol = this.calcVolatility(data.prices.slice(-this.params.vol_period));
    const adjustedRisk = this.params.base_risk / (1 + vol * this.params.vol_scale);
    return Math.max(this.params.min_risk, Math.min(this.params.max_risk, adjustedRisk));
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.vol_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const riskPercent = this.getVolatilityAdjustedRisk(data);
        const cash = ctx.getCapital() * riskPercent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_atr_trailing_239.ts
import * as fs239 from "fs";
import * as path239 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams239 = {
  lookback: 20,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  atr_period: 14,
  atr_multiplier: 2,
  stop_loss: 0.1,
  risk_percent: 0.15
};
function loadSavedParams239() {
  const paramsPath = path239.join(__dirname, "strat_atr_trailing_239.params.json");
  if (!fs239.existsSync(paramsPath))
    return null;
  try {
    const content = fs239.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams239) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class ATRTrailing239Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams239();
    this.params = { ...defaultParams239, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        trueRanges: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calculateATR(data) {
    if (data.trueRanges.length < this.params.atr_period)
      return null;
    const recentTR = data.trueRanges.slice(-this.params.atr_period);
    return recentTR.reduce((a, b) => a + b, 0) / recentTR.length;
  }
  findSupportLevels(data) {
    if (data.lows.length < this.params.lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    if (data.prices.length > 0) {
      const prevClose = data.prices[data.prices.length - 1];
      const tr = Math.max(bar.high - bar.low, Math.abs(bar.high - prevClose), Math.abs(bar.low - prevClose));
      data.trueRanges.push(tr);
      if (data.trueRanges.length > this.params.atr_period + 10) {
        data.trueRanges.shift();
      }
    }
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.lookback, this.params.atr_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const atr = this.calculateATR(data);
    const supports = this.findSupportLevels(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (atr !== null) {
          const trailingStop = newHighest - atr * this.params.atr_multiplier;
          if (bar.close < trailingStop) {
            ctx.close(bar.tokenId);
            this.entryPrice.delete(bar.tokenId);
            this.highestPrice.delete(bar.tokenId);
            return;
          }
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_multi_timeframe_sr_240.ts
import * as fs240 from "fs";
import * as path240 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams240 = {
  short_lookback: 10,
  long_lookback: 30,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams240() {
  const paramsPath = path240.join(__dirname, "strat_multi_timeframe_sr_240.params.json");
  if (!fs240.existsSync(paramsPath))
    return null;
  try {
    const content = fs240.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams240) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class MultiTimeframeSR240Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams240();
    this.params = { ...defaultParams240, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  findShortTermSupport(data) {
    if (data.lows.length < this.params.short_lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.short_lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 2);
  }
  findLongTermSupport(data) {
    if (data.lows.length < this.params.long_lookback)
      return [];
    const recentLows = data.lows.slice(-this.params.long_lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 2);
  }
  findResistanceLevel(data) {
    if (data.highs.length < this.params.long_lookback)
      return null;
    const recentHighs = data.highs.slice(-this.params.long_lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  isNearSupport(price, shortSupports, longSupports) {
    const threshold = this.params.bounce_threshold;
    const nearShort = shortSupports.some((s) => Math.abs(price - s) / s < threshold);
    const nearLong = longSupports.some((s) => Math.abs(price - s) / s < threshold);
    const shortLongConfluence = shortSupports.some((ss) => longSupports.some((ls) => Math.abs(ss - ls) / ls < threshold * 2));
    return nearShort && (nearLong || shortLongConfluence);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.long_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const shortSupports = this.findShortTermSupport(data);
    const longSupports = this.findLongTermSupport(data);
    const resistance = this.findResistanceLevel(data);
    if (!stoch || shortSupports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = this.isNearSupport(bar.close, shortSupports, longSupports);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_exit_tweak_241.ts
import * as fs241 from "fs";
import * as path241 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams241 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  profit_target: 0.1,
  max_hold_bars: 35,
  risk_percent: 0.18
};
function loadSavedParams241() {
  const paramsPath = path241.join(__dirname, "strat_sr_multi_exit_tweak_241.params.json");
  if (!fs241.existsSync(paramsPath))
    return null;
  try {
    const content = fs241.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams241) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiExitTweak241Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams241();
    this.params = { ...defaultParams241, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_tweak2_242.ts
import * as fs242 from "fs";
import * as path242 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams242 = {
  base_lookback: 20,
  min_lookback: 6,
  max_lookback: 40,
  volatility_period: 12,
  base_bounce_threshold: 0.025,
  vol_bounce_scale: 2,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.18
};
function loadSavedParams242() {
  const paramsPath = path242.join(__dirname, "strat_sr_adaptive_tweak2_242.params.json");
  if (!fs242.existsSync(paramsPath))
    return null;
  try {
    const content = fs242.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams242) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveTweak2_242Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams242();
    this.params = { ...defaultParams242, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getAdaptiveBounceThreshold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_bounce_threshold;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return this.params.base_bounce_threshold + recentVol * this.params.vol_bounce_scale;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const bounceThreshold = this.getAdaptiveBounceThreshold(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < bounceThreshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_momentum_tweak_243.ts
import * as fs243 from "fs";
import * as path243 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams243 = {
  base_lookback: 22,
  min_lookback: 6,
  max_lookback: 40,
  volatility_period: 12,
  bounce_threshold: 0.04,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 28,
  stoch_overbought: 68,
  momentum_period: 4,
  momentum_min: 0.003,
  stop_loss: 0.1,
  trailing_stop: 0.055,
  risk_percent: 0.17
};
function loadSavedParams243() {
  const paramsPath = path243.join(__dirname, "strat_sr_momentum_tweak_243.params.json");
  if (!fs243.existsSync(paramsPath))
    return null;
  try {
    const content = fs243.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams243) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMomentumTweak243Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams243();
    this.params = { ...defaultParams243, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const hasMomentum = momentum >= this.params.momentum_min;
      if (nearSupport && bouncing && stochOversold && hasMomentum) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_momentum_244.ts
import * as fs244 from "fs";
import * as path244 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams244 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.038,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 27,
  stoch_overbought: 67,
  momentum_period: 4,
  momentum_min: 0.004,
  stop_loss: 0.09,
  trailing_stop: 0.055,
  profit_target: 0.1,
  max_hold_bars: 45,
  risk_percent: 0.17
};
function loadSavedParams244() {
  const paramsPath = path244.join(__dirname, "strat_sr_multi_momentum_244.params.json");
  if (!fs244.existsSync(paramsPath))
    return null;
  try {
    const content = fs244.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams244) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiMomentum244Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams244();
    this.params = { ...defaultParams244, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const hasMomentum = momentum >= this.params.momentum_min;
      if (nearSupport && bouncing && stochOversold && hasMomentum) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_rsi_confirm_245.ts
import * as fs245 from "fs";
import * as path245 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams245 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  rsi_period: 14,
  rsi_oversold: 35,
  rsi_overbought: 65,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 30,
  stoch_overbought: 70,
  stop_loss: 0.09,
  trailing_stop: 0.055,
  risk_percent: 0.16
};
function loadSavedParams245() {
  const paramsPath = path245.join(__dirname, "strat_sr_rsi_confirm_245.params.json");
  if (!fs245.existsSync(paramsPath))
    return null;
  try {
    const content = fs245.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams245) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRRSIConfirm245Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams245();
    this.params = { ...defaultParams245, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        gains: [],
        losses: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getRSI(data) {
    if (data.prices.length < this.params.rsi_period + 1)
      return null;
    const current = data.prices[data.prices.length - 1];
    const prev = data.prices[data.prices.length - 2];
    const change = current - prev;
    const gain = change > 0 ? change : 0;
    const loss = change < 0 ? -change : 0;
    data.gains.push(gain);
    data.losses.push(loss);
    if (data.gains.length > this.params.rsi_period) {
      data.gains.shift();
      data.losses.shift();
    }
    if (data.gains.length < this.params.rsi_period)
      return null;
    const avgGain = data.gains.reduce((a, b) => a + b, 0) / this.params.rsi_period;
    const avgLoss = data.losses.reduce((a, b) => a + b, 0) / this.params.rsi_period;
    if (avgLoss === 0)
      return 100;
    const rs = avgGain / avgLoss;
    return 100 - 100 / (1 + rs);
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const rsi = this.getRSI(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || rsi === null || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought || rsi >= this.params.rsi_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const rsiOversold = rsi <= this.params.rsi_oversold;
      if (nearSupport && bouncing && stochOversold && rsiOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_asymmetric_246.ts
import * as fs246 from "fs";
import * as path246 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams246 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  stop_loss: 0.06,
  trailing_stop: 0.05,
  target_multiplier: 2.5,
  risk_percent: 0.16
};
function loadSavedParams246() {
  const paramsPath = path246.join(__dirname, "strat_sr_asymmetric_246.params.json");
  if (!fs246.existsSync(paramsPath))
    return null;
  try {
    const content = fs246.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams246) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAsymmetric246Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams246();
    this.params = { ...defaultParams246, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    const profitTarget = this.params.stop_loss * this.params.target_multiplier;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + profitTarget)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_trend_strength_247.ts
import * as fs247 from "fs";
import * as path247 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams247 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  trend_period: 20,
  trend_threshold: -0.02,
  stop_loss: 0.09,
  trailing_stop: 0.055,
  risk_percent: 0.16
};
function loadSavedParams247() {
  const paramsPath = path247.join(__dirname, "strat_sr_trend_strength_247.params.json");
  if (!fs247.existsSync(paramsPath))
    return null;
  try {
    const content = fs247.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams247) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRTrendStrength247Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams247();
    this.params = { ...defaultParams247, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_double_confirm_248.ts
import * as fs248 from "fs";
import * as path248 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams248 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 28,
  stoch_overbought: 68,
  bounce_bars: 2,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  profit_target: 0.12,
  risk_percent: 0.17
};
function loadSavedParams248() {
  const paramsPath = path248.join(__dirname, "strat_sr_double_confirm_248.params.json");
  if (!fs248.existsSync(paramsPath))
    return null;
  try {
    const content = fs248.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams248) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRDoubleConfirm248Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams248();
    this.params = { ...defaultParams248, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0,
        nearSupport: false
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
    const bouncing = bar.close > prevPrice;
    if (nearSupport && bouncing) {
      data.consecutiveBounces++;
    } else if (!nearSupport) {
      data.consecutiveBounces = 0;
    }
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const confirmedBounce = data.consecutiveBounces >= this.params.bounce_bars;
      if (nearSupport && bouncing && stochOversold && confirmedBounce) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            data.consecutiveBounces = 0;
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_trend_strict_249.ts
import * as fs249 from "fs";
import * as path249 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams249 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  trend_period: 25,
  trend_threshold: 0.01,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  risk_percent: 0.15
};
function loadSavedParams249() {
  const paramsPath = path249.join(__dirname, "strat_sr_trend_strict_249.params.json");
  if (!fs249.existsSync(paramsPath))
    return null;
  try {
    const content = fs249.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams249) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRTrendStrict249Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams249();
    this.params = { ...defaultParams249, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_trend_250.ts
import * as fs250 from "fs";
import * as path250 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams250 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 65,
  trend_period: 20,
  trend_threshold: -0.02,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  profit_target: 0.1,
  max_hold_bars: 35,
  risk_percent: 0.17
};
function loadSavedParams250() {
  const paramsPath = path250.join(__dirname, "strat_sr_multi_trend_250.params.json");
  if (!fs250.existsSync(paramsPath))
    return null;
  try {
    const content = fs250.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams250) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiTrend250Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams250();
    this.params = { ...defaultParams250, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_target_251.ts
import * as fs251 from "fs";
import * as path251 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams251 = {
  base_lookback: 20,
  min_lookback: 6,
  max_lookback: 40,
  volatility_period: 12,
  base_bounce_threshold: 0.025,
  vol_bounce_scale: 2,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  profit_target: 0.12,
  risk_percent: 0.17
};
function loadSavedParams251() {
  const paramsPath = path251.join(__dirname, "strat_sr_adaptive_target_251.params.json");
  if (!fs251.existsSync(paramsPath))
    return null;
  try {
    const content = fs251.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams251) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveTarget251Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams251();
    this.params = { ...defaultParams251, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getAdaptiveBounceThreshold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_bounce_threshold;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return this.params.base_bounce_threshold + recentVol * this.params.vol_bounce_scale;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = this.params.max_lookback + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const bounceThreshold = this.getAdaptiveBounceThreshold(data);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < bounceThreshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      if (nearSupport && bouncing && stochOversold) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_momentum_trend_252.ts
import * as fs252 from "fs";
import * as path252 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams252 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  momentum_period: 5,
  momentum_threshold: 0.005,
  trend_period: 20,
  trend_threshold: -0.01,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.16
};
function loadSavedParams252() {
  const paramsPath = path252.join(__dirname, "strat_sr_momentum_trend_252.params.json");
  if (!fs252.existsSync(paramsPath))
    return null;
  try {
    const content = fs252.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams252) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMomentumTrend252Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams252();
    this.params = { ...defaultParams252, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period, this.params.momentum_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const momentum = this.getMomentum(data.prices);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && momentumOk && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_triple_confirm_253.ts
import * as fs253 from "fs";
import * as path253 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams253 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.03,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 20,
  stoch_overbought: 75,
  momentum_period: 5,
  momentum_threshold: 0.003,
  trend_period: 25,
  trend_threshold: -0.01,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  profit_target: 0.15,
  risk_percent: 0.18
};
function loadSavedParams253() {
  const paramsPath = path253.join(__dirname, "strat_sr_triple_confirm_253.params.json");
  if (!fs253.existsSync(paramsPath))
    return null;
  try {
    const content = fs253.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams253) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRTripleConfirm253Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams253();
    this.params = { ...defaultParams253, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period, this.params.momentum_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const momentum = this.getMomentum(data.prices);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && momentumOk && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_range_vol_254.ts
import * as fs254 from "fs";
import * as path254 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams254 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  range_period: 10,
  range_multiplier: 1.2,
  trend_period: 20,
  trend_threshold: -0.02,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.16
};
function loadSavedParams254() {
  const paramsPath = path254.join(__dirname, "strat_sr_range_vol_254.params.json");
  if (!fs254.existsSync(paramsPath))
    return null;
  try {
    const content = fs254.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams254) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRRangeVol254Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams254();
    this.params = { ...defaultParams254, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        ranges: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  isRangeExpansion(data, currentRange) {
    if (data.ranges.length < this.params.range_period)
      return true;
    const recentRanges = data.ranges.slice(-this.params.range_period);
    const avgRange = recentRanges.reduce((a, b) => a + b, 0) / recentRanges.length;
    return currentRange >= avgRange * this.params.range_multiplier;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    const currentRange = bar.high - bar.low;
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    data.ranges.push(currentRange);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period, this.params.range_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
      data.ranges.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const rangeExpansion = this.isRangeExpansion(data, currentRange);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && trendOk && rangeExpansion) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_long_trend_255.ts
import * as fs255 from "fs";
import * as path255 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams255 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  short_trend_period: 10,
  long_trend_period: 40,
  short_trend_threshold: -0.02,
  long_trend_threshold: -0.05,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.16
};
function loadSavedParams255() {
  const paramsPath = path255.join(__dirname, "strat_sr_long_trend_255.params.json");
  if (!fs255.existsSync(paramsPath))
    return null;
  try {
    const content = fs255.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams255) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRLongTrend255Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams255();
    this.params = { ...defaultParams255, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrend(prices, period) {
    if (prices.length < period)
      return 0;
    const recent = prices.slice(-period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.long_trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const shortTrend = this.getTrend(data.prices, this.params.short_trend_period);
    const longTrend = this.getTrend(data.prices, this.params.long_trend_period);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const shortTrendOk = shortTrend >= this.params.short_trend_threshold;
      const longTrendOk = longTrend >= this.params.long_trend_threshold;
      if (nearSupport && bouncing && stochOversold && shortTrendOk && longTrendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_strict_entry_256.ts
import * as fs256 from "fs";
import * as path256 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams256 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.025,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 20,
  stoch_overbought: 75,
  trend_period: 20,
  trend_threshold: 0,
  momentum_period: 3,
  momentum_threshold: 0.005,
  min_bounce_bars: 2,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.2
};
function loadSavedParams256() {
  const paramsPath = path256.join(__dirname, "strat_sr_strict_entry_256.params.json");
  if (!fs256.existsSync(paramsPath))
    return null;
  try {
    const content = fs256.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams256) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRStrictEntry256Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams256();
    this.params = { ...defaultParams256, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_strict_loose_257.ts
import * as fs257 from "fs";
import * as path257 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams257 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.03,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 28,
  stoch_overbought: 72,
  trend_period: 20,
  trend_threshold: -0.01,
  momentum_period: 3,
  momentum_threshold: 0.004,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.2
};
function loadSavedParams257() {
  const paramsPath = path257.join(__dirname, "strat_sr_strict_loose_257.params.json");
  if (!fs257.existsSync(paramsPath))
    return null;
  try {
    const content = fs257.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams257) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRStrictLoose257Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams257();
    this.params = { ...defaultParams257, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_strict_momentum_258.ts
import * as fs258 from "fs";
import * as path258 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams258 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.028,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 75,
  trend_period: 25,
  trend_threshold: -0.015,
  momentum_period: 4,
  momentum_threshold: 0.002,
  min_bounce_bars: 2,
  stop_loss: 0.075,
  trailing_stop: 0.05,
  risk_percent: 0.22
};
function loadSavedParams258() {
  const paramsPath = path258.join(__dirname, "strat_sr_strict_momentum_258.params.json");
  if (!fs258.existsSync(paramsPath))
    return null;
  try {
    const content = fs258.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams258) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRStrictMomentum258Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams258();
    this.params = { ...defaultParams258, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_trend_multi_exit_259.ts
import * as fs259 from "fs";
import * as path259 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams259 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.035,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 70,
  trend_period: 25,
  trend_threshold: 0.01,
  stop_loss: 0.08,
  trailing_stop: 0.05,
  profit_target: 0.12,
  max_hold_bars: 40,
  risk_percent: 0.18
};
function loadSavedParams259() {
  const paramsPath = path259.join(__dirname, "strat_sr_trend_multi_exit_259.params.json");
  if (!fs259.existsSync(paramsPath))
    return null;
  try {
    const content = fs259.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams259) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRTrendMultiExit259Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams259();
    this.params = { ...defaultParams259, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      if (nearSupport && bouncing && stochOversold && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_strict_multi_exit_260.ts
import * as fs260 from "fs";
import * as path260 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams260 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.025,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 22,
  stoch_overbought: 75,
  trend_period: 22,
  trend_threshold: -0.005,
  momentum_period: 3,
  momentum_threshold: 0.005,
  min_bounce_bars: 2,
  stop_loss: 0.075,
  trailing_stop: 0.055,
  profit_target: 0.15,
  max_hold_bars: 35,
  risk_percent: 0.2
};
function loadSavedParams260() {
  const paramsPath = path260.join(__dirname, "strat_sr_strict_multi_exit_260.params.json");
  if (!fs260.existsSync(paramsPath))
    return null;
  try {
    const content = fs260.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams260) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRStrictMultiExit260Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams260();
    this.params = { ...defaultParams260, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_very_strict_261.ts
import * as fs261 from "fs";
import * as path261 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams261 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.022,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 18,
  stoch_overbought: 78,
  trend_period: 20,
  trend_threshold: 0.005,
  momentum_period: 3,
  momentum_threshold: 0.008,
  min_bounce_bars: 3,
  stop_loss: 0.07,
  trailing_stop: 0.05,
  risk_percent: 0.24
};
function loadSavedParams261() {
  const paramsPath = path261.join(__dirname, "strat_sr_very_strict_261.params.json");
  if (!fs261.existsSync(paramsPath))
    return null;
  try {
    const content = fs261.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams261) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRVeryStrict261Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams261();
    this.params = { ...defaultParams261, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_bounce_quality_262.ts
import * as fs262 from "fs";
import * as path262 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams262 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.03,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 72,
  trend_period: 20,
  trend_threshold: -0.01,
  min_bounce_bars: 2,
  min_bounce_gain: 0.01,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.2
};
function loadSavedParams262() {
  const paramsPath = path262.join(__dirname, "strat_sr_bounce_quality_262.params.json");
  if (!fs262.existsSync(paramsPath))
    return null;
  try {
    const content = fs262.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams262) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRBounceQuality262Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams262();
    this.params = { ...defaultParams262, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0,
        bounceStartPrice: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      if (data.consecutiveBounces === 0) {
        data.bounceStartPrice = prevPrice;
      }
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
      data.bounceStartPrice = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      const bounceGain = data.bounceStartPrice > 0 ? (bar.close - data.bounceStartPrice) / data.bounceStartPrice : 0;
      const qualityBounce = bounceGain >= this.params.min_bounce_gain;
      if (nearSupport && multiBarBounce && qualityBounce && stochOversold && trendOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_weighted_trend_263.ts
import * as fs263 from "fs";
import * as path263 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams263 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.03,
  stoch_k_period: 14,
  stoch_d_period: 4,
  stoch_oversold: 25,
  stoch_overbought: 72,
  trend_period: 20,
  trend_weight: 0.6,
  momentum_period: 5,
  momentum_weight: 0.4,
  min_score: 0.003,
  stop_loss: 0.08,
  trailing_stop: 0.055,
  risk_percent: 0.18
};
function loadSavedParams263() {
  const paramsPath = path263.join(__dirname, "strat_sr_weighted_trend_263.params.json");
  if (!fs263.existsSync(paramsPath))
    return null;
  try {
    const content = fs263.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams263) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRWeightedTrend263Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams263();
    this.params = { ...defaultParams263, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: []
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  getWeightedScore(trend, momentum) {
    return trend * this.params.trend_weight + momentum * this.params.momentum_weight;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const weightedScore = this.getWeightedScore(trendStrength, momentum);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const bouncing = bar.close > prevPrice;
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const scoreOk = weightedScore >= this.params.min_score;
      if (nearSupport && bouncing && stochOversold && scoreOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_strict_264.ts
import * as fs264 from "fs";
import * as path264 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams264 = {
  base_lookback: 20,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 10,
  base_bounce_threshold: 0.025,
  vol_bounce_scale: 1.8,
  stoch_k_period: 14,
  stoch_d_period: 4,
  base_stoch_oversold: 22,
  stoch_overbought: 75,
  trend_period: 22,
  trend_threshold: -0.005,
  momentum_period: 3,
  momentum_threshold: 0.005,
  min_bounce_bars: 2,
  stop_loss: 0.075,
  trailing_stop: 0.055,
  risk_percent: 0.2
};
function loadSavedParams264() {
  const paramsPath = path264.join(__dirname, "strat_sr_adaptive_strict_264.params.json");
  if (!fs264.existsSync(paramsPath))
    return null;
  try {
    const content = fs264.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams264) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveStrict264Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams264();
    this.params = { ...defaultParams264, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getAdaptiveBounceThreshold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_bounce_threshold;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return this.params.base_bounce_threshold + recentVol * this.params.vol_bounce_scale;
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const adaptiveBounce = this.getAdaptiveBounceThreshold(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          ctx.close(bar.tokenId);
          this.entryPrice.delete(bar.tokenId);
          this.highestPrice.delete(bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < adaptiveBounce);
      const stochOversold = stoch.k <= this.params.base_stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_exit_high_pt_265.ts
import * as fs265 from "fs";
import * as path265 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams265 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  profit_target: 0.2,
  max_hold_bars: 50,
  risk_percent: 0.22
};
function loadSavedParams265() {
  const paramsPath = path265.join(__dirname, "strat_sr_multi_exit_high_pt_265.params.json");
  if (!fs265.existsSync(paramsPath))
    return null;
  try {
    const content = fs265.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams265) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiExitHighPT265Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams265();
    this.params = { ...defaultParams265, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_exit_short_hold_266.ts
import * as fs266 from "fs";
import * as path266 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams266 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  profit_target: 0.12,
  max_hold_bars: 25,
  risk_percent: 0.22
};
function loadSavedParams266() {
  const paramsPath = path266.join(__dirname, "strat_sr_multi_exit_short_hold_266.params.json");
  if (!fs266.existsSync(paramsPath))
    return null;
  try {
    const content = fs266.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams266) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiExitShortHold266Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams266();
    this.params = { ...defaultParams266, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_multi_exit_tight_trail_267.ts
import * as fs267 from "fs";
import * as path267 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams267 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.04,
  profit_target: 0.12,
  max_hold_bars: 40,
  risk_percent: 0.22
};
function loadSavedParams267() {
  const paramsPath = path267.join(__dirname, "strat_sr_multi_exit_tight_trail_267.params.json");
  if (!fs267.existsSync(paramsPath))
    return null;
  try {
    const content = fs267.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams267) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMultiExitTightTrail267Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams267();
    this.params = { ...defaultParams267, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_adaptive_multi_exit_268.ts
import * as fs268 from "fs";
import * as path268 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams268 = {
  base_lookback: 16,
  min_lookback: 8,
  max_lookback: 35,
  volatility_period: 14,
  base_bounce_threshold: 0.033,
  vol_bounce_scale: 1.4,
  stoch_k_period: 14,
  stoch_d_period: 3,
  base_stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.014,
  momentum_period: 2,
  momentum_threshold: 0.009,
  min_bounce_bars: 1,
  stop_loss: 0.1,
  trailing_stop: 0.05,
  profit_target: 0.12,
  max_hold_bars: 40,
  risk_percent: 0.24
};
function loadSavedParams268() {
  const paramsPath = path268.join(__dirname, "strat_sr_adaptive_multi_exit_268.params.json");
  if (!fs268.existsSync(paramsPath))
    return null;
  try {
    const content = fs268.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams268) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRAdaptiveMultiExit268Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams268();
    this.params = { ...defaultParams268, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getAdaptiveBounceThreshold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_bounce_threshold;
    }
    const vol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return this.params.base_bounce_threshold * (1 + vol * this.params.vol_bounce_scale);
  }
  getAdaptiveStochOversold(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_stoch_oversold;
    }
    const vol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    return Math.min(35, this.params.base_stoch_oversold + vol * 50);
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const adaptiveBounce = this.getAdaptiveBounceThreshold(data);
    const adaptiveOversold = this.getAdaptiveStochOversold(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < adaptiveBounce);
      const stochOversold = stoch.k <= adaptiveOversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_dynamic_pt_269.ts
import * as fs269 from "fs";
import * as path269 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams269 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 10,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  base_profit_target: 0.1,
  vol_pt_scale: 2,
  max_hold_bars: 40,
  risk_percent: 0.22
};
function loadSavedParams269() {
  const paramsPath = path269.join(__dirname, "strat_sr_dynamic_pt_269.params.json");
  if (!fs269.existsSync(paramsPath))
    return null;
  try {
    const content = fs269.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams269) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRDynamicPT269Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  dynamicPT = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams269();
    this.params = { ...defaultParams269, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0,
        entryVol: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
    this.dynamicPT.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    const currentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      const profitTarget = this.dynamicPT.get(bar.tokenId) ?? this.params.base_profit_target;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + profitTarget)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
            const dynamicProfitTarget = this.params.base_profit_target * (1 + currentVol * this.params.vol_pt_scale);
            this.dynamicPT.set(bar.tokenId, Math.min(0.25, dynamicProfitTarget));
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_tiered_exit_270.ts
import * as fs270 from "fs";
import * as path270 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams270 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  first_target: 0.08,
  second_target: 0.15,
  first_exit_pct: 0.5,
  max_hold_bars: 40,
  risk_percent: 0.22
};
function loadSavedParams270() {
  const paramsPath = path270.join(__dirname, "strat_sr_tiered_exit_270.params.json");
  if (!fs270.existsSync(paramsPath))
    return null;
  try {
    const content = fs270.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams270) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRTieredExit270Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  firstTargetHit = new Map;
  initialSize = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams270();
    this.params = { ...defaultParams270, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
    this.firstTargetHit.delete(tokenId);
    this.initialSize.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      const firstHit = this.firstTargetHit.get(bar.tokenId) ?? false;
      const initSize = this.initialSize.get(bar.tokenId) ?? position.size;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (!firstHit && bar.close >= entry * (1 + this.params.first_target)) {
          const sellSize = initSize * this.params.first_exit_pct;
          ctx.sell(bar.tokenId, sellSize);
          this.firstTargetHit.set(bar.tokenId, true);
          return;
        }
        if (firstHit && bar.close >= entry * (1 + this.params.second_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
            this.firstTargetHit.set(bar.tokenId, false);
            this.initialSize.set(bar.tokenId, size);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_momentum_exit_271.ts
import * as fs271 from "fs";
import * as path271 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams271 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 3,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  stop_loss: 0.08,
  base_trailing_stop: 0.07,
  momentum_trail_scale: 0.5,
  profit_target: 0.15,
  max_hold_bars: 40,
  risk_percent: 0.22
};
function loadSavedParams271() {
  const paramsPath = path271.join(__dirname, "strat_sr_momentum_exit_271.params.json");
  if (!fs271.existsSync(paramsPath))
    return null;
  try {
    const content = fs271.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams271) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRMomentumExit271Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams271();
    this.params = { ...defaultParams271, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        const dynamicTrail = momentum < 0 ? this.params.base_trailing_stop * (1 - this.params.momentum_trail_scale) : this.params.base_trailing_stop;
        if (bar.close < newHighest * (1 - dynamicTrail)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/strategies/strat_sr_rsi_exit_272.ts
import * as fs272 from "fs";
import * as path272 from "path";
var __dirname = "/Users/heinrich/Documents/testbtc/src/strategies";
var defaultParams272 = {
  base_lookback: 16,
  min_lookback: 6,
  max_lookback: 35,
  volatility_period: 8,
  bounce_threshold: 0.03,
  stoch_k_period: 16,
  stoch_d_period: 3,
  stoch_oversold: 20,
  stoch_overbought: 76,
  trend_period: 24,
  trend_threshold: -0.008,
  momentum_period: 2,
  momentum_threshold: 0.005,
  min_bounce_bars: 1,
  rsi_period: 14,
  rsi_overbought: 70,
  stop_loss: 0.08,
  trailing_stop: 0.06,
  profit_target: 0.15,
  max_hold_bars: 40,
  risk_percent: 0.22
};
function loadSavedParams272() {
  const paramsPath = path272.join(__dirname, "strat_sr_rsi_exit_272.params.json");
  if (!fs272.existsSync(paramsPath))
    return null;
  try {
    const content = fs272.readFileSync(paramsPath, "utf-8");
    const saved = JSON.parse(content);
    const params = {};
    for (const [key, value] of Object.entries(saved)) {
      if (key !== "metadata" && key in defaultParams272) {
        if (typeof value === "number") {
          params[key] = value;
        }
      }
    }
    return params;
  } catch {
    return null;
  }
}

class SRRsiExit272Strategy {
  params;
  tokenData = new Map;
  entryPrice = new Map;
  highestPrice = new Map;
  barsHeld = new Map;
  constructor(params = {}) {
    const savedParams = loadSavedParams272();
    this.params = { ...defaultParams272, ...savedParams, ...params };
  }
  onInit(_ctx) {}
  getOrCreateData(tokenId) {
    if (!this.tokenData.has(tokenId)) {
      this.tokenData.set(tokenId, {
        prices: [],
        highs: [],
        lows: [],
        kValues: [],
        gains: [],
        losses: [],
        consecutiveBounces: 0
      });
    }
    return this.tokenData.get(tokenId);
  }
  calcVolatility(prices) {
    if (prices.length < 2)
      return 0;
    const mean2 = prices.reduce((a, b) => a + b, 0) / prices.length;
    const sqDiffs = prices.reduce((sum, p) => sum + (p - mean2) * (p - mean2), 0);
    return Math.sqrt(sqDiffs / prices.length) / mean2;
  }
  getAdaptiveLookback(data) {
    if (data.prices.length < this.params.volatility_period) {
      return this.params.base_lookback;
    }
    const recentVol = this.calcVolatility(data.prices.slice(-this.params.volatility_period));
    const historicalVol = this.calcVolatility(data.prices.slice(-this.params.max_lookback));
    if (historicalVol === 0)
      return this.params.base_lookback;
    const volRatio = recentVol / historicalVol;
    let adaptiveLookback = Math.round(this.params.base_lookback / volRatio);
    return Math.max(this.params.min_lookback, Math.min(this.params.max_lookback, adaptiveLookback));
  }
  getTrendStrength(prices) {
    if (prices.length < this.params.trend_period)
      return 0;
    const recent = prices.slice(-this.params.trend_period);
    const first = recent[0];
    const last = recent[recent.length - 1];
    return (last - first) / first;
  }
  getMomentum(prices) {
    if (prices.length < this.params.momentum_period + 1)
      return 0;
    const current = prices[prices.length - 1];
    const past = prices[prices.length - 1 - this.params.momentum_period];
    return (current - past) / past;
  }
  getRSI(data) {
    if (data.prices.length < this.params.rsi_period + 1)
      return null;
    const len = data.prices.length;
    const change = data.prices[len - 1] - data.prices[len - 2];
    if (change > 0) {
      data.gains.push(change);
      data.losses.push(0);
    } else {
      data.gains.push(0);
      data.losses.push(Math.abs(change));
    }
    if (data.gains.length > this.params.rsi_period) {
      data.gains.shift();
      data.losses.shift();
    }
    if (data.gains.length < this.params.rsi_period)
      return null;
    const avgGain = data.gains.reduce((a, b) => a + b, 0) / this.params.rsi_period;
    const avgLoss = data.losses.reduce((a, b) => a + b, 0) / this.params.rsi_period;
    if (avgLoss === 0)
      return 100;
    const rs = avgGain / avgLoss;
    return 100 - 100 / (1 + rs);
  }
  findSupportLevels(data, lookback) {
    if (data.lows.length < lookback)
      return [];
    const recentLows = data.lows.slice(-lookback);
    const sorted = [...recentLows].sort((a, b) => a - b);
    return sorted.slice(0, 3);
  }
  findResistanceLevel(data, lookback) {
    if (data.highs.length < lookback)
      return null;
    const recentHighs = data.highs.slice(-lookback);
    return Math.max(...recentHighs);
  }
  getStochastic(data) {
    if (data.prices.length < this.params.stoch_k_period)
      return null;
    const slice = data.prices.slice(-this.params.stoch_k_period);
    const high = Math.max(...slice);
    const low = Math.min(...slice);
    const k = high === low ? 50 : (data.prices[data.prices.length - 1] - low) / (high - low) * 100;
    data.kValues.push(k);
    if (data.kValues.length > this.params.stoch_d_period)
      data.kValues.shift();
    if (data.kValues.length < this.params.stoch_d_period)
      return null;
    const d = data.kValues.reduce((a, b) => a + b, 0) / data.kValues.length;
    return { k, d };
  }
  closePosition(ctx, tokenId) {
    ctx.close(tokenId);
    this.entryPrice.delete(tokenId);
    this.highestPrice.delete(tokenId);
    this.barsHeld.delete(tokenId);
  }
  onNext(ctx, bar) {
    const data = this.getOrCreateData(bar.tokenId);
    data.prices.push(bar.close);
    data.highs.push(bar.high);
    data.lows.push(bar.low);
    const maxPeriod = Math.max(this.params.max_lookback, this.params.trend_period, this.params.rsi_period) + 20;
    if (data.prices.length > maxPeriod) {
      data.prices.shift();
      data.highs.shift();
      data.lows.shift();
    }
    const prevPrice = data.prices.length > 1 ? data.prices[data.prices.length - 2] : bar.close;
    if (bar.close > prevPrice) {
      data.consecutiveBounces++;
    } else {
      data.consecutiveBounces = 0;
    }
    const stoch = this.getStochastic(data);
    const rsi = this.getRSI(data);
    const adaptiveLookback = this.getAdaptiveLookback(data);
    const trendStrength = this.getTrendStrength(data.prices);
    const momentum = this.getMomentum(data.prices);
    const supports = this.findSupportLevels(data, adaptiveLookback);
    const resistance = this.findResistanceLevel(data, adaptiveLookback);
    if (!stoch || supports.length === 0)
      return;
    const position = ctx.getPosition(bar.tokenId);
    if (position && position.size > 0) {
      const entry = this.entryPrice.get(bar.tokenId);
      const highest = this.highestPrice.get(bar.tokenId) ?? bar.close;
      const bars = this.barsHeld.get(bar.tokenId) ?? 0;
      this.barsHeld.set(bar.tokenId, bars + 1);
      if (entry) {
        if (bar.close > highest) {
          this.highestPrice.set(bar.tokenId, bar.close);
        }
        const newHighest = this.highestPrice.get(bar.tokenId);
        if (bar.close < entry * (1 - this.params.stop_loss)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close < newHighest * (1 - this.params.trailing_stop)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bar.close >= entry * (1 + this.params.profit_target)) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (bars >= this.params.max_hold_bars) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (rsi !== null && rsi >= this.params.rsi_overbought) {
          this.closePosition(ctx, bar.tokenId);
          return;
        }
        if (resistance !== null && bar.close >= resistance || stoch.k >= this.params.stoch_overbought) {
          this.closePosition(ctx, bar.tokenId);
        }
      }
    } else if (bar.close > 0.05 && bar.close < 0.95) {
      const nearSupport = supports.some((s) => Math.abs(bar.close - s) / s < this.params.bounce_threshold);
      const stochOversold = stoch.k <= this.params.stoch_oversold && stoch.k > stoch.d;
      const trendOk = trendStrength >= this.params.trend_threshold;
      const momentumOk = momentum >= this.params.momentum_threshold;
      const multiBarBounce = data.consecutiveBounces >= this.params.min_bounce_bars;
      if (nearSupport && multiBarBounce && stochOversold && trendOk && momentumOk) {
        const cash = ctx.getCapital() * this.params.risk_percent * 0.995;
        const size = cash / bar.close;
        if (size > 0 && cash <= ctx.getCapital()) {
          const result = ctx.buy(bar.tokenId, size);
          if (result.success) {
            this.entryPrice.set(bar.tokenId, bar.close);
            this.highestPrice.set(bar.tokenId, bar.close);
            this.barsHeld.set(bar.tokenId, 0);
          }
        }
      }
    }
  }
  onComplete(_ctx) {}
}

// src/optimization/differential-evolution.ts
init_engine();
var import_cli_progress = __toESM(require_cli_progress(), 1);

class DifferentialEvolutionOptimizer {
  data;
  strategyClass;
  paramConfigs;
  config;
  quiet = false;
  paramNames;
  dim;
  populationSize;
  F;
  CR;
  constructor(data, strategyClass, paramConfigs, config = {}) {
    this.data = data;
    this.strategyClass = strategyClass;
    this.paramConfigs = paramConfigs;
    this.config = {
      maxIterations: config.maxIterations ?? 100,
      convergenceThreshold: config.convergenceThreshold ?? 0.000001,
      learningRate: config.learningRate ?? 1,
      randomSamples: config.randomSamples ?? 50
    };
    this.paramNames = Object.keys(paramConfigs);
    this.dim = this.paramNames.length;
    this.populationSize = Math.max(10, this.dim + 1);
    this.F = 0.8;
    this.CR = 0.9;
  }
  setQuiet(quiet) {
    this.quiet = quiet;
  }
  async optimize(initialParams) {
    const history = [];
    let converged = false;
    const numRandomSamples = this.config.randomSamples;
    if (!this.quiet) {
      console.log(`DE: Random search phase (` + numRandomSamples + ` samples in parallel)...`);
    }
    const randomParamsList = Array.from({ length: numRandomSamples }, () => this.sampleRandomParams());
    const randomResults = await Promise.all(randomParamsList.map((params) => Promise.resolve(this.evaluate(params))));
    const randomSamples = randomParamsList.map((params, i) => ({
      params,
      fitness: randomResults[i].fitness,
      return: randomResults[i].return
    }));
    randomSamples.sort((a, b) => b.fitness - a.fitness);
    const topCount = Math.max(2, Math.ceil(numRandomSamples * 0.2));
    const topSamples = randomSamples.slice(0, topCount);
    if (!this.quiet) {
      console.log(`  Best random: ${randomSamples[0].fitness.toFixed(4)}`);
      console.log(`  Top 20%: ${topCount} samples, running 3 generations of evolution...`);
    }
    let population = topSamples.map((s) => ({ ...s }));
    const initialPopSize = this.populationSize;
    this.populationSize = Math.max(topCount + 2, initialPopSize);
    while (population.length < this.populationSize) {
      const params = this.sampleRandomParams();
      const evalResult = this.evaluate(params);
      population.push({
        params,
        fitness: evalResult.fitness,
        return: evalResult.return
      });
    }
    for (let gen = 0;gen < 3; gen++) {
      population = this.evolveGeneration(population);
    }
    population.sort((a, b) => b.fitness - a.fitness);
    const finalists = population.slice(0, 2);
    if (!this.quiet) {
      console.log(`  Finalists: ${finalists[0].fitness.toFixed(4)}, ${finalists[1].fitness.toFixed(4)}`);
      console.log(`DE: Running differential evolution on finalists...`);
    }
    population = finalists.map((s) => ({ ...s }));
    this.populationSize = Math.max(10, this.dim + 1);
    while (population.length < this.populationSize) {
      const params = this.sampleRandomParams();
      const evalResult = this.evaluate(params);
      population.push({
        params,
        fitness: evalResult.fitness,
        return: evalResult.return
      });
    }
    if (!this.quiet) {
      console.log(`  Dimensions: ${this.dim}, Population: ${this.populationSize}`);
      console.log(`  F: ${this.F}, CR: ${this.CR}`);
    }
    const progressBar = !this.quiet ? new import_cli_progress.default.SingleBar({
      format: "Generation {bar} {percentage}% | Gen: {value}/{total} | Best: {sharpe}",
      barCompleteChar: "",
      barIncompleteChar: "",
      hideCursor: true
    }) : null;
    if (progressBar) {
      progressBar.start(this.config.maxIterations, 0, { sharpe: "0.0000" });
    }
    for (let generation = 0;generation < this.config.maxIterations; generation++) {
      let bestInGeneration = population[0];
      let improvedInGen = false;
      const trials = [];
      for (let i = 0;i < this.populationSize; i++) {
        const candidates = population.map((_, idx) => idx).filter((idx) => idx !== i);
        const [r1, r2, r3] = this.shuffleArray(candidates).slice(0, 3);
        const mutant = {};
        for (const key of this.paramNames) {
          const config = this.paramConfigs[key];
          const xr1 = population[r1].params[key];
          const xr2 = population[r2].params[key];
          const xr3 = population[r3].params[key];
          let mutantValue = xr1 + this.F * (xr2 - xr3);
          if (mutantValue < config.min) {
            mutantValue = config.min + Math.random() * (config.max - config.min);
          } else if (mutantValue > config.max) {
            mutantValue = config.min + Math.random() * (config.max - config.min);
          }
          if (config.stepSize >= 1) {
            mutantValue = Math.round(mutantValue / config.stepSize) * config.stepSize;
          }
          mutant[key] = mutantValue;
        }
        const trial = {};
        const jrand = Math.floor(Math.random() * this.dim);
        let j = 0;
        for (const key of this.paramNames) {
          if (Math.random() < this.CR || j === jrand) {
            trial[key] = mutant[key];
          } else {
            trial[key] = population[i].params[key];
          }
          j++;
        }
        trials.push({ trial, index: i });
      }
      const trialResults = await Promise.all(trials.map(({ trial }) => Promise.resolve(this.evaluate(trial))));
      const newPopulation = [];
      for (let i = 0;i < trials.length; i++) {
        const { trial, index } = trials[i];
        const trialResult = trialResults[i];
        const trialFitness = trialResult.fitness;
        if (trialFitness >= population[index].fitness) {
          newPopulation.push({ params: trial, fitness: trialFitness, return: trialResult.return });
          if (trialFitness > population[index].fitness) {
            improvedInGen = true;
          }
        } else {
          newPopulation.push(population[index]);
        }
        if (trialFitness > bestInGeneration.fitness) {
          bestInGeneration = { params: trial, fitness: trialFitness, return: trialResult.return };
        }
      }
      population = newPopulation;
      if (progressBar) {
        progressBar.update(generation + 1, { sharpe: bestInGeneration.fitness.toFixed(4) });
      }
      history.push({
        iteration: generation,
        params: { ...bestInGeneration.params },
        sharpeRatio: bestInGeneration.fitness
      });
      if (!improvedInGen && generation > 20) {
        const recentHistory = history.slice(-20);
        const maxFit = Math.max(...recentHistory.map((h) => h.sharpeRatio));
        const minFit = Math.min(...recentHistory.map((h) => h.sharpeRatio));
        if (maxFit - minFit < this.config.convergenceThreshold) {
          converged = true;
          if (!this.quiet) {
            console.log(`
DE: Converged after ${generation + 1} generations`);
          }
          break;
        }
      }
    }
    const bestIndividual = population.reduce((best, current) => current.fitness > best.fitness ? current : best);
    if (progressBar) {
      progressBar.stop();
    }
    return {
      finalParams: bestIndividual.params,
      bestSharpe: bestIndividual.fitness,
      bestReturn: bestIndividual.return,
      history,
      iterations: history.length,
      converged
    };
  }
  sampleRandomParams() {
    const params = {};
    for (const [key, config] of Object.entries(this.paramConfigs)) {
      const range = config.max - config.min;
      params[key] = config.min + Math.random() * range;
      if (config.stepSize >= 1) {
        params[key] = Math.round(params[key] / config.stepSize) * config.stepSize;
      }
    }
    return params;
  }
  evaluate(params) {
    const strategy = new this.strategyClass(params);
    const engine = new BacktestEngine(this.data, strategy, { feeRate: 0.002 });
    const originalLog = console.log;
    if (this.quiet) {
      console.log = () => {};
    }
    try {
      const result = engine.run();
      const minTrades = 3;
      const tradePenalty = result.totalTrades < minTrades ? result.totalTrades / minTrades : 1;
      const returnWeight = 0.9;
      const sharpeWeight = 0.1;
      const normalizedReturn = result.totalReturn / 100;
      const fitness = (sharpeWeight * Math.max(0, result.sharpeRatio) + returnWeight * normalizedReturn) * tradePenalty;
      return { fitness, return: result.totalReturn };
    } finally {
      console.log = originalLog;
    }
  }
  evolveGeneration(population) {
    const newPopulation = [];
    const popSize = population.length;
    for (let i = 0;i < popSize; i++) {
      const candidates = population.map((_, idx) => idx).filter((idx) => idx !== i);
      const [r1, r2, r3] = this.shuffleArray(candidates).slice(0, 3);
      const mutant = {};
      for (const key of this.paramNames) {
        const config = this.paramConfigs[key];
        const xr1 = population[r1].params[key];
        const xr2 = population[r2].params[key];
        const xr3 = population[r3].params[key];
        let mutantValue = xr1 + this.F * (xr2 - xr3);
        if (mutantValue < config.min) {
          mutantValue = config.min;
        } else if (mutantValue > config.max) {
          mutantValue = config.max;
        }
        if (config.stepSize >= 1) {
          mutantValue = Math.round(mutantValue / config.stepSize) * config.stepSize;
        }
        mutant[key] = mutantValue;
      }
      const trial = {};
      const jrand = Math.floor(Math.random() * this.dim);
      let j = 0;
      for (const key of this.paramNames) {
        if (Math.random() < this.CR || j === jrand) {
          trial[key] = mutant[key];
        } else {
          trial[key] = population[i].params[key];
        }
        j++;
      }
      const trialResult = this.evaluate(trial);
      const trialFitness = trialResult.fitness;
      if (trialFitness >= population[i].fitness) {
        newPopulation.push({ params: trial, fitness: trialFitness, return: trialResult.return });
      } else {
        newPopulation.push(population[i]);
      }
    }
    return newPopulation;
  }
  shuffleArray(array) {
    const arr = [...array];
    for (let i = arr.length - 1;i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
}
// scripts/run-optimization.ts
init_engine();
import * as fs273 from "fs";
import * as path273 from "path";
kleur_default.enabled = true;
var strategies = {
  simple_ma: {
    class: SimpleMAStrategy,
    params: {
      fast_period: { min: 5, max: 30, stepSize: 5 },
      slow_period: { min: 20, max: 100, stepSize: 10 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0, max: 0, stepSize: 1 },
      risk_percent: { min: 0.1, max: 0.5, stepSize: 0.1 }
    },
    outputFile: "strat_simple_ma_01.params.json"
  },
  bollinger: {
    class: BollingerBandsStrategy,
    params: {
      period: { min: 10, max: 50, stepSize: 5 },
      std_dev_multiplier: { min: 1.5, max: 3, stepSize: 0.5 },
      stop_loss: { min: 0.01, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0, max: 1, stepSize: 1 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 },
      mean_reversion: { min: 0, max: 1, stepSize: 1 }
    },
    outputFile: "strat_bollinger_02.params.json"
  },
  rsi: {
    class: RSIMeanReversionStrategy,
    params: {
      rsi_period: { min: 3, max: 10, stepSize: 1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_03.params.json"
  },
  breakout: {
    class: ATRBreakoutStrategy,
    params: {
      breakout_multiplier: { min: 0.1, max: 1, stepSize: 0.1 },
      lookback: { min: 5, max: 20, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_atr_breakout_04.params.json"
  },
  ma_vol: {
    class: MAStrategyWithATRStop,
    params: {
      fast_period: { min: 3, max: 10, stepSize: 1 },
      slow_period: { min: 10, max: 30, stepSize: 5 },
      volatility_period: { min: 10, max: 30, stepSize: 5 },
      vol_multiplier: { min: 1, max: 4, stepSize: 0.5 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_ma_atr_05.params.json"
  },
  support: {
    class: SupportResistanceStrategy,
    params: {
      lookback: { min: 5, max: 20, stepSize: 5 },
      bounce_threshold: { min: 0.02, max: 0.1, stepSize: 0.02 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 },
      take_profit: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_support_06.params.json"
  },
  momentum: {
    class: ShortTermStrategy,
    params: {
      lookback: { min: 2, max: 6, stepSize: 1 },
      entry_threshold: { min: 0.02, max: 0.1, stepSize: 0.02 },
      trailing_stop_pct: { min: 0.02, max: 0.1, stepSize: 0.02 },
      minimum_hold: { min: 2, max: 6, stepSize: 1 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_momentum_07.params.json"
  },
  range: {
    class: RangeTradingStrategy,
    params: {
      buy_below: { min: 0.15, max: 0.4, stepSize: 0.05 },
      sell_above: { min: 0.5, max: 0.8, stepSize: 0.05 },
      stop_loss: { min: 0.1, max: 0.3, stepSize: 0.05 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_range_08.params.json"
  },
  mean_revert: {
    class: MeanReversionStrategy,
    params: {
      ma_period: { min: 5, max: 15, stepSize: 1 },
      deviation_threshold: { min: 0.01, max: 0.08, stepSize: 0.01 },
      stop_loss: { min: 0.03, max: 0.15, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mean_revert_09.params.json"
  },
  dual_ma: {
    class: DualMAStrategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      slow_period: { min: 10, max: 20, stepSize: 2 },
      trend_period: { min: 20, max: 40, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.02 },
      trailing_stop_pct: { min: 0.02, max: 0.08, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_dual_ma_10.params.json"
  },
  ema_fast: {
    class: EMAFastCrossStrategy,
    params: {
      fast_period: { min: 2, max: 5, stepSize: 1 },
      slow_period: { min: 6, max: 15, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_ema_fast_11.params.json"
  },
  ema_med: {
    class: EMAMedCrossStrategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      slow_period: { min: 10, max: 25, stepSize: 2 },
      stop_loss: { min: 0.03, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_ema_med_12.params.json"
  },
  ema_slow: {
    class: EMASlowCrossStrategy,
    params: {
      fast_period: { min: 5, max: 12, stepSize: 1 },
      slow_period: { min: 15, max: 35, stepSize: 2 },
      stop_loss: { min: 0.03, max: 0.12, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_ema_slow_13.params.json"
  },
  ema_tight: {
    class: EMATightStopStrategy,
    params: {
      fast_period: { min: 2, max: 6, stepSize: 1 },
      slow_period: { min: 8, max: 18, stepSize: 1 },
      stop_loss: { min: 0.01, max: 0.05, stepSize: 0.005 },
      trailing_stop: { min: 0.01, max: 0.04, stepSize: 0.005 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_ema_tight_14.params.json"
  },
  ema_wide: {
    class: EMAWideStopStrategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      slow_period: { min: 8, max: 20, stepSize: 2 },
      stop_loss: { min: 0.06, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.04, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_ema_wide_15.params.json"
  },
  roc_fast: {
    class: ROCFastStrategy,
    params: {
      lookback: { min: 2, max: 5, stepSize: 1 },
      entry_threshold: { min: 0.01, max: 0.08, stepSize: 0.01 },
      exit_threshold: { min: 0.01, max: 0.06, stepSize: 0.01 },
      min_hold: { min: 1, max: 5, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_roc_fast_16.params.json"
  },
  roc_slow: {
    class: ROCSlowStrategy,
    params: {
      lookback: { min: 5, max: 15, stepSize: 1 },
      entry_threshold: { min: 0.02, max: 0.1, stepSize: 0.01 },
      exit_threshold: { min: 0.01, max: 0.08, stepSize: 0.01 },
      min_hold: { min: 2, max: 8, stepSize: 1 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_roc_slow_17.params.json"
  },
  donchian_short: {
    class: DonchianShortStrategy,
    params: {
      channel_period: { min: 5, max: 15, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      exit_at_mid: { min: 0, max: 1, stepSize: 1 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_donchian_short_18.params.json"
  },
  donchian_long: {
    class: DonchianLongStrategy,
    params: {
      channel_period: { min: 10, max: 25, stepSize: 2 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      exit_at_mid: { min: 0, max: 1, stepSize: 1 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_donchian_long_19.params.json"
  },
  stoch_fast: {
    class: StochFastStrategy,
    params: {
      k_period: { min: 3, max: 8, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_fast_20.params.json"
  },
  stoch_slow: {
    class: StochSlowStrategy,
    params: {
      k_period: { min: 8, max: 15, stepSize: 1 },
      d_period: { min: 3, max: 8, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_slow_21.params.json"
  },
  willr_short: {
    class: WillRShortStrategy,
    params: {
      period: { min: 5, max: 12, stepSize: 1 },
      oversold_level: { min: -95, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -5, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_short_22.params.json"
  },
  willr_long: {
    class: WillRLongStrategy,
    params: {
      period: { min: 10, max: 20, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_willr_long_23.params.json"
  },
  accel_fast: {
    class: AccelFastStrategy,
    params: {
      lookback: { min: 3, max: 6, stepSize: 1 },
      entry_threshold: { min: 0.001, max: 0.015, stepSize: 0.002 },
      exit_threshold: { min: 0.001, max: 0.01, stepSize: 0.001 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_accel_fast_24.params.json"
  },
  accel_slow: {
    class: AccelSlowStrategy,
    params: {
      lookback: { min: 5, max: 12, stepSize: 1 },
      entry_threshold: { min: 0.001, max: 0.01, stepSize: 0.001 },
      exit_threshold: { min: 0.001, max: 0.008, stepSize: 0.001 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_accel_slow_25.params.json"
  },
  vbreak_tight: {
    class: VolBreakTightStrategy,
    params: {
      vol_period: { min: 5, max: 12, stepSize: 1 },
      lookback: { min: 8, max: 20, stepSize: 2 },
      contraction_ratio: { min: 0.3, max: 0.7, stepSize: 0.1 },
      breakout_threshold: { min: 0.01, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_vbreak_tight_26.params.json"
  },
  vbreak_wide: {
    class: VolBreakWideStrategy,
    params: {
      vol_period: { min: 8, max: 18, stepSize: 2 },
      lookback: { min: 12, max: 25, stepSize: 2 },
      contraction_ratio: { min: 0.4, max: 0.8, stepSize: 0.1 },
      breakout_threshold: { min: 0.015, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_vbreak_wide_27.params.json"
  },
  ribbon_tight: {
    class: RibbonTightStrategy,
    params: {
      shortest_period: { min: 2, max: 5, stepSize: 1 },
      period_step: { min: 1, max: 4, stepSize: 1 },
      num_mas: { min: 3, max: 6, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_ribbon_tight_28.params.json"
  },
  ribbon_wide: {
    class: RibbonWideStrategy,
    params: {
      shortest_period: { min: 3, max: 8, stepSize: 1 },
      period_step: { min: 2, max: 6, stepSize: 1 },
      num_mas: { min: 3, max: 7, stepSize: 1 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_ribbon_wide_29.params.json"
  },
  rsi_div_fast: {
    class: RSIDivFastStrategy,
    params: {
      rsi_period: { min: 3, max: 8, stepSize: 1 },
      divergence_lookback: { min: 4, max: 10, stepSize: 1 },
      oversold: { min: 20, max: 40, stepSize: 5 },
      overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_div_fast_30.params.json"
  },
  rsi_div_slow: {
    class: RSIDivSlowStrategy,
    params: {
      rsi_period: { min: 5, max: 12, stepSize: 1 },
      divergence_lookback: { min: 8, max: 15, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_div_slow_31.params.json"
  },
  mr_rsi_tight: {
    class: MRRSITightStrategy,
    params: {
      ma_period: { min: 4, max: 10, stepSize: 1 },
      rsi_period: { min: 3, max: 8, stepSize: 1 },
      deviation_threshold: { min: 0.01, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_tight_32.params.json"
  },
  mr_rsi_wide: {
    class: MRRSIWideStrategy,
    params: {
      ma_period: { min: 6, max: 15, stepSize: 1 },
      rsi_period: { min: 5, max: 10, stepSize: 1 },
      deviation_threshold: { min: 0.02, max: 0.08, stepSize: 0.01 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_wide_33.params.json"
  },
  adapt_fast: {
    class: AdaptFastStrategy,
    params: {
      min_period: { min: 2, max: 5, stepSize: 1 },
      max_period: { min: 8, max: 20, stepSize: 2 },
      vol_sensitivity: { min: 20, max: 100, stepSize: 10 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_adapt_fast_34.params.json"
  },
  adapt_slow: {
    class: AdaptSlowStrategy,
    params: {
      min_period: { min: 3, max: 8, stepSize: 1 },
      max_period: { min: 15, max: 35, stepSize: 5 },
      vol_sensitivity: { min: 10, max: 80, stepSize: 10 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_adapt_slow_35.params.json"
  },
  tri_ma_fast: {
    class: TriMAFastStrategy,
    params: {
      fast_period: { min: 2, max: 5, stepSize: 1 },
      mid_period: { min: 4, max: 10, stepSize: 1 },
      slow_period: { min: 8, max: 18, stepSize: 2 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_tri_ma_fast_36.params.json"
  },
  tri_ma_slow: {
    class: TriMASlowStrategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      mid_period: { min: 8, max: 16, stepSize: 2 },
      slow_period: { min: 15, max: 30, stepSize: 2 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_tri_ma_slow_37.params.json"
  },
  env_tight: {
    class: EnvTightStrategy,
    params: {
      ma_period: { min: 5, max: 15, stepSize: 1 },
      envelope_pct: { min: 0.01, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_tight_38.params.json"
  },
  env_wide: {
    class: EnvWideStrategy,
    params: {
      ma_period: { min: 8, max: 20, stepSize: 2 },
      envelope_pct: { min: 0.03, max: 0.1, stepSize: 0.01 },
      stop_loss: { min: 0.05, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_env_wide_39.params.json"
  },
  pat_dip: {
    class: PatDipStrategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.12, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_dip_40.params.json"
  },
  pat_mom: {
    class: PatMomStrategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_mom_41.params.json"
  },
  combo_tight: {
    class: ComboTightStrategy,
    params: {
      bb_period: { min: 5, max: 12, stepSize: 1 },
      rsi_period: { min: 3, max: 8, stepSize: 1 },
      std_mult: { min: 1.2, max: 2.5, stepSize: 0.1 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_tight_42.params.json"
  },
  combo_wide: {
    class: ComboWideStrategy,
    params: {
      bb_period: { min: 8, max: 18, stepSize: 2 },
      rsi_period: { min: 5, max: 10, stepSize: 1 },
      std_mult: { min: 1.5, max: 3, stepSize: 0.2 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_combo_wide_43.params.json"
  },
  tstr_fast: {
    class: TStrFastStrategy,
    params: {
      lookback: { min: 4, max: 10, stepSize: 1 },
      entry_strength: { min: 0.5, max: 0.9, stepSize: 0.05 },
      exit_strength: { min: 0.1, max: 0.5, stepSize: 0.05 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_tstr_fast_44.params.json"
  },
  tstr_slow: {
    class: TStrSlowStrategy,
    params: {
      lookback: { min: 8, max: 18, stepSize: 2 },
      entry_strength: { min: 0.5, max: 0.85, stepSize: 0.05 },
      exit_strength: { min: 0.15, max: 0.5, stepSize: 0.05 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_tstr_slow_45.params.json"
  },
  swing_short: {
    class: SwingShortStrategy,
    params: {
      swing_window: { min: 2, max: 5, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      take_profit: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_swing_short_46.params.json"
  },
  swing_long: {
    class: SwingLongStrategy,
    params: {
      swing_window: { min: 3, max: 8, stepSize: 1 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      take_profit: { min: 0.06, max: 0.2, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_swing_long_47.params.json"
  },
  rev_fast: {
    class: RevFastStrategy,
    params: {
      lookback: { min: 3, max: 8, stepSize: 1 },
      drop_threshold: { min: 0.02, max: 0.1, stepSize: 0.01 },
      bounce_threshold: { min: 0.01, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.12, stepSize: 0.01 },
      take_profit: { min: 0.04, max: 0.15, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_rev_fast_48.params.json"
  },
  rev_slow: {
    class: RevSlowStrategy,
    params: {
      lookback: { min: 6, max: 15, stepSize: 1 },
      drop_threshold: { min: 0.04, max: 0.15, stepSize: 0.01 },
      bounce_threshold: { min: 0.01, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.05, max: 0.15, stepSize: 0.01 },
      take_profit: { min: 0.06, max: 0.2, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_rev_slow_49.params.json"
  },
  chan_tight: {
    class: ChanTightStrategy,
    params: {
      channel_period: { min: 5, max: 12, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.02, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_tight_50.params.json"
  },
  chan_wide: {
    class: ChanWideStrategy,
    params: {
      channel_period: { min: 10, max: 20, stepSize: 2 },
      channel_width: { min: 0.3, max: 1, stepSize: 0.1 },
      stop_loss: { min: 0.04, max: 0.15, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_chan_wide_51.params.json"
  },
  mcross_fast: {
    class: MCrossFastStrategy,
    params: {
      ma_period: { min: 3, max: 10, stepSize: 1 },
      stop_loss: { min: 0.02, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mcross_fast_52.params.json"
  },
  mcross_slow: {
    class: MCrossSlowStrategy,
    params: {
      ma_period: { min: 8, max: 20, stepSize: 2 },
      stop_loss: { min: 0.04, max: 0.12, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mcross_slow_53.params.json"
  },
  mr_rsi_v01: {
    class: MRRsiV01Strategy,
    params: {
      ma_period: { min: 2, max: 8, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.045, stepSize: 0.005 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v01_54.params.json"
  },
  mr_rsi_v02: {
    class: MRRsiV02Strategy,
    params: {
      ma_period: { min: 2, max: 9, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v02_55.params.json"
  },
  mr_rsi_v03: {
    class: MRRsiV03Strategy,
    params: {
      ma_period: { min: 2, max: 9, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.009999999999999998, max: 0.06, stepSize: 0.005 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v03_56.params.json"
  },
  mr_rsi_v04: {
    class: MRRsiV04Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v04_57.params.json"
  },
  mr_rsi_v05: {
    class: MRRsiV05Strategy,
    params: {
      ma_period: { min: 4, max: 12, stepSize: 1 },
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      deviation_threshold: { min: 0.009999999999999998, max: 0.06, stepSize: 0.005 },
      rsi_oversold: { min: 18, max: 38, stepSize: 5 },
      rsi_overbought: { min: 62, max: 82, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v05_58.params.json"
  },
  mr_rsi_v06: {
    class: MRRsiV06Strategy,
    params: {
      ma_period: { min: 5, max: 13, stepSize: 1 },
      rsi_period: { min: 5, max: 11, stepSize: 1 },
      deviation_threshold: { min: 0.02, max: 0.07, stepSize: 0.005 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v06_59.params.json"
  },
  mr_rsi_v07: {
    class: MRRsiV07Strategy,
    params: {
      ma_period: { min: 7, max: 15, stepSize: 1 },
      rsi_period: { min: 6, max: 12, stepSize: 1 },
      deviation_threshold: { min: 0.009999999999999998, max: 0.06, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v07_60.params.json"
  },
  mr_rsi_v08: {
    class: MRRsiV08Strategy,
    params: {
      ma_period: { min: 9, max: 17, stepSize: 1 },
      rsi_period: { min: 7, max: 13, stepSize: 1 },
      deviation_threshold: { min: 0.030000000000000002, max: 0.08, stepSize: 0.005 },
      rsi_oversold: { min: 12, max: 32, stepSize: 5 },
      rsi_overbought: { min: 68, max: 88, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v08_61.params.json"
  },
  mr_rsi_v09: {
    class: MRRsiV09Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      deviation_threshold: { min: 0.030000000000000002, max: 0.08, stepSize: 0.005 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v09_62.params.json"
  },
  mr_rsi_v10: {
    class: MRRsiV10Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.04, stepSize: 0.005 },
      rsi_oversold: { min: 25, max: 45, stepSize: 5 },
      rsi_overbought: { min: 55, max: 75, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v10_63.params.json"
  },
  mr_rsi_v11: {
    class: MRRsiV11Strategy,
    params: {
      ma_period: { min: 2, max: 8, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.04, stepSize: 0.005 },
      rsi_oversold: { min: 25, max: 45, stepSize: 5 },
      rsi_overbought: { min: 55, max: 75, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v11_64.params.json"
  },
  mr_rsi_v12: {
    class: MRRsiV12Strategy,
    params: {
      ma_period: { min: 7, max: 15, stepSize: 1 },
      rsi_period: { min: 6, max: 12, stepSize: 1 },
      deviation_threshold: { min: 0.02, max: 0.07, stepSize: 0.005 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v12_65.params.json"
  },
  mr_rsi_v13: {
    class: MRRsiV13Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.005000000000000001, max: 0.055, stepSize: 0.005 },
      rsi_oversold: { min: 18, max: 38, stepSize: 5 },
      rsi_overbought: { min: 62, max: 82, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v13_66.params.json"
  },
  mr_rsi_v14: {
    class: MRRsiV14Strategy,
    params: {
      ma_period: { min: 4, max: 12, stepSize: 1 },
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      deviation_threshold: { min: 0.015000000000000003, max: 0.065, stepSize: 0.005 },
      rsi_oversold: { min: 16, max: 36, stepSize: 5 },
      rsi_overbought: { min: 64, max: 84, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v14_67.params.json"
  },
  mr_rsi_v15: {
    class: MRRsiV15Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v15_68.params.json"
  },
  mr_rsi_v16: {
    class: MRRsiV16Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v16_69.params.json"
  },
  mr_rsi_v17: {
    class: MRRsiV17Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.009999999999999998, max: 0.06, stepSize: 0.005 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v17_70.params.json"
  },
  mr_rsi_v18: {
    class: MRRsiV18Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      deviation_threshold: { min: 0.009999999999999998, max: 0.06, stepSize: 0.005 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v18_71.params.json"
  },
  mr_rsi_v19: {
    class: MRRsiV19Strategy,
    params: {
      ma_period: { min: 2, max: 8, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      deviation_threshold: { min: 0.005, max: 0.05, stepSize: 0.005 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v19_72.params.json"
  },
  mr_rsi_v20: {
    class: MRRsiV20Strategy,
    params: {
      ma_period: { min: 11, max: 19, stepSize: 1 },
      rsi_period: { min: 8, max: 14, stepSize: 1 },
      deviation_threshold: { min: 0.039999999999999994, max: 0.09, stepSize: 0.005 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_mr_rsi_v20_73.params.json"
  },
  willr_v01: {
    class: WillRV01Strategy,
    params: {
      period: { min: 3, max: 9, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v01_74.params.json"
  },
  willr_v02: {
    class: WillRV02Strategy,
    params: {
      period: { min: 3, max: 10, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v02_75.params.json"
  },
  willr_v03: {
    class: WillRV03Strategy,
    params: {
      period: { min: 3, max: 10, stepSize: 1 },
      oversold_level: { min: -98, max: -80, stepSize: 5 },
      overbought_level: { min: -20, max: -2, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v03_76.params.json"
  },
  willr_v04: {
    class: WillRV04Strategy,
    params: {
      period: { min: 5, max: 13, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v04_77.params.json"
  },
  willr_v05: {
    class: WillRV05Strategy,
    params: {
      period: { min: 5, max: 13, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v05_78.params.json"
  },
  willr_v06: {
    class: WillRV06Strategy,
    params: {
      period: { min: 5, max: 13, stepSize: 1 },
      oversold_level: { min: -98, max: -85, stepSize: 5 },
      overbought_level: { min: -15, max: -2, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v06_79.params.json"
  },
  willr_v07: {
    class: WillRV07Strategy,
    params: {
      period: { min: 9, max: 17, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v07_80.params.json"
  },
  willr_v08: {
    class: WillRV08Strategy,
    params: {
      period: { min: 9, max: 17, stepSize: 1 },
      oversold_level: { min: -98, max: -80, stepSize: 5 },
      overbought_level: { min: -20, max: -2, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v08_81.params.json"
  },
  willr_v09: {
    class: WillRV09Strategy,
    params: {
      period: { min: 4, max: 12, stepSize: 1 },
      oversold_level: { min: -98, max: -85, stepSize: 5 },
      overbought_level: { min: -35, max: -15, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v09_82.params.json"
  },
  willr_v10: {
    class: WillRV10Strategy,
    params: {
      period: { min: 3, max: 11, stepSize: 1 },
      oversold_level: { min: -80, max: -60, stepSize: 5 },
      overbought_level: { min: -40, max: -20, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v10_83.params.json"
  },
  willr_v11: {
    class: WillRV11Strategy,
    params: {
      period: { min: 3, max: 9, stepSize: 1 },
      oversold_level: { min: -85, max: -65, stepSize: 5 },
      overbought_level: { min: -35, max: -15, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v11_84.params.json"
  },
  willr_v12: {
    class: WillRV12Strategy,
    params: {
      period: { min: 11, max: 19, stepSize: 1 },
      oversold_level: { min: -98, max: -80, stepSize: 5 },
      overbought_level: { min: -20, max: -2, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v12_85.params.json"
  },
  willr_v13: {
    class: WillRV13Strategy,
    params: {
      period: { min: 4, max: 12, stepSize: 1 },
      oversold_level: { min: -92, max: -72, stepSize: 5 },
      overbought_level: { min: -28, max: -8, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v13_86.params.json"
  },
  willr_v14: {
    class: WillRV14Strategy,
    params: {
      period: { min: 6, max: 14, stepSize: 1 },
      oversold_level: { min: -88, max: -68, stepSize: 5 },
      overbought_level: { min: -32, max: -12, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v14_87.params.json"
  },
  willr_v15: {
    class: WillRV15Strategy,
    params: {
      period: { min: 4, max: 12, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v15_88.params.json"
  },
  willr_v16: {
    class: WillRV16Strategy,
    params: {
      period: { min: 4, max: 12, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      trailing_stop: { min: 0.06, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v16_89.params.json"
  },
  willr_v17: {
    class: WillRV17Strategy,
    params: {
      period: { min: 3, max: 11, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v17_90.params.json"
  },
  willr_v18: {
    class: WillRV18Strategy,
    params: {
      period: { min: 3, max: 11, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v18_91.params.json"
  },
  willr_v19: {
    class: WillRV19Strategy,
    params: {
      period: { min: 3, max: 8, stepSize: 1 },
      oversold_level: { min: -90, max: -70, stepSize: 5 },
      overbought_level: { min: -30, max: -10, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v19_92.params.json"
  },
  willr_v20: {
    class: WillRV20Strategy,
    params: {
      period: { min: 15, max: 23, stepSize: 1 },
      oversold_level: { min: -95, max: -75, stepSize: 5 },
      overbought_level: { min: -25, max: -5, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_willr_v20_93.params.json"
  },
  env_v01: {
    class: EnvV01Strategy,
    params: {
      ma_period: { min: 2, max: 9, stepSize: 1 },
      envelope_pct: { min: 0.005, max: 0.04, stepSize: 0.005 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_env_v01_94.params.json"
  },
  env_v02: {
    class: EnvV02Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      envelope_pct: { min: 0.005, max: 0.045, stepSize: 0.005 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_v02_95.params.json"
  },
  env_v03: {
    class: EnvV03Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      envelope_pct: { min: 0.010000000000000002, max: 0.055, stepSize: 0.005 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_env_v03_96.params.json"
  },
  env_v04: {
    class: EnvV04Strategy,
    params: {
      ma_period: { min: 2, max: 10, stepSize: 1 },
      envelope_pct: { min: 0.025, max: 0.07, stepSize: 0.005 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_env_v04_97.params.json"
  },
  env_v05: {
    class: EnvV05Strategy,
    params: {
      ma_period: { min: 5, max: 13, stepSize: 1 },
      envelope_pct: { min: 0.005000000000000001, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_v05_98.params.json"
  },
  env_v06: {
    class: EnvV06Strategy,
    params: {
      ma_period: { min: 5, max: 13, stepSize: 1 },
      envelope_pct: { min: 0.015, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_env_v06_99.params.json"
  },
  env_v07: {
    class: EnvV07Strategy,
    params: {
      ma_period: { min: 5, max: 13, stepSize: 1 },
      envelope_pct: { min: 0.035, max: 0.08, stepSize: 0.005 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_env_v07_100.params.json"
  },
  env_v08: {
    class: EnvV08Strategy,
    params: {
      ma_period: { min: 9, max: 17, stepSize: 1 },
      envelope_pct: { min: 0.005000000000000001, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_v08_101.params.json"
  },
  env_v09: {
    class: EnvV09Strategy,
    params: {
      ma_period: { min: 9, max: 17, stepSize: 1 },
      envelope_pct: { min: 0.025, max: 0.07, stepSize: 0.005 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_env_v09_102.params.json"
  },
  env_v10: {
    class: EnvV10Strategy,
    params: {
      ma_period: { min: 9, max: 17, stepSize: 1 },
      envelope_pct: { min: 0.045, max: 0.09, stepSize: 0.005 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_env_v10_103.params.json"
  },
  env_v11: {
    class: EnvV11Strategy,
    params: {
      ma_period: { min: 2, max: 9, stepSize: 1 },
      envelope_pct: { min: 0.005, max: 0.045, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_env_v11_104.params.json"
  },
  env_v12: {
    class: EnvV12Strategy,
    params: {
      ma_period: { min: 12, max: 20, stepSize: 1 },
      envelope_pct: { min: 0.035, max: 0.08, stepSize: 0.005 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_env_v12_105.params.json"
  },
  env_v13: {
    class: EnvV13Strategy,
    params: {
      ma_period: { min: 4, max: 12, stepSize: 1 },
      envelope_pct: { min: 0.010000000000000002, max: 0.055, stepSize: 0.005 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_env_v13_106.params.json"
  },
  env_v14: {
    class: EnvV14Strategy,
    params: {
      ma_period: { min: 6, max: 14, stepSize: 1 },
      envelope_pct: { min: 0.020000000000000004, max: 0.065, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_env_v14_107.params.json"
  },
  env_v15: {
    class: EnvV15Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      envelope_pct: { min: 0.005000000000000001, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_v15_108.params.json"
  },
  env_v16: {
    class: EnvV16Strategy,
    params: {
      ma_period: { min: 3, max: 11, stepSize: 1 },
      envelope_pct: { min: 0.005000000000000001, max: 0.05, stepSize: 0.005 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_env_v16_109.params.json"
  },
  env_v17: {
    class: EnvV17Strategy,
    params: {
      ma_period: { min: 4, max: 12, stepSize: 1 },
      envelope_pct: { min: 0.015, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_env_v17_110.params.json"
  },
  env_v18: {
    class: EnvV18Strategy,
    params: {
      ma_period: { min: 4, max: 12, stepSize: 1 },
      envelope_pct: { min: 0.015, max: 0.06, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_env_v18_111.params.json"
  },
  env_v19: {
    class: EnvV19Strategy,
    params: {
      ma_period: { min: 2, max: 8, stepSize: 1 },
      envelope_pct: { min: 0.005, max: 0.038, stepSize: 0.005 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_env_v19_112.params.json"
  },
  env_v20: {
    class: EnvV20Strategy,
    params: {
      ma_period: { min: 15, max: 23, stepSize: 1 },
      envelope_pct: { min: 0.045, max: 0.09, stepSize: 0.005 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_env_v20_113.params.json"
  },
  chan_v01: {
    class: ChanV01Strategy,
    params: {
      channel_period: { min: 3, max: 9, stepSize: 1 },
      channel_width: { min: 0.1, max: 0.6, stepSize: 0.1 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v01_114.params.json"
  },
  chan_v02: {
    class: ChanV02Strategy,
    params: {
      channel_period: { min: 3, max: 10, stepSize: 1 },
      channel_width: { min: 0.10000000000000003, max: 0.7, stepSize: 0.1 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v02_115.params.json"
  },
  chan_v03: {
    class: ChanV03Strategy,
    params: {
      channel_period: { min: 3, max: 10, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v03_116.params.json"
  },
  chan_v04: {
    class: ChanV04Strategy,
    params: {
      channel_period: { min: 3, max: 10, stepSize: 1 },
      channel_width: { min: 0.39999999999999997, max: 1, stepSize: 0.1 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v04_117.params.json"
  },
  chan_v05: {
    class: ChanV05Strategy,
    params: {
      channel_period: { min: 5, max: 13, stepSize: 1 },
      channel_width: { min: 0.10000000000000003, max: 0.7, stepSize: 0.1 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v05_118.params.json"
  },
  chan_v06: {
    class: ChanV06Strategy,
    params: {
      channel_period: { min: 5, max: 13, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v06_119.params.json"
  },
  chan_v07: {
    class: ChanV07Strategy,
    params: {
      channel_period: { min: 5, max: 13, stepSize: 1 },
      channel_width: { min: 0.5, max: 1.1, stepSize: 0.1 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v07_120.params.json"
  },
  chan_v08: {
    class: ChanV08Strategy,
    params: {
      channel_period: { min: 9, max: 17, stepSize: 1 },
      channel_width: { min: 0.10000000000000003, max: 0.7, stepSize: 0.1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v08_121.params.json"
  },
  chan_v09: {
    class: ChanV09Strategy,
    params: {
      channel_period: { min: 9, max: 17, stepSize: 1 },
      channel_width: { min: 0.3, max: 0.8999999999999999, stepSize: 0.1 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v09_122.params.json"
  },
  chan_v10: {
    class: ChanV10Strategy,
    params: {
      channel_period: { min: 9, max: 17, stepSize: 1 },
      channel_width: { min: 0.6000000000000001, max: 1.2, stepSize: 0.1 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      trailing_stop: { min: 0.05, max: 0.11000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v10_123.params.json"
  },
  chan_v11: {
    class: ChanV11Strategy,
    params: {
      channel_period: { min: 3, max: 9, stepSize: 1 },
      channel_width: { min: 0.1, max: 0.6, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v11_124.params.json"
  },
  chan_v12: {
    class: ChanV12Strategy,
    params: {
      channel_period: { min: 12, max: 20, stepSize: 1 },
      channel_width: { min: 0.39999999999999997, max: 1, stepSize: 0.1 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v12_125.params.json"
  },
  chan_v13: {
    class: ChanV13Strategy,
    params: {
      channel_period: { min: 4, max: 12, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v13_126.params.json"
  },
  chan_v14: {
    class: ChanV14Strategy,
    params: {
      channel_period: { min: 6, max: 14, stepSize: 1 },
      channel_width: { min: 0.3, max: 0.8999999999999999, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v14_127.params.json"
  },
  chan_v15: {
    class: ChanV15Strategy,
    params: {
      channel_period: { min: 4, max: 12, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v15_128.params.json"
  },
  chan_v16: {
    class: ChanV16Strategy,
    params: {
      channel_period: { min: 4, max: 12, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      trailing_stop: { min: 0.06, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v16_129.params.json"
  },
  chan_v17: {
    class: ChanV17Strategy,
    params: {
      channel_period: { min: 3, max: 11, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v17_130.params.json"
  },
  chan_v18: {
    class: ChanV18Strategy,
    params: {
      channel_period: { min: 3, max: 11, stepSize: 1 },
      channel_width: { min: 0.2, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v18_131.params.json"
  },
  chan_v19: {
    class: ChanV19Strategy,
    params: {
      channel_period: { min: 3, max: 8, stepSize: 1 },
      channel_width: { min: 0.1, max: 0.5, stepSize: 0.1 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v19_132.params.json"
  },
  chan_v20: {
    class: ChanV20Strategy,
    params: {
      channel_period: { min: 15, max: 23, stepSize: 1 },
      channel_width: { min: 0.7, max: 1.3, stepSize: 0.1 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      trailing_stop: { min: 0.05, max: 0.11000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_chan_v20_133.params.json"
  },
  combo_v01: {
    class: ComboV01Strategy,
    params: {
      bb_period: { min: 2, max: 9, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      std_mult: { min: 1, max: 2.3, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v01_134.params.json"
  },
  combo_v02: {
    class: ComboV02Strategy,
    params: {
      bb_period: { min: 2, max: 10, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      std_mult: { min: 1.3, max: 2.6, stepSize: 0.1 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v02_135.params.json"
  },
  combo_v03: {
    class: ComboV03Strategy,
    params: {
      bb_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v03_136.params.json"
  },
  combo_v04: {
    class: ComboV04Strategy,
    params: {
      bb_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      std_mult: { min: 2, max: 3.3, stepSize: 0.1 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v04_137.params.json"
  },
  combo_v05: {
    class: ComboV05Strategy,
    params: {
      bb_period: { min: 5, max: 13, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      std_mult: { min: 1, max: 2.3, stepSize: 0.1 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v05_138.params.json"
  },
  combo_v06: {
    class: ComboV06Strategy,
    params: {
      bb_period: { min: 5, max: 13, stepSize: 1 },
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v06_139.params.json"
  },
  combo_v07: {
    class: ComboV07Strategy,
    params: {
      bb_period: { min: 7, max: 15, stepSize: 1 },
      rsi_period: { min: 5, max: 11, stepSize: 1 },
      std_mult: { min: 2, max: 3.3, stepSize: 0.1 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v07_140.params.json"
  },
  combo_v08: {
    class: ComboV08Strategy,
    params: {
      bb_period: { min: 9, max: 17, stepSize: 1 },
      rsi_period: { min: 5, max: 11, stepSize: 1 },
      std_mult: { min: 1, max: 2.3, stepSize: 0.1 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v08_141.params.json"
  },
  combo_v09: {
    class: ComboV09Strategy,
    params: {
      bb_period: { min: 9, max: 17, stepSize: 1 },
      rsi_period: { min: 6, max: 12, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v09_142.params.json"
  },
  combo_v10: {
    class: ComboV10Strategy,
    params: {
      bb_period: { min: 12, max: 20, stepSize: 1 },
      rsi_period: { min: 7, max: 13, stepSize: 1 },
      std_mult: { min: 2, max: 3.3, stepSize: 0.1 },
      rsi_oversold: { min: 10, max: 30, stepSize: 5 },
      rsi_overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v10_143.params.json"
  },
  combo_v11: {
    class: ComboV11Strategy,
    params: {
      bb_period: { min: 2, max: 9, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      std_mult: { min: 0.8, max: 2.1, stepSize: 0.1 },
      rsi_oversold: { min: 25, max: 45, stepSize: 5 },
      rsi_overbought: { min: 55, max: 75, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v11_144.params.json"
  },
  combo_v12: {
    class: ComboV12Strategy,
    params: {
      bb_period: { min: 11, max: 19, stepSize: 1 },
      rsi_period: { min: 6, max: 12, stepSize: 1 },
      std_mult: { min: 2.3, max: 3.5999999999999996, stepSize: 0.1 },
      rsi_oversold: { min: 10, max: 28, stepSize: 5 },
      rsi_overbought: { min: 72, max: 90, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v12_145.params.json"
  },
  combo_v13: {
    class: ComboV13Strategy,
    params: {
      bb_period: { min: 4, max: 12, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      std_mult: { min: 1.3, max: 2.6, stepSize: 0.1 },
      rsi_oversold: { min: 18, max: 38, stepSize: 5 },
      rsi_overbought: { min: 62, max: 82, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v13_146.params.json"
  },
  combo_v14: {
    class: ComboV14Strategy,
    params: {
      bb_period: { min: 6, max: 14, stepSize: 1 },
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      std_mult: { min: 1.7000000000000002, max: 3, stepSize: 0.1 },
      rsi_oversold: { min: 16, max: 36, stepSize: 5 },
      rsi_overbought: { min: 64, max: 84, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v14_147.params.json"
  },
  combo_v15: {
    class: ComboV15Strategy,
    params: {
      bb_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v15_148.params.json"
  },
  combo_v16: {
    class: ComboV16Strategy,
    params: {
      bb_period: { min: 3, max: 11, stepSize: 1 },
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v16_149.params.json"
  },
  combo_v17: {
    class: ComboV17Strategy,
    params: {
      bb_period: { min: 4, max: 12, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v17_150.params.json"
  },
  combo_v18: {
    class: ComboV18Strategy,
    params: {
      bb_period: { min: 4, max: 12, stepSize: 1 },
      rsi_period: { min: 3, max: 9, stepSize: 1 },
      std_mult: { min: 1.5, max: 2.8, stepSize: 0.1 },
      rsi_oversold: { min: 15, max: 35, stepSize: 5 },
      rsi_overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v18_151.params.json"
  },
  combo_v19: {
    class: ComboV19Strategy,
    params: {
      bb_period: { min: 2, max: 8, stepSize: 1 },
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      std_mult: { min: 0.8, max: 2, stepSize: 0.1 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v19_152.params.json"
  },
  combo_v20: {
    class: ComboV20Strategy,
    params: {
      bb_period: { min: 15, max: 23, stepSize: 1 },
      rsi_period: { min: 8, max: 14, stepSize: 1 },
      std_mult: { min: 2.5, max: 3.8, stepSize: 0.1 },
      rsi_oversold: { min: 10, max: 25, stepSize: 5 },
      rsi_overbought: { min: 75, max: 90, stepSize: 5 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_combo_v20_153.params.json"
  },
  stoch_v01: {
    class: StochV01Strategy,
    params: {
      k_period: { min: 2, max: 8, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 5, max: 25, stepSize: 5 },
      overbought: { min: 75, max: 95, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v01_154.params.json"
  },
  stoch_v02: {
    class: StochV02Strategy,
    params: {
      k_period: { min: 2, max: 9, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v02_155.params.json"
  },
  stoch_v03: {
    class: StochV03Strategy,
    params: {
      k_period: { min: 2, max: 10, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v03_156.params.json"
  },
  stoch_v04: {
    class: StochV04Strategy,
    params: {
      k_period: { min: 2, max: 10, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 5, max: 25, stepSize: 5 },
      overbought: { min: 75, max: 95, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v04_157.params.json"
  },
  stoch_v05: {
    class: StochV05Strategy,
    params: {
      k_period: { min: 4, max: 12, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v05_158.params.json"
  },
  stoch_v06: {
    class: StochV06Strategy,
    params: {
      k_period: { min: 5, max: 13, stepSize: 1 },
      d_period: { min: 3, max: 7, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v06_159.params.json"
  },
  stoch_v07: {
    class: StochV07Strategy,
    params: {
      k_period: { min: 7, max: 15, stepSize: 1 },
      d_period: { min: 3, max: 7, stepSize: 1 },
      oversold: { min: 5, max: 25, stepSize: 5 },
      overbought: { min: 75, max: 95, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v07_160.params.json"
  },
  stoch_v08: {
    class: StochV08Strategy,
    params: {
      k_period: { min: 9, max: 17, stepSize: 1 },
      d_period: { min: 4, max: 8, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v08_161.params.json"
  },
  stoch_v09: {
    class: StochV09Strategy,
    params: {
      k_period: { min: 9, max: 17, stepSize: 1 },
      d_period: { min: 4, max: 8, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v09_162.params.json"
  },
  stoch_v10: {
    class: StochV10Strategy,
    params: {
      k_period: { min: 11, max: 19, stepSize: 1 },
      d_period: { min: 5, max: 9, stepSize: 1 },
      oversold: { min: 5, max: 25, stepSize: 5 },
      overbought: { min: 75, max: 95, stepSize: 5 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v10_163.params.json"
  },
  stoch_v11: {
    class: StochV11Strategy,
    params: {
      k_period: { min: 2, max: 8, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v11_164.params.json"
  },
  stoch_v12: {
    class: StochV12Strategy,
    params: {
      k_period: { min: 11, max: 19, stepSize: 1 },
      d_period: { min: 5, max: 9, stepSize: 1 },
      oversold: { min: 5, max: 20, stepSize: 5 },
      overbought: { min: 80, max: 95, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v12_165.params.json"
  },
  stoch_v13: {
    class: StochV13Strategy,
    params: {
      k_period: { min: 3, max: 11, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 12, max: 32, stepSize: 5 },
      overbought: { min: 68, max: 88, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v13_166.params.json"
  },
  stoch_v14: {
    class: StochV14Strategy,
    params: {
      k_period: { min: 6, max: 14, stepSize: 1 },
      d_period: { min: 3, max: 7, stepSize: 1 },
      oversold: { min: 8, max: 28, stepSize: 5 },
      overbought: { min: 72, max: 92, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v14_167.params.json"
  },
  stoch_v15: {
    class: StochV15Strategy,
    params: {
      k_period: { min: 3, max: 11, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v15_168.params.json"
  },
  stoch_v16: {
    class: StochV16Strategy,
    params: {
      k_period: { min: 3, max: 11, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v16_169.params.json"
  },
  stoch_v17: {
    class: StochV17Strategy,
    params: {
      k_period: { min: 4, max: 12, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v17_170.params.json"
  },
  stoch_v18: {
    class: StochV18Strategy,
    params: {
      k_period: { min: 4, max: 12, stepSize: 1 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v18_171.params.json"
  },
  stoch_v19: {
    class: StochV19Strategy,
    params: {
      k_period: { min: 2, max: 8, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v19_172.params.json"
  },
  stoch_v20: {
    class: StochV20Strategy,
    params: {
      k_period: { min: 15, max: 23, stepSize: 1 },
      d_period: { min: 6, max: 10, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v20_173.params.json"
  },
  pat_v01: {
    class: PatV01Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v01_174.params.json"
  },
  pat_v02: {
    class: PatV02Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v02_175.params.json"
  },
  pat_v03: {
    class: PatV03Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v03_176.params.json"
  },
  pat_v04: {
    class: PatV04Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v04_177.params.json"
  },
  pat_v05: {
    class: PatV05Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 5, stepSize: 1 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v05_178.params.json"
  },
  pat_v06: {
    class: PatV06Strategy,
    params: {
      consec_bars: { min: 3, max: 6, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v06_179.params.json"
  },
  pat_v07: {
    class: PatV07Strategy,
    params: {
      consec_bars: { min: 3, max: 6, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      trailing_stop: { min: 0.030000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v07_180.params.json"
  },
  pat_v08: {
    class: PatV08Strategy,
    params: {
      consec_bars: { min: 3, max: 6, stepSize: 1 },
      exit_bars: { min: 1, max: 5, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.32999999999999996, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v08_181.params.json"
  },
  pat_v09: {
    class: PatV09Strategy,
    params: {
      consec_bars: { min: 4, max: 7, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.13, stepSize: 0.01 },
      trailing_stop: { min: 0.039999999999999994, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v09_182.params.json"
  },
  pat_v10: {
    class: PatV10Strategy,
    params: {
      consec_bars: { min: 4, max: 7, stepSize: 1 },
      exit_bars: { min: 1, max: 5, stepSize: 1 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      trailing_stop: { min: 0.05, max: 0.11000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.35, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v10_183.params.json"
  },
  pat_v11: {
    class: PatV11Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v11_184.params.json"
  },
  pat_v12: {
    class: PatV12Strategy,
    params: {
      consec_bars: { min: 3, max: 6, stepSize: 1 },
      exit_bars: { min: 1, max: 5, stepSize: 1 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v12_185.params.json"
  },
  pat_v13: {
    class: PatV13Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v13_186.params.json"
  },
  pat_v14: {
    class: PatV14Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.29000000000000004, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v14_187.params.json"
  },
  pat_v15: {
    class: PatV15Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.01, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v15_188.params.json"
  },
  pat_v16: {
    class: PatV16Strategy,
    params: {
      consec_bars: { min: 2, max: 5, stepSize: 1 },
      exit_bars: { min: 1, max: 4, stepSize: 1 },
      stop_loss: { min: 0.09, max: 0.16999999999999998, stepSize: 0.01 },
      trailing_stop: { min: 0.06, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v16_189.params.json"
  },
  pat_v17: {
    class: PatV17Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v17_190.params.json"
  },
  pat_v18: {
    class: PatV18Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v18_191.params.json"
  },
  pat_v19: {
    class: PatV19Strategy,
    params: {
      consec_bars: { min: 2, max: 4, stepSize: 1 },
      exit_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.01, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v19_192.params.json"
  },
  pat_v20: {
    class: PatV20Strategy,
    params: {
      consec_bars: { min: 4, max: 7, stepSize: 1 },
      exit_bars: { min: 1, max: 6, stepSize: 1 },
      stop_loss: { min: 0.07, max: 0.15000000000000002, stepSize: 0.01 },
      trailing_stop: { min: 0.06, max: 0.12, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_pat_v20_193.params.json"
  },
  rsi_d_v01: {
    class: RsiDV01Strategy,
    params: {
      rsi_period: { min: 2, max: 7, stepSize: 1 },
      divergence_lookback: { min: 3, max: 9, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.01, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.22999999999999998, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v01_194.params.json"
  },
  rsi_d_v02: {
    class: RsiDV02Strategy,
    params: {
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      divergence_lookback: { min: 3, max: 10, stepSize: 1 },
      oversold: { min: 20, max: 40, stepSize: 5 },
      overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v02_195.params.json"
  },
  rsi_d_v03: {
    class: RsiDV03Strategy,
    params: {
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      divergence_lookback: { min: 4, max: 12, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v03_196.params.json"
  },
  rsi_d_v04: {
    class: RsiDV04Strategy,
    params: {
      rsi_period: { min: 6, max: 12, stepSize: 1 },
      divergence_lookback: { min: 7, max: 15, stepSize: 1 },
      oversold: { min: 10, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 90, stepSize: 5 },
      stop_loss: { min: 0.04000000000000001, max: 0.12000000000000001, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.3, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v04_197.params.json"
  },
  rsi_d_v05: {
    class: RsiDV05Strategy,
    params: {
      rsi_period: { min: 2, max: 8, stepSize: 1 },
      divergence_lookback: { min: 3, max: 10, stepSize: 1 },
      oversold: { min: 20, max: 40, stepSize: 5 },
      overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.11, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.4, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v05_198.params.json"
  },
  rsi_d_v06: {
    class: RsiDV06Strategy,
    params: {
      rsi_period: { min: 8, max: 14, stepSize: 1 },
      divergence_lookback: { min: 9, max: 17, stepSize: 1 },
      oversold: { min: 10, max: 28, stepSize: 5 },
      overbought: { min: 72, max: 90, stepSize: 5 },
      stop_loss: { min: 0.010000000000000002, max: 0.09, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v06_199.params.json"
  },
  rsi_d_v07: {
    class: RsiDV07Strategy,
    params: {
      rsi_period: { min: 4, max: 10, stepSize: 1 },
      divergence_lookback: { min: 5, max: 13, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      stop_loss: { min: 0.020000000000000004, max: 0.1, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.27, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_d_v07_200.params.json"
  },
  stoch_v20_tweak_201: {
    class: StochV20Tweak201Strategy,
    params: {
      k_period: { min: 6, max: 12, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold_base: { min: 15, max: 30, stepSize: 5 },
      overbought_base: { min: 70, max: 85, stepSize: 5 },
      volatility_period: { min: 10, max: 30, stepSize: 5 },
      level_adjustment_factor: { min: 5, max: 20, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.12, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v20_tweak_201.params.json"
  },
  stoch_v06_tweak_202: {
    class: StochV06Tweak202Strategy,
    params: {
      k_period: { min: 8, max: 16, stepSize: 2 },
      d_period: { min: 3, max: 7, stepSize: 1 },
      oversold: { min: 10, max: 25, stepSize: 5 },
      overbought: { min: 75, max: 90, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 },
      ma_period: { min: 10, max: 30, stepSize: 5 },
      use_trend_filter: { min: 0, max: 1, stepSize: 1 },
      use_mtf_confirmation: { min: 0, max: 1, stepSize: 1 },
      use_dynamic_sizing: { min: 0, max: 1, stepSize: 1 },
      mtf_threshold: { min: 0.3, max: 0.7, stepSize: 0.1 }
    },
    outputFile: "strat_stoch_v06_tweak_202.params.json"
  },
  stoch_v09_tweak_203: {
    class: StochV09Tweak203Strategy,
    params: {
      k_period: { min: 6, max: 14, stepSize: 2 },
      d_period: { min: 2, max: 6, stepSize: 1 },
      oversold: { min: 15, max: 35, stepSize: 5 },
      overbought: { min: 65, max: 85, stepSize: 5 },
      rsi_period: { min: 10, max: 20, stepSize: 2 },
      rsi_oversold_max: { min: 30, max: 50, stepSize: 5 },
      rsi_overbought_min: { min: 50, max: 70, stepSize: 5 },
      divergence_lookback: { min: 3, max: 8, stepSize: 1 },
      enable_divergence: { min: 0, max: 1, stepSize: 1 },
      enable_rsi_confirm: { min: 0, max: 1, stepSize: 1 },
      profit_level_1: { min: 0.03, max: 0.08, stepSize: 0.01 },
      profit_level_2: { min: 0.06, max: 0.15, stepSize: 0.03 },
      partial_close_pct_1: { min: 0.3, max: 0.6, stepSize: 0.1 },
      partial_close_pct_2: { min: 0.3, max: 0.7, stepSize: 0.1 },
      stop_loss: { min: 0.04, max: 0.1, stepSize: 0.02 },
      risk_percent: { min: 0.08, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_stoch_v09_tweak_203.params.json"
  },
  stoch_adaptive_204: {
    class: StochAdaptiveStrategy,
    params: {
      min_k_period: { min: 2, max: 5, stepSize: 1 },
      max_k_period: { min: 10, max: 20, stepSize: 2 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      percentile_lookback: { min: 10, max: 30, stepSize: 5 },
      oversold_percentile: { min: 10, max: 25, stepSize: 5 },
      overbought_percentile: { min: 75, max: 90, stepSize: 5 },
      atr_period: { min: 10, max: 20, stepSize: 2 },
      min_atr_threshold: { min: 0.002, max: 0.01, stepSize: 0.002 },
      volatility_scale: { min: 30, max: 70, stepSize: 10 },
      stop_loss: { min: 0.02, max: 0.08, stepSize: 0.02 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_adaptive_204.params.json"
  },
  rsi_stoch_combo_205: {
    class: RsiStochCombo205Strategy,
    params: {
      rsi_period: { min: 10, max: 20, stepSize: 2 },
      divergence_lookback: { min: 3, max: 8, stepSize: 1 },
      k_period: { min: 10, max: 20, stepSize: 2 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 15, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 85, stepSize: 5 },
      signal_window: { min: 2, max: 5, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.15, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_stoch_combo_205.params.json"
  },
  volatility_breakout_206: {
    class: VolatilityBreakoutStrategy,
    params: {
      atr_period: { min: 10, max: 20, stepSize: 2 },
      atr_multiplier: { min: 0.3, max: 0.8, stepSize: 0.1 },
      lookback: { min: 10, max: 30, stepSize: 5 },
      volume_period: { min: 5, max: 15, stepSize: 5 },
      stop_loss: { min: 0.02, max: 0.08, stepSize: 0.02 },
      trailing_stop: { min: 0.015, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.15, stepSize: 0.05 }
    },
    outputFile: "strat_volatility_breakout_206.params.json"
  },
  trend_following_ma_207: {
    class: TrendFollowingMAStrategy,
    params: {
      fast_period: { min: 5, max: 20, stepSize: 5 },
      medium_period: { min: 15, max: 40, stepSize: 5 },
      slow_period: { min: 30, max: 80, stepSize: 10 },
      adx_period: { min: 10, max: 20, stepSize: 2 },
      adx_threshold: { min: 20, max: 35, stepSize: 5 },
      pullback_threshold: { min: 0.001, max: 0.02, stepSize: 0.005 },
      stop_loss: { min: 0.02, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.015, max: 0.06, stepSize: 0.015 },
      risk_percent: { min: 0.05, max: 0.25, stepSize: 0.05 },
      take_profit_enabled: { min: 0, max: 1, stepSize: 1 },
      take_profit: { min: 0.05, max: 0.15, stepSize: 0.05 }
    },
    outputFile: "strat_trend_following_ma_207.params.json"
  },
  mean_reversion_band_208: {
    class: MeanReversionBandV208Strategy,
    params: {
      bb_period: { min: 15, max: 30, stepSize: 5 },
      bb_stddev_mult: { min: 1.5, max: 2.5, stepSize: 0.25 },
      rsi_period: { min: 10, max: 20, stepSize: 2 },
      rsi_oversold: { min: 20, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 80, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.15, stepSize: 0.05 }
    },
    outputFile: "strat_mean_reversion_band_208.params.json"
  },
  stoch_v20_tweak2_209: {
    class: StochV20Tweak2_209Strategy,
    params: {
      k_period: { min: 5, max: 14, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold_base: { min: 10, max: 25, stepSize: 5 },
      overbought_base: { min: 65, max: 80, stepSize: 5 },
      volatility_period: { min: 5, max: 15, stepSize: 2 },
      level_adjustment_factor: { min: 0.1, max: 0.5, stepSize: 0.1 },
      momentum_period: { min: 3, max: 10, stepSize: 1 },
      momentum_threshold: { min: 0.005, max: 0.02, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_v20_tweak2_209.params.json"
  },
  mean_reversion_band2_210: {
    class: MeanReversionBand2_210Strategy,
    params: {
      bb_period: { min: 15, max: 30, stepSize: 5 },
      bb_stddev_mult: { min: 1.5, max: 2.5, stepSize: 0.25 },
      rsi_period: { min: 12, max: 22, stepSize: 2 },
      rsi_oversold: { min: 20, max: 35, stepSize: 5 },
      rsi_overbought: { min: 60, max: 75, stepSize: 5 },
      momentum_lookback: { min: 3, max: 8, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.05, max: 0.15, stepSize: 0.05 }
    },
    outputFile: "strat_mean_reversion_band2_210.params.json"
  },
  stoch_v06_tweak2_211: {
    class: StochV06Tweak2_211Strategy,
    params: {
      k_period: { min: 5, max: 12, stepSize: 1 },
      d_period: { min: 2, max: 5, stepSize: 1 },
      oversold: { min: 15, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 85, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.25, stepSize: 0.05 },
      ma_period: { min: 20, max: 40, stepSize: 5 },
      mtf_fast_period: { min: 3, max: 8, stepSize: 1 },
      mtf_slow_period: { min: 10, max: 20, stepSize: 2 }
    },
    outputFile: "strat_stoch_v06_tweak2_211.params.json"
  },
  momentum_vol_212: {
    class: MomentumVol212Strategy,
    params: {
      momentum_period: { min: 3, max: 10, stepSize: 1 },
      momentum_threshold: { min: 0.01, max: 0.04, stepSize: 0.005 },
      volatility_period: { min: 8, max: 16, stepSize: 2 },
      volatility_multiplier: { min: 1, max: 2, stepSize: 0.2 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_momentum_vol_212.params.json"
  },
  roc_adaptive_213: {
    class: RocAdaptive213Strategy,
    params: {
      roc_period: { min: 3, max: 10, stepSize: 1 },
      volatility_period: { min: 10, max: 20, stepSize: 2 },
      base_threshold: { min: 0.01, max: 0.03, stepSize: 0.005 },
      threshold_scale: { min: 1.5, max: 3, stepSize: 0.5 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_roc_adaptive_213.params.json"
  },
  keltner_breakout_214: {
    class: KeltnerBreakout214Strategy,
    params: {
      ema_period: { min: 15, max: 30, stepSize: 5 },
      atr_period: { min: 10, max: 18, stepSize: 2 },
      atr_multiplier: { min: 1.5, max: 3, stepSize: 0.25 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_keltner_breakout_214.params.json"
  },
  macd_stoch_combo_215: {
    class: MacdStochCombo215Strategy,
    params: {
      macd_fast: { min: 8, max: 16, stepSize: 2 },
      macd_slow: { min: 20, max: 30, stepSize: 2 },
      macd_signal: { min: 6, max: 12, stepSize: 2 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 2, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      signal_window: { min: 2, max: 5, stepSize: 1 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_macd_stoch_combo_215.params.json"
  },
  support_resistance_stoch_216: {
    class: SupportResistanceStoch216Strategy,
    params: {
      lookback: { min: 15, max: 30, stepSize: 5 },
      bounce_threshold: { min: 0.01, max: 0.03, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 2, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.08, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_support_resistance_stoch_216.params.json"
  },
  momentum_vol_tweak_217: {
    class: MomentumVolTweak217Strategy,
    params: {
      momentum_period: { min: 5, max: 12, stepSize: 1 },
      momentum_threshold: { min: 0.02, max: 0.05, stepSize: 0.005 },
      volatility_period: { min: 12, max: 20, stepSize: 2 },
      volatility_multiplier: { min: 0.8, max: 1.5, stepSize: 0.1 },
      ema_period: { min: 15, max: 30, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.06, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.05, stepSize: 0.01 },
      risk_percent: { min: 0.15, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_momentum_vol_tweak_217.params.json"
  },
  support_resistance_tweak_218: {
    class: SupportResistanceTweak218Strategy,
    params: {
      lookback: { min: 10, max: 25, stepSize: 5 },
      bounce_threshold: { min: 0.015, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 2, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.01 },
      trailing_stop: { min: 0.03, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.15, max: 0.25, stepSize: 0.05 }
    },
    outputFile: "strat_support_resistance_tweak_218.params.json"
  },
  keltner_tweak_219: {
    class: KeltnerTweak219Strategy,
    params: {
      ema_period: { min: 18, max: 35, stepSize: 3 },
      atr_period: { min: 8, max: 16, stepSize: 2 },
      atr_multiplier: { min: 2, max: 3.5, stepSize: 0.25 },
      momentum_period: { min: 3, max: 8, stepSize: 1 },
      momentum_threshold: { min: 0.005, max: 0.02, stepSize: 0.005 },
      stop_loss: { min: 0.03, max: 0.06, stepSize: 0.01 },
      trailing_stop: { min: 0.015, max: 0.035, stepSize: 0.005 },
      risk_percent: { min: 0.08, max: 0.15, stepSize: 0.02 }
    },
    outputFile: "strat_keltner_tweak_219.params.json"
  },
  dual_momentum_220: {
    class: DualMomentum220Strategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      slow_period: { min: 10, max: 20, stepSize: 2 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      momentum_threshold: { min: 0.015, max: 0.03, stepSize: 0.005 },
      vol_adj_factor: { min: 0.3, max: 0.8, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.04, stepSize: 0.005 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_dual_momentum_220.params.json"
  },
  price_range_breakout_221: {
    class: PriceRangeBreakout221Strategy,
    params: {
      lookback: { min: 10, max: 25, stepSize: 5 },
      range_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      breakout_multiplier: { min: 1.1, max: 1.4, stepSize: 0.1 },
      stop_loss: { min: 0.03, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.04, stepSize: 0.005 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_price_range_breakout_221.params.json"
  },
  velocity_222: {
    class: Velocity222Strategy,
    params: {
      velocity_period: { min: 3, max: 8, stepSize: 1 },
      acceleration_period: { min: 2, max: 5, stepSize: 1 },
      velocity_threshold: { min: 0.01, max: 0.025, stepSize: 0.005 },
      acceleration_threshold: { min: 0.003, max: 0.01, stepSize: 0.002 },
      stop_loss: { min: 0.03, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.04, stepSize: 0.005 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_velocity_222.params.json"
  },
  triple_ema_223: {
    class: TripleEMA223Strategy,
    params: {
      fast_period: { min: 3, max: 8, stepSize: 1 },
      medium_period: { min: 10, max: 18, stepSize: 2 },
      slow_period: { min: 20, max: 35, stepSize: 5 },
      stop_loss: { min: 0.03, max: 0.07, stepSize: 0.01 },
      trailing_stop: { min: 0.02, max: 0.04, stepSize: 0.005 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_triple_ema_223.params.json"
  },
  mean_rev_momentum_224: {
    class: MeanRevMomentum224Strategy,
    params: {
      lookback: { min: 15, max: 30, stepSize: 5 },
      oversold_percentile: { min: 15, max: 30, stepSize: 5 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.01, stepSize: 0.002 },
      stop_loss: { min: 0.03, max: 0.07, stepSize: 0.01 },
      take_profit: { min: 0.06, max: 0.12, stepSize: 0.02 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_mean_rev_momentum_224.params.json"
  },
  sr_adaptive_225: {
    class: SRAdaptive225Strategy,
    params: {
      base_lookback: { min: 10, max: 25, stepSize: 5 },
      min_lookback: { min: 5, max: 10, stepSize: 2 },
      max_lookback: { min: 25, max: 40, stepSize: 5 },
      volatility_period: { min: 8, max: 16, stepSize: 4 },
      bounce_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_sr_adaptive_225.params.json"
  },
  sr_multi_exit_226: {
    class: SRMultiExit226Strategy,
    params: {
      lookback: { min: 10, max: 20, stepSize: 5 },
      bounce_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.1, max: 0.2, stepSize: 0.05 },
      max_hold_bars: { min: 30, max: 80, stepSize: 10 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_sr_multi_exit_226.params.json"
  },
  sr_momentum_filter_227: {
    class: SRMomentumFilter227Strategy,
    params: {
      lookback: { min: 10, max: 20, stepSize: 5 },
      bounce_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      momentum_period: { min: 3, max: 8, stepSize: 1 },
      momentum_min: { min: 0.003, max: 0.01, stepSize: 0.002 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_sr_momentum_filter_227.params.json"
  },
  pivot_point_228: {
    class: PivotPoint228Strategy,
    params: {
      pivot_period: { min: 15, max: 30, stepSize: 5 },
      bounce_threshold: { min: 0.015, max: 0.04, stepSize: 0.01 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_pivot_point_228.params.json"
  },
  range_mean_revert_229: {
    class: RangeMeanRevert229Strategy,
    params: {
      lookback: { min: 20, max: 35, stepSize: 5 },
      range_percentile: { min: 0.08, max: 0.15, stepSize: 0.02 },
      oversold_percentile: { min: 0.1, max: 0.25, stepSize: 0.05 },
      overbought_percentile: { min: 0.75, max: 0.9, stepSize: 0.05 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_range_mean_revert_229.params.json"
  },
  breakout_confirmation_230: {
    class: BreakoutConfirmation230Strategy,
    params: {
      lookback: { min: 15, max: 25, stepSize: 5 },
      breakout_threshold: { min: 0.01, max: 0.025, stepSize: 0.005 },
      volatility_period: { min: 8, max: 16, stepSize: 4 },
      volatility_multiplier: { min: 1.1, max: 1.5, stepSize: 0.1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_breakout_confirmation_230.params.json"
  },
  stoch_rsi_231: {
    class: StochRSI231Strategy,
    params: {
      rsi_period: { min: 10, max: 18, stepSize: 2 },
      stoch_period: { min: 10, max: 18, stepSize: 2 },
      k_smooth: { min: 2, max: 4, stepSize: 1 },
      d_smooth: { min: 2, max: 4, stepSize: 1 },
      oversold: { min: 15, max: 30, stepSize: 5 },
      overbought: { min: 70, max: 85, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_stoch_rsi_231.params.json"
  },
  channel_breakout_232: {
    class: ChannelBreakout232Strategy,
    params: {
      channel_period: { min: 15, max: 30, stepSize: 5 },
      entry_threshold: { min: 0.005, max: 0.02, stepSize: 0.005 },
      confirmation_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_channel_breakout_232.params.json"
  },
  sr_adaptive_tweak_233: {
    class: SRAdaptiveTweak233Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 30, max: 50, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      base_bounce_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      vol_bounce_scale: { min: 1, max: 2.5, stepSize: 0.5 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.02 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_adaptive_tweak_233.params.json"
  },
  sr_adaptive_multi_exit_234: {
    class: SRAdaptiveMultiExit234Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.02 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      max_hold_bars: { min: 30, max: 70, stepSize: 10 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_adaptive_multi_exit_234.params.json"
  },
  sr_adaptive_momentum_235: {
    class: SRAdaptiveMomentum235Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      momentum_period: { min: 3, max: 8, stepSize: 1 },
      momentum_min: { min: 0.003, max: 0.01, stepSize: 0.002 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.02 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_adaptive_momentum_235.params.json"
  },
  rsi_adaptive_support_236: {
    class: RSIAdaptiveSupport236Strategy,
    params: {
      rsi_period: { min: 10, max: 20, stepSize: 2 },
      rsi_oversold: { min: 25, max: 40, stepSize: 5 },
      rsi_overbought: { min: 60, max: 75, stepSize: 5 },
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.02 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_rsi_adaptive_support_236.params.json"
  },
  dynamic_stoch_237: {
    class: DynamicStoch237Strategy,
    params: {
      lookback: { min: 15, max: 30, stepSize: 5 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      base_oversold: { min: 20, max: 35, stepSize: 5 },
      base_overbought: { min: 65, max: 80, stepSize: 5 },
      vol_period: { min: 8, max: 16, stepSize: 2 },
      vol_scale: { min: 50, max: 150, stepSize: 25 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.02 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_dynamic_stoch_237.params.json"
  },
  volatility_sizing_238: {
    class: VolatilitySizing238Strategy,
    params: {
      lookback: { min: 15, max: 30, stepSize: 5 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      vol_period: { min: 8, max: 16, stepSize: 2 },
      base_risk: { min: 0.1, max: 0.2, stepSize: 0.05 },
      min_risk: { min: 0.05, max: 0.12, stepSize: 0.02 },
      max_risk: { min: 0.2, max: 0.35, stepSize: 0.05 },
      vol_scale: { min: 1.5, max: 3, stepSize: 0.5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.02 }
    },
    outputFile: "strat_volatility_sizing_238.params.json"
  },
  atr_trailing_239: {
    class: ATRTrailing239Strategy,
    params: {
      lookback: { min: 15, max: 30, stepSize: 5 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      atr_period: { min: 10, max: 20, stepSize: 2 },
      atr_multiplier: { min: 1.5, max: 3, stepSize: 0.5 },
      stop_loss: { min: 0.06, max: 0.14, stepSize: 0.02 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_atr_trailing_239.params.json"
  },
  multi_timeframe_sr_240: {
    class: MultiTimeframeSR240Strategy,
    params: {
      short_lookback: { min: 6, max: 15, stepSize: 3 },
      long_lookback: { min: 20, max: 40, stepSize: 5 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.02 },
      risk_percent: { min: 0.1, max: 0.2, stepSize: 0.05 }
    },
    outputFile: "strat_multi_timeframe_sr_240.params.json"
  },
  sr_multi_exit_tweak_241: {
    class: SRMultiExitTweak241Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 60, max: 75, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.02 },
      profit_target: { min: 0.06, max: 0.14, stepSize: 0.02 },
      max_hold_bars: { min: 25, max: 50, stepSize: 5 },
      risk_percent: { min: 0.14, max: 0.22, stepSize: 0.04 }
    },
    outputFile: "strat_sr_multi_exit_tweak_241.params.json"
  },
  sr_adaptive_tweak2_242: {
    class: SRAdaptiveTweak2_242Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 35, max: 50, stepSize: 5 },
      volatility_period: { min: 8, max: 16, stepSize: 2 },
      base_bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.01 },
      vol_bounce_scale: { min: 1.5, max: 3, stepSize: 0.5 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.14, max: 0.22, stepSize: 0.04 }
    },
    outputFile: "strat_sr_adaptive_tweak2_242.params.json"
  },
  sr_momentum_tweak_243: {
    class: SRMomentumTweak243Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 35, max: 50, stepSize: 5 },
      volatility_period: { min: 8, max: 16, stepSize: 2 },
      bounce_threshold: { min: 0.03, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 22, max: 35, stepSize: 4 },
      stoch_overbought: { min: 62, max: 75, stepSize: 4 },
      momentum_period: { min: 3, max: 6, stepSize: 1 },
      momentum_min: { min: 0.002, max: 0.008, stepSize: 0.002 },
      stop_loss: { min: 0.07, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.14, max: 0.2, stepSize: 0.03 }
    },
    outputFile: "strat_sr_momentum_tweak_243.params.json"
  },
  sr_multi_momentum_244: {
    class: SRMultiMomentum244Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.03, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 22, max: 35, stepSize: 4 },
      stoch_overbought: { min: 62, max: 75, stepSize: 4 },
      momentum_period: { min: 3, max: 6, stepSize: 1 },
      momentum_min: { min: 0.002, max: 0.008, stepSize: 0.002 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.06, max: 0.14, stepSize: 0.02 },
      max_hold_bars: { min: 30, max: 60, stepSize: 10 },
      risk_percent: { min: 0.14, max: 0.2, stepSize: 0.03 }
    },
    outputFile: "strat_sr_multi_momentum_244.params.json"
  },
  sr_rsi_confirm_245: {
    class: SRRSIConfirm245Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      rsi_period: { min: 10, max: 18, stepSize: 2 },
      rsi_oversold: { min: 30, max: 45, stepSize: 5 },
      rsi_overbought: { min: 60, max: 75, stepSize: 5 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 25, max: 40, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_rsi_confirm_245.params.json"
  },
  sr_asymmetric_246: {
    class: SRAsymmetric246Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      stop_loss: { min: 0.04, max: 0.08, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.06, stepSize: 0.01 },
      target_multiplier: { min: 2, max: 3.5, stepSize: 0.5 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_asymmetric_246.params.json"
  },
  sr_trend_strength_247: {
    class: SRTrendStrength247Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 35, stepSize: 5 },
      stoch_overbought: { min: 65, max: 80, stepSize: 5 },
      trend_period: { min: 15, max: 30, stepSize: 5 },
      trend_threshold: { min: -0.04, max: 0, stepSize: 0.01 },
      stop_loss: { min: 0.06, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.04 }
    },
    outputFile: "strat_sr_trend_strength_247.params.json"
  },
  sr_double_confirm_248: {
    class: SRDoubleConfirm248Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 30, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 22, max: 35, stepSize: 4 },
      stoch_overbought: { min: 62, max: 75, stepSize: 4 },
      bounce_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      risk_percent: { min: 0.14, max: 0.2, stepSize: 0.03 }
    },
    outputFile: "strat_sr_double_confirm_248.params.json"
  },
  sr_trend_strict_249: {
    class: SRTrendStrict249Strategy,
    params: {
      base_lookback: { min: 15, max: 30, stepSize: 5 },
      min_lookback: { min: 5, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 45, stepSize: 5 },
      volatility_period: { min: 8, max: 15, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.05, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 18, max: 32, stepSize: 4 },
      stoch_overbought: { min: 65, max: 78, stepSize: 4 },
      trend_period: { min: 18, max: 35, stepSize: 5 },
      trend_threshold: { min: 0, max: 0.03, stepSize: 0.01 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.12, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_trend_strict_249.params.json"
  },
  sr_multi_trend_250: {
    class: SRMultiTrend250Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 30, stepSize: 5 },
      stoch_overbought: { min: 60, max: 72, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.03, max: 0, stepSize: 0.01 },
      stop_loss: { min: 0.05, max: 0.09, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.06, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.14, stepSize: 0.02 },
      max_hold_bars: { min: 25, max: 45, stepSize: 5 },
      risk_percent: { min: 0.14, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_multi_trend_250.params.json"
  },
  sr_adaptive_target_251: {
    class: SRAdaptiveTarget251Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 32, max: 48, stepSize: 5 },
      volatility_period: { min: 8, max: 16, stepSize: 2 },
      base_bounce_threshold: { min: 0.018, max: 0.035, stepSize: 0.005 },
      vol_bounce_scale: { min: 1.5, max: 2.8, stepSize: 0.4 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 30, stepSize: 5 },
      stoch_overbought: { min: 65, max: 78, stepSize: 4 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      risk_percent: { min: 0.14, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_adaptive_target_251.params.json"
  },
  sr_momentum_trend_252: {
    class: SRMomentumTrend252Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 30, stepSize: 5 },
      stoch_overbought: { min: 65, max: 78, stepSize: 4 },
      momentum_period: { min: 3, max: 8, stepSize: 1 },
      momentum_threshold: { min: 0.002, max: 0.01, stepSize: 0.002 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0.01, stepSize: 0.01 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.13, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_momentum_trend_252.params.json"
  },
  sr_triple_confirm_253: {
    class: SRTripleConfirm253Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 25, stepSize: 5 },
      stoch_overbought: { min: 70, max: 82, stepSize: 4 },
      momentum_period: { min: 3, max: 7, stepSize: 2 },
      momentum_threshold: { min: 0.001, max: 0.006, stepSize: 0.001 },
      trend_period: { min: 18, max: 32, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0.01, stepSize: 0.01 },
      stop_loss: { min: 0.05, max: 0.09, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.06, stepSize: 0.01 },
      profit_target: { min: 0.1, max: 0.2, stepSize: 0.03 },
      risk_percent: { min: 0.15, max: 0.22, stepSize: 0.02 }
    },
    outputFile: "strat_sr_triple_confirm_253.params.json"
  },
  sr_range_vol_254: {
    class: SRRangeVol254Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 30, stepSize: 5 },
      stoch_overbought: { min: 65, max: 78, stepSize: 4 },
      range_period: { min: 6, max: 15, stepSize: 3 },
      range_multiplier: { min: 1, max: 1.6, stepSize: 0.2 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.03, max: 0, stepSize: 0.01 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.13, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_range_vol_254.params.json"
  },
  sr_long_trend_255: {
    class: SRLongTrend255Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.01 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 20, max: 30, stepSize: 5 },
      stoch_overbought: { min: 65, max: 78, stepSize: 4 },
      short_trend_period: { min: 6, max: 15, stepSize: 3 },
      long_trend_period: { min: 30, max: 55, stepSize: 5 },
      short_trend_threshold: { min: -0.03, max: 0, stepSize: 0.01 },
      long_trend_threshold: { min: -0.08, max: -0.02, stepSize: 0.02 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.13, max: 0.2, stepSize: 0.02 }
    },
    outputFile: "strat_sr_long_trend_255.params.json"
  },
  sr_strict_entry_256: {
    class: SRStrictEntry256Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.018, max: 0.035, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 25, stepSize: 5 },
      stoch_overbought: { min: 70, max: 82, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.01, max: 0.02, stepSize: 0.01 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.002, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.09, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.06, stepSize: 0.01 },
      risk_percent: { min: 0.16, max: 0.24, stepSize: 0.02 }
    },
    outputFile: "strat_sr_strict_entry_256.params.json"
  },
  sr_strict_loose_257: {
    class: SRStrictLoose257Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 22, max: 35, stepSize: 4 },
      stoch_overbought: { min: 68, max: 80, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0.01, stepSize: 0.01 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.002, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.14, max: 0.26, stepSize: 0.02 }
    },
    outputFile: "strat_sr_strict_loose_257.params.json"
  },
  sr_strict_momentum_258: {
    class: SRStrictMomentum258Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.018, max: 0.038, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 18, max: 32, stepSize: 4 },
      stoch_overbought: { min: 70, max: 82, stepSize: 4 },
      trend_period: { min: 18, max: 32, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0.005, stepSize: 0.008 },
      momentum_period: { min: 2, max: 6, stepSize: 1 },
      momentum_threshold: { min: 0.001, max: 0.005, stepSize: 0.001 },
      min_bounce_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_strict_momentum_258.params.json"
  },
  sr_trend_multi_exit_259: {
    class: SRTrendMultiExit259Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 18, max: 32, stepSize: 4 },
      stoch_overbought: { min: 66, max: 78, stepSize: 4 },
      trend_period: { min: 18, max: 32, stepSize: 4 },
      trend_threshold: { min: 0.002, max: 0.02, stepSize: 0.006 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.18, stepSize: 0.02 },
      max_hold_bars: { min: 25, max: 55, stepSize: 10 },
      risk_percent: { min: 0.12, max: 0.24, stepSize: 0.02 }
    },
    outputFile: "strat_sr_trend_multi_exit_259.params.json"
  },
  sr_strict_multi_exit_260: {
    class: SRStrictMultiExit260Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.015, max: 0.035, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 16, max: 28, stepSize: 4 },
      stoch_overbought: { min: 70, max: 82, stepSize: 4 },
      trend_period: { min: 16, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.01, stepSize: 0.008 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.009, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.1, max: 0.2, stepSize: 0.02 },
      max_hold_bars: { min: 25, max: 45, stepSize: 10 },
      risk_percent: { min: 0.14, max: 0.26, stepSize: 0.02 }
    },
    outputFile: "strat_sr_strict_multi_exit_260.params.json"
  },
  sr_very_strict_261: {
    class: SRVeryStrict261Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.015, max: 0.03, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 12, max: 24, stepSize: 4 },
      stoch_overbought: { min: 74, max: 86, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: 0, max: 0.015, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.005, max: 0.012, stepSize: 0.002 },
      min_bounce_bars: { min: 2, max: 4, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.09, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.18, max: 0.3, stepSize: 0.02 }
    },
    outputFile: "strat_sr_very_strict_261.params.json"
  },
  sr_bounce_quality_262: {
    class: SRBounceQuality262Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 18, max: 32, stepSize: 4 },
      stoch_overbought: { min: 68, max: 80, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0.01, stepSize: 0.01 },
      min_bounce_bars: { min: 1, max: 3, stepSize: 1 },
      min_bounce_gain: { min: 0.005, max: 0.02, stepSize: 0.005 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.14, max: 0.26, stepSize: 0.02 }
    },
    outputFile: "strat_sr_bounce_quality_262.params.json"
  },
  sr_weighted_trend_263: {
    class: SRWeightedTrend263Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 18, max: 32, stepSize: 4 },
      stoch_overbought: { min: 68, max: 80, stepSize: 4 },
      trend_period: { min: 15, max: 28, stepSize: 4 },
      trend_weight: { min: 0.4, max: 0.8, stepSize: 0.1 },
      momentum_period: { min: 3, max: 7, stepSize: 1 },
      momentum_weight: { min: 0.2, max: 0.6, stepSize: 0.1 },
      min_score: { min: 0.001, max: 0.006, stepSize: 0.001 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.12, max: 0.24, stepSize: 0.02 }
    },
    outputFile: "strat_sr_weighted_trend_263.params.json"
  },
  sr_adaptive_strict_264: {
    class: SRAdaptiveStrict264Strategy,
    params: {
      base_lookback: { min: 15, max: 28, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      base_bounce_threshold: { min: 0.015, max: 0.035, stepSize: 0.005 },
      vol_bounce_scale: { min: 1.2, max: 2.4, stepSize: 0.3 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      base_stoch_oversold: { min: 16, max: 28, stepSize: 4 },
      stoch_overbought: { min: 70, max: 82, stepSize: 4 },
      trend_period: { min: 16, max: 28, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.01, stepSize: 0.008 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.009, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 3, stepSize: 1 },
      stop_loss: { min: 0.05, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.07, stepSize: 0.01 },
      risk_percent: { min: 0.14, max: 0.26, stepSize: 0.02 }
    },
    outputFile: "strat_sr_adaptive_strict_264.params.json"
  },
  sr_multi_exit_high_pt_265: {
    class: SRMultiExitHighPT265Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.01 },
      profit_target: { min: 0.15, max: 0.25, stepSize: 0.025 },
      max_hold_bars: { min: 35, max: 60, stepSize: 8 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_multi_exit_high_pt_265.params.json"
  },
  sr_multi_exit_short_hold_266: {
    class: SRMultiExitShortHold266Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      max_hold_bars: { min: 15, max: 35, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_multi_exit_short_hold_266.params.json"
  },
  sr_multi_exit_tight_trail_267: {
    class: SRMultiExitTightTrail267Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.025, max: 0.055, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_multi_exit_tight_trail_267.params.json"
  },
  sr_adaptive_multi_exit_268: {
    class: SRAdaptiveMultiExit268Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 6, max: 12, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 10, max: 18, stepSize: 2 },
      base_bounce_threshold: { min: 0.025, max: 0.045, stepSize: 0.005 },
      vol_bounce_scale: { min: 1, max: 2, stepSize: 0.2 },
      stoch_k_period: { min: 10, max: 18, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      base_stoch_oversold: { min: 15, max: 25, stepSize: 3 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.02, max: 0, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.006, max: 0.012, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.07, max: 0.12, stepSize: 0.02 },
      trailing_stop: { min: 0.03, max: 0.07, stepSize: 0.01 },
      profit_target: { min: 0.08, max: 0.16, stepSize: 0.02 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.18, max: 0.3, stepSize: 0.02 }
    },
    outputFile: "strat_sr_adaptive_multi_exit_268.params.json"
  },
  sr_dynamic_pt_269: {
    class: SRDynamicPT269Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 8, max: 14, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.01 },
      base_profit_target: { min: 0.06, max: 0.14, stepSize: 0.02 },
      vol_pt_scale: { min: 1, max: 3, stepSize: 0.5 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_dynamic_pt_269.params.json"
  },
  sr_tiered_exit_270: {
    class: SRTieredExit270Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.01 },
      first_target: { min: 0.05, max: 0.1, stepSize: 0.015 },
      second_target: { min: 0.12, max: 0.2, stepSize: 0.02 },
      first_exit_pct: { min: 0.3, max: 0.6, stepSize: 0.1 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_tiered_exit_270.params.json"
  },
  sr_momentum_exit_271: {
    class: SRMomentumExit271Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      base_trailing_stop: { min: 0.05, max: 0.09, stepSize: 0.01 },
      momentum_trail_scale: { min: 0.3, max: 0.7, stepSize: 0.1 },
      profit_target: { min: 0.1, max: 0.2, stepSize: 0.025 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_momentum_exit_271.params.json"
  },
  sr_rsi_exit_272: {
    class: SRRsiExit272Strategy,
    params: {
      base_lookback: { min: 12, max: 24, stepSize: 4 },
      min_lookback: { min: 4, max: 10, stepSize: 2 },
      max_lookback: { min: 28, max: 42, stepSize: 5 },
      volatility_period: { min: 6, max: 12, stepSize: 2 },
      bounce_threshold: { min: 0.02, max: 0.04, stepSize: 0.005 },
      stoch_k_period: { min: 12, max: 20, stepSize: 2 },
      stoch_d_period: { min: 3, max: 5, stepSize: 1 },
      stoch_oversold: { min: 15, max: 28, stepSize: 4 },
      stoch_overbought: { min: 72, max: 84, stepSize: 4 },
      trend_period: { min: 18, max: 30, stepSize: 4 },
      trend_threshold: { min: -0.015, max: 0.005, stepSize: 0.005 },
      momentum_period: { min: 2, max: 5, stepSize: 1 },
      momentum_threshold: { min: 0.003, max: 0.008, stepSize: 0.002 },
      min_bounce_bars: { min: 1, max: 2, stepSize: 1 },
      rsi_period: { min: 10, max: 18, stepSize: 2 },
      rsi_overbought: { min: 65, max: 80, stepSize: 5 },
      stop_loss: { min: 0.06, max: 0.1, stepSize: 0.02 },
      trailing_stop: { min: 0.04, max: 0.08, stepSize: 0.01 },
      profit_target: { min: 0.1, max: 0.2, stepSize: 0.025 },
      max_hold_bars: { min: 30, max: 50, stepSize: 5 },
      risk_percent: { min: 0.16, max: 0.28, stepSize: 0.02 }
    },
    outputFile: "strat_sr_rsi_exit_272.params.json"
  }
};
function seededShuffle(array, seed) {
  const result = [...array];
  for (let i = result.length - 1;i > 0; i--) {
    seed = seed * 1103515245 + 12345 & 2147483647;
    const j = seed % (i + 1);
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
function testParams(data, strategyClass, params) {
  const strategy = new strategyClass(params);
  const engine = new BacktestEngine(data, strategy, { feeRate: 0.002 });
  const originalLog = console.log;
  console.log = () => {};
  try {
    const result = engine.run();
    return {
      return: result.totalReturn,
      sharpe: result.sharpeRatio,
      trades: result.totalTrades,
      stdDev: 0
    };
  } finally {
    console.log = originalLog;
  }
}
var program2 = new Command;
program2.name("optimize").description("Differential Evolution Optimization for Trading Strategy").option("-l, --list-strategies", "List available strategies").option("-s, --strategy <name>", "Strategy to optimize", "simple_ma").option("-i, --max-iterations <number>", "Maximum generations", "30").option("-r, --random-samples <number>", "Initial random samples", "50").option("-d, --data <file>", "Data file path", "data/test-data.bson").option("-m, --min-test-return <number>", "Minimum test return to accept", "10").option("-a, --attempts <number>", "Number of optimization attempts", "5").option("-t, --max-tokens <number>", "Maximum number of tokens to use", "500").action(async (options) => {
  if (options.listStrategies) {
    console.log(kleur_default.cyan("Available strategies:"));
    for (const [name, config] of Object.entries(strategies)) {
      console.log("  " + kleur_default.green(name) + " -> " + config.outputFile);
    }
    process.exit(0);
  }
  if (options.plot) {
    const historyPath2 = path273.join(process.cwd(), "data", "optimization-history.json");
    if (!fs273.existsSync(historyPath2)) {
      console.error(kleur_default.red("No optimization history found. Run optimize first."));
      process.exit(1);
    }
    const historyData2 = JSON.parse(fs273.readFileSync(historyPath2, "utf-8"));
    console.log(kleur_default.cyan(`Optimization Progress
`));
    console.log("Generation | Sharpe Ratio");
    console.log("-".repeat(30));
    for (const entry of historyData2.history) {
      console.log(String(entry.iteration).padStart(10) + " | " + entry.sharpeRatio.toFixed(4));
    }
    console.log("-".repeat(30));
    console.log(`
Best params:`);
    for (const [k, v] of Object.entries(historyData2.bestParams)) {
      if (k !== "metadata")
        console.log("  " + k + ": " + v);
    }
    console.log(`
Performance:`);
    console.log("  Test Return: " + historyData2.finalMetrics.testReturn.toFixed(2) + " (" + (historyData2.finalMetrics.testReturn / 10).toFixed(1) + "%)");
    console.log("  Test Sharpe: " + historyData2.finalMetrics.testSharpe.toFixed(4));
    console.log("  Test Trades: " + historyData2.finalMetrics.testTrades);
    process.exit(0);
  }
  const strategyName = options.strategy;
  const strategyConfig = strategies[strategyName];
  if (!strategyConfig) {
    console.error(kleur_default.red("Unknown strategy: " + strategyName));
    console.log(kleur_default.yellow("Available strategies:") + " " + Object.keys(strategies).join(", "));
    process.exit(1);
  }
  const StrategyClass = strategyConfig.class;
  const paramConfigs = strategyConfig.params;
  const outputFile = strategyConfig.outputFile;
  const maxIterations = parseInt(options.maxIterations);
  const randomSamples = parseInt(options.randomSamples);
  const dataFile = options.data;
  const minTestReturn = parseFloat(options.minTestReturn);
  const attempts = parseInt(options.attempts);
  const maxTokens = parseInt(options.maxTokens);
  console.log(kleur_default.cyan("Strategy:") + " " + strategyName);
  console.log(kleur_default.cyan("Loading data from:") + " " + dataFile);
  const fullData = loadStoredData(dataFile);
  console.log("Loaded " + fullData.markets.length + " markets");
  console.log(kleur_default.yellow(`
Splitting data: 70% train, 30% test (by time)...`));
  let allTokens = Array.from(fullData.priceHistory.keys());
  if (allTokens.length > maxTokens) {
    allTokens = seededShuffle(allTokens, 42).slice(0, maxTokens);
    console.log("Limiting to " + maxTokens + " tokens (seeded shuffle)");
  }
  const trainPriceHistory = new Map;
  const testPriceHistory = new Map;
  for (const tokenId of allTokens) {
    const history = fullData.priceHistory.get(tokenId);
    if (!history || history.length < 10)
      continue;
    const splitIdx = Math.floor(history.length * 0.7);
    const trainHistory = history.slice(0, splitIdx);
    const testHistory = history.slice(splitIdx);
    if (trainHistory.length > 0) {
      trainPriceHistory.set(tokenId, trainHistory);
    }
    if (testHistory.length > 0) {
      testPriceHistory.set(tokenId, testHistory);
    }
  }
  const train = {
    ...fullData,
    priceHistory: trainPriceHistory
  };
  const test = {
    ...fullData,
    priceHistory: testPriceHistory
  };
  const full = fullData;
  let totalTrainPoints = 0;
  let totalTestPoints = 0;
  for (const history of train.priceHistory.values())
    totalTrainPoints += history.length;
  for (const history of test.priceHistory.values())
    totalTestPoints += history.length;
  console.log("Train: " + totalTrainPoints + " price points, Test: " + totalTestPoints + " price points (" + allTokens.length + " tokens)");
  console.log("Max generations: " + maxIterations + ", Attempts: " + attempts);
  console.log(`
` + kleur_default.bold(kleur_default.magenta("=".repeat(60))));
  console.log(kleur_default.bold(kleur_default.magenta("Differential Evolution Optimization")));
  console.log(kleur_default.bold(kleur_default.magenta("=".repeat(60))));
  let bestResult = null;
  let bestTestReturn = -Infinity;
  let bestParams = null;
  for (let attempt = 1;attempt <= attempts; attempt++) {
    console.log(kleur_default.yellow(`
Attempt ` + attempt + "/" + attempts + "..."));
    console.log(kleur_default.cyan("  Random search (" + randomSamples + " samples)..."));
    const optimizer = new DifferentialEvolutionOptimizer(train, StrategyClass, paramConfigs, {
      maxIterations,
      convergenceThreshold: 0.000001,
      learningRate: 1,
      randomSamples
    });
    optimizer.setQuiet(true);
    const result = await optimizer.optimize(attempt === 1 ? null : bestParams);
    console.log(kleur_default.cyan("  DE running..."));
    const testMetrics = testParams(test, StrategyClass, result.finalParams);
    console.log("  Train: Sharpe " + result.bestSharpe.toFixed(4) + " | Return $" + result.bestReturn.toFixed(2));
    console.log("  Test:  Sharpe " + testMetrics.sharpe.toFixed(4) + " | Return $" + testMetrics.return.toFixed(2));
    console.log("  Trades: " + testMetrics.trades);
    if (testMetrics.return > bestTestReturn) {
      bestTestReturn = testMetrics.return;
      bestResult = result;
      bestParams = result.finalParams;
      console.log(kleur_default.green("   NEW BEST"));
      if (testMetrics.return >= minTestReturn) {
        console.log(kleur_default.green(`
 Reached target test return of $` + minTestReturn));
        break;
      }
    }
  }
  if (!bestResult || !bestParams) {
    console.error(kleur_default.red(`
 Failed to find valid parameters`));
    process.exit(1);
  }
  const finalTestMetrics = testParams(test, StrategyClass, bestParams);
  const fullMetrics = testParams(full, StrategyClass, bestParams);
  const trainMetrics = testParams(train, StrategyClass, bestParams);
  console.log(`
` + kleur_default.bold(kleur_default.cyan("=".repeat(60))));
  console.log(kleur_default.bold(kleur_default.cyan("FINAL RESULTS")));
  console.log(kleur_default.bold(kleur_default.cyan("=".repeat(60))));
  console.log(`
Parameters:`);
  for (const [key, value] of Object.entries(bestParams)) {
    const config = paramConfigs[key];
    if (config.stepSize === 1 && config.min === 0 && config.max === 1) {
      console.log("  " + key + ": " + (value === 1 ? "true" : "false"));
    } else if (key === "stop_loss" || key === "risk_percent") {
      console.log("  " + key + ": " + value.toFixed(4) + " (" + (value * 100).toFixed(2) + "%)");
    } else {
      console.log("  " + key + ": " + value);
    }
  }
  console.log(`
Performance:`);
  console.log("  Train Return: $" + trainMetrics.return.toFixed(2) + " stdDev:$" + trainMetrics.stdDev.toFixed(2));
  console.log("  Train Sharpe: " + trainMetrics.sharpe.toFixed(4));
  console.log("  Test Return: $" + finalTestMetrics.return.toFixed(2) + " stdDev:$" + finalTestMetrics.stdDev.toFixed(2));
  console.log("  Test Sharpe: " + finalTestMetrics.sharpe.toFixed(4));
  console.log("  Test Trades: " + finalTestMetrics.trades);
  console.log("  Full Return: $" + fullMetrics.return.toFixed(2) + " stdDev:$" + fullMetrics.stdDev.toFixed(2));
  console.log("  Full Sharpe: " + fullMetrics.sharpe.toFixed(4));
  console.log("  Iterations: " + bestResult.iterations);
  console.log("  Converged: " + (bestResult.converged ? "Yes" : "No"));
  console.log(kleur_default.cyan(`
Optimization Progress
`));
  console.log("Generation | Sharpe Ratio");
  console.log("-".repeat(30));
  for (const entry of bestResult.history) {
    console.log(String(entry.iteration).padStart(10) + " | " + entry.sharpeRatio.toFixed(4));
  }
  console.log("-".repeat(30));
  const output = {
    ...bestParams,
    metadata: {
      best_test_return: finalTestMetrics.return,
      optimized_at: new Date().toISOString()
    }
  };
  const outputPath = path273.join(process.cwd(), "src", "strategies", outputFile);
  fs273.writeFileSync(outputPath, JSON.stringify(output, null, 2));
  console.log(kleur_default.green(`
 Parameters saved to ` + outputFile));
  const historyPath = path273.join(process.cwd(), "data", "optimization-history.json");
  const historyData = {
    strategy: strategyName,
    bestParams,
    history: bestResult.history,
    finalMetrics: {
      trainReturn: trainMetrics.return,
      trainStdDev: trainMetrics.stdDev,
      testReturn: finalTestMetrics.return,
      testStdDev: finalTestMetrics.stdDev,
      testSharpe: finalTestMetrics.sharpe,
      testTrades: finalTestMetrics.trades,
      fullReturn: fullMetrics.return,
      fullStdDev: fullMetrics.stdDev,
      fullSharpe: fullMetrics.sharpe
    }
  };
  fs273.writeFileSync(historyPath, JSON.stringify(historyData, null, 2));
  console.log(kleur_default.green(" History saved to optimization-history.json"));
});
program2.parse();
